/*
Twilio - Api

This is the public Twilio REST API.

API version: 1.29.1
Contact: support@twilio.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateAccountRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	friendlyName *string
}

// A human readable description of the account to create, defaults to &#x60;SubAccount Created at {YYYY-MM-DD HH:MM meridian}&#x60;
func (r ApiCreateAccountRequest) FriendlyName(friendlyName string) ApiCreateAccountRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiCreateAccountRequest) Execute() (*ApiV2010Account, *http.Response, error) {
	return r.ApiService.CreateAccountExecute(r)
}

/*
CreateAccount Method for CreateAccount

Create a new Twilio Subaccount from the account making the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountRequest
*/
func (a *DefaultApiService) CreateAccount(ctx context.Context) ApiCreateAccountRequest {
	return ApiCreateAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiV2010Account
func (a *DefaultApiService) CreateAccountExecute(r ApiCreateAccountRequest) (*ApiV2010Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	city *string
	customerName *string
	isoCountry *string
	postalCode *string
	region *string
	street *string
	autoCorrectAddress *bool
	emergencyEnabled *bool
	friendlyName *string
}

// The city of the new address.
func (r ApiCreateAddressRequest) City(city string) ApiCreateAddressRequest {
	r.city = &city
	return r
}

// The name to associate with the new address.
func (r ApiCreateAddressRequest) CustomerName(customerName string) ApiCreateAddressRequest {
	r.customerName = &customerName
	return r
}

// The ISO country code of the new address.
func (r ApiCreateAddressRequest) IsoCountry(isoCountry string) ApiCreateAddressRequest {
	r.isoCountry = &isoCountry
	return r
}

// The postal code of the new address.
func (r ApiCreateAddressRequest) PostalCode(postalCode string) ApiCreateAddressRequest {
	r.postalCode = &postalCode
	return r
}

// The state or region of the new address.
func (r ApiCreateAddressRequest) Region(region string) ApiCreateAddressRequest {
	r.region = &region
	return r
}

// The number and street address of the new address.
func (r ApiCreateAddressRequest) Street(street string) ApiCreateAddressRequest {
	r.street = &street
	return r
}

// Whether we should automatically correct the address. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;. If empty or &#x60;true&#x60;, we will correct the address you provide if necessary. If &#x60;false&#x60;, we won&#39;t alter the address you provide.
func (r ApiCreateAddressRequest) AutoCorrectAddress(autoCorrectAddress bool) ApiCreateAddressRequest {
	r.autoCorrectAddress = &autoCorrectAddress
	return r
}

// Whether to enable emergency calling on the new address. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiCreateAddressRequest) EmergencyEnabled(emergencyEnabled bool) ApiCreateAddressRequest {
	r.emergencyEnabled = &emergencyEnabled
	return r
}

// A descriptive string that you create to describe the new address. It can be up to 64 characters long.
func (r ApiCreateAddressRequest) FriendlyName(friendlyName string) ApiCreateAddressRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiCreateAddressRequest) Execute() (*ApiV2010AccountAddress, *http.Response, error) {
	return r.ApiService.CreateAddressExecute(r)
}

/*
CreateAddress Method for CreateAddress



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Address resource.
 @return ApiCreateAddressRequest
*/
func (a *DefaultApiService) CreateAddress(ctx context.Context, accountSid string) ApiCreateAddressRequest {
	return ApiCreateAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountAddress
func (a *DefaultApiService) CreateAddressExecute(r ApiCreateAddressRequest) (*ApiV2010AccountAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Addresses.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.city == nil {
		return localVarReturnValue, nil, reportError("city is required and must be specified")
	}
	if r.customerName == nil {
		return localVarReturnValue, nil, reportError("customerName is required and must be specified")
	}
	if r.isoCountry == nil {
		return localVarReturnValue, nil, reportError("isoCountry is required and must be specified")
	}
	if r.postalCode == nil {
		return localVarReturnValue, nil, reportError("postalCode is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.street == nil {
		return localVarReturnValue, nil, reportError("street is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoCorrectAddress != nil {
		localVarFormParams.Add("AutoCorrectAddress", parameterToString(*r.autoCorrectAddress, ""))
	}
	localVarFormParams.Add("City", parameterToString(*r.city, ""))
	localVarFormParams.Add("CustomerName", parameterToString(*r.customerName, ""))
	if r.emergencyEnabled != nil {
		localVarFormParams.Add("EmergencyEnabled", parameterToString(*r.emergencyEnabled, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	localVarFormParams.Add("IsoCountry", parameterToString(*r.isoCountry, ""))
	localVarFormParams.Add("PostalCode", parameterToString(*r.postalCode, ""))
	localVarFormParams.Add("Region", parameterToString(*r.region, ""))
	localVarFormParams.Add("Street", parameterToString(*r.street, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	apiVersion *string
	friendlyName *string
	messageStatusCallback *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsStatusCallback *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceUrl *string
}

// The API version to use to start a new TwiML session. Can be: &#x60;2010-04-01&#x60; or &#x60;2008-08-01&#x60;. The default value is the account&#39;s default API version.
func (r ApiCreateApplicationRequest) ApiVersion(apiVersion string) ApiCreateApplicationRequest {
	r.apiVersion = &apiVersion
	return r
}

// A descriptive string that you create to describe the new application. It can be up to 64 characters long.
func (r ApiCreateApplicationRequest) FriendlyName(friendlyName string) ApiCreateApplicationRequest {
	r.friendlyName = &friendlyName
	return r
}

// The URL we should call using a POST method to send message status information to your application.
func (r ApiCreateApplicationRequest) MessageStatusCallback(messageStatusCallback string) ApiCreateApplicationRequest {
	r.messageStatusCallback = &messageStatusCallback
	return r
}

// The HTTP method we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateApplicationRequest) SmsFallbackMethod(smsFallbackMethod string) ApiCreateApplicationRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while retrieving or executing the TwiML from &#x60;sms_url&#x60;.
func (r ApiCreateApplicationRequest) SmsFallbackUrl(smsFallbackUrl string) ApiCreateApplicationRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateApplicationRequest) SmsMethod(smsMethod string) ApiCreateApplicationRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call using a POST method to send status information about SMS messages sent by the application.
func (r ApiCreateApplicationRequest) SmsStatusCallback(smsStatusCallback string) ApiCreateApplicationRequest {
	r.smsStatusCallback = &smsStatusCallback
	return r
}

// The URL we should call when the phone number receives an incoming SMS message.
func (r ApiCreateApplicationRequest) SmsUrl(smsUrl string) ApiCreateApplicationRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiCreateApplicationRequest) StatusCallback(statusCallback string) ApiCreateApplicationRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateApplicationRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateApplicationRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// Whether we should look up the caller&#39;s caller-ID name from the CNAM database (additional charges apply). Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiCreateApplicationRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiCreateApplicationRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateApplicationRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiCreateApplicationRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiCreateApplicationRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiCreateApplicationRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateApplicationRequest) VoiceMethod(voiceMethod string) ApiCreateApplicationRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The URL we should call when the phone number assigned to this application receives a call.
func (r ApiCreateApplicationRequest) VoiceUrl(voiceUrl string) ApiCreateApplicationRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiCreateApplicationRequest) Execute() (*ApiV2010AccountApplication, *http.Response, error) {
	return r.ApiService.CreateApplicationExecute(r)
}

/*
CreateApplication Method for CreateApplication

Create a new application within your account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateApplicationRequest
*/
func (a *DefaultApiService) CreateApplication(ctx context.Context, accountSid string) ApiCreateApplicationRequest {
	return ApiCreateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountApplication
func (a *DefaultApiService) CreateApplicationExecute(r ApiCreateApplicationRequest) (*ApiV2010AccountApplication, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Applications.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.messageStatusCallback != nil {
		localVarFormParams.Add("MessageStatusCallback", parameterToString(*r.messageStatusCallback, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsStatusCallback != nil {
		localVarFormParams.Add("SmsStatusCallback", parameterToString(*r.smsStatusCallback, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCallRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	from *string
	to *string
	applicationSid *string
	asyncAmd *string
	asyncAmdStatusCallback *string
	asyncAmdStatusCallbackMethod *string
	byoc *string
	callReason *string
	callToken *string
	callerId *string
	fallbackMethod *string
	fallbackUrl *string
	machineDetection *string
	machineDetectionSilenceTimeout *int32
	machineDetectionSpeechEndThreshold *int32
	machineDetectionSpeechThreshold *int32
	machineDetectionTimeout *int32
	method *string
	record *bool
	recordingChannels *string
	recordingStatusCallback *string
	recordingStatusCallbackEvent *[]string
	recordingStatusCallbackMethod *string
	recordingTrack *string
	sendDigits *string
	sipAuthPassword *string
	sipAuthUsername *string
	statusCallback *string
	statusCallbackEvent *[]string
	statusCallbackMethod *string
	timeLimit *int32
	timeout *int32
	trim *string
	twiml *string
	url *string
}

// The phone number or client identifier to use as the caller id. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the &#x60;to&#x60; parameter is a phone number, &#x60;From&#x60; must also be a phone number.
func (r ApiCreateCallRequest) From(from string) ApiCreateCallRequest {
	r.from = &from
	return r
}

// The phone number, SIP address, or client identifier to call.
func (r ApiCreateCallRequest) To(to string) ApiCreateCallRequest {
	r.to = &to
	return r
}

// The SID of the Application resource that will handle the call, if the call will be handled by an application.
func (r ApiCreateCallRequest) ApplicationSid(applicationSid string) ApiCreateCallRequest {
	r.applicationSid = &applicationSid
	return r
}

// Select whether to perform answering machine detection in the background. Default, blocks the execution of the call until Answering Machine Detection is completed. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiCreateCallRequest) AsyncAmd(asyncAmd string) ApiCreateCallRequest {
	r.asyncAmd = &asyncAmd
	return r
}

// The URL that we should call using the &#x60;async_amd_status_callback_method&#x60; to notify customer application whether the call was answered by human, machine or fax.
func (r ApiCreateCallRequest) AsyncAmdStatusCallback(asyncAmdStatusCallback string) ApiCreateCallRequest {
	r.asyncAmdStatusCallback = &asyncAmdStatusCallback
	return r
}

// The HTTP method we should use when calling the &#x60;async_amd_status_callback&#x60; URL. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;.
func (r ApiCreateCallRequest) AsyncAmdStatusCallbackMethod(asyncAmdStatusCallbackMethod string) ApiCreateCallRequest {
	r.asyncAmdStatusCallbackMethod = &asyncAmdStatusCallbackMethod
	return r
}

// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that &#x60;byoc&#x60; is only meaningful when &#x60;to&#x60; is a phone number; it will otherwise be ignored. (Beta)
func (r ApiCreateCallRequest) Byoc(byoc string) ApiCreateCallRequest {
	r.byoc = &byoc
	return r
}

// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party&#39;s phone. (Branded Calls Beta)
func (r ApiCreateCallRequest) CallReason(callReason string) ApiCreateCallRequest {
	r.callReason = &callReason
	return r
}

// A token string needed to invoke a forwarded call. A call_token is generated when an incoming call is received on a Twilio number. Pass an incoming call&#39;s call_token value to a forwarded call via the call_token parameter when creating a new call. A forwarded call should bear the same CallerID of the original incoming call.
func (r ApiCreateCallRequest) CallToken(callToken string) ApiCreateCallRequest {
	r.callToken = &callToken
	return r
}

// The phone number, SIP address, or Client identifier that made this call. Phone numbers are in [E.164 format](https://wwnw.twilio.com/docs/glossary/what-e164) (e.g., +16175551212). SIP addresses are formatted as &#x60;name@company.com&#x60;.
func (r ApiCreateCallRequest) CallerId(callerId string) ApiCreateCallRequest {
	r.callerId = &callerId
	return r
}

// The HTTP method that we should use to request the &#x60;fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiCreateCallRequest) FallbackMethod(fallbackMethod string) ApiCreateCallRequest {
	r.fallbackMethod = &fallbackMethod
	return r
}

// The URL that we call using the &#x60;fallback_method&#x60; if an error occurs when requesting or executing the TwiML at &#x60;url&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiCreateCallRequest) FallbackUrl(fallbackUrl string) ApiCreateCallRequest {
	r.fallbackUrl = &fallbackUrl
	return r
}

// Whether to detect if a human, answering machine, or fax has picked up the call. Can be: &#x60;Enable&#x60; or &#x60;DetectMessageEnd&#x60;. Use &#x60;Enable&#x60; if you would like us to return &#x60;AnsweredBy&#x60; as soon as the called party is identified. Use &#x60;DetectMessageEnd&#x60;, if you would like to leave a message on an answering machine. If &#x60;send_digits&#x60; is provided, this parameter is ignored. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection).
func (r ApiCreateCallRequest) MachineDetection(machineDetection string) ApiCreateCallRequest {
	r.machineDetection = &machineDetection
	return r
}

// The number of milliseconds of initial silence after which an &#x60;unknown&#x60; AnsweredBy result will be returned. Possible Values: 2000-10000. Default: 5000.
func (r ApiCreateCallRequest) MachineDetectionSilenceTimeout(machineDetectionSilenceTimeout int32) ApiCreateCallRequest {
	r.machineDetectionSilenceTimeout = &machineDetectionSilenceTimeout
	return r
}

// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Possible Values: 500-5000. Default: 1200.
func (r ApiCreateCallRequest) MachineDetectionSpeechEndThreshold(machineDetectionSpeechEndThreshold int32) ApiCreateCallRequest {
	r.machineDetectionSpeechEndThreshold = &machineDetectionSpeechEndThreshold
	return r
}

// The number of milliseconds that is used as the measuring stick for the length of the speech activity, where durations lower than this value will be interpreted as a human and longer than this value as a machine. Possible Values: 1000-6000. Default: 2400.
func (r ApiCreateCallRequest) MachineDetectionSpeechThreshold(machineDetectionSpeechThreshold int32) ApiCreateCallRequest {
	r.machineDetectionSpeechThreshold = &machineDetectionSpeechThreshold
	return r
}

// The number of seconds that we should attempt to detect an answering machine before timing out and sending a voice request with &#x60;AnsweredBy&#x60; of &#x60;unknown&#x60;. The default timeout is 30 seconds.
func (r ApiCreateCallRequest) MachineDetectionTimeout(machineDetectionTimeout int32) ApiCreateCallRequest {
	r.machineDetectionTimeout = &machineDetectionTimeout
	return r
}

// The HTTP method we should use when calling the &#x60;url&#x60; parameter&#39;s value. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiCreateCallRequest) Method(method string) ApiCreateCallRequest {
	r.method = &method
	return r
}

// Whether to record the call. Can be &#x60;true&#x60; to record the phone call, or &#x60;false&#x60; to not. The default is &#x60;false&#x60;. The &#x60;recording_url&#x60; is sent to the &#x60;status_callback&#x60; URL.
func (r ApiCreateCallRequest) Record(record bool) ApiCreateCallRequest {
	r.record = &record
	return r
}

// The number of channels in the final recording. Can be: &#x60;mono&#x60; or &#x60;dual&#x60;. The default is &#x60;mono&#x60;. &#x60;mono&#x60; records both legs of the call in a single channel of the recording file. &#x60;dual&#x60; records each leg to a separate channel of the recording file. The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
func (r ApiCreateCallRequest) RecordingChannels(recordingChannels string) ApiCreateCallRequest {
	r.recordingChannels = &recordingChannels
	return r
}

// The URL that we call when the recording is available to be accessed.
func (r ApiCreateCallRequest) RecordingStatusCallback(recordingStatusCallback string) ApiCreateCallRequest {
	r.recordingStatusCallback = &recordingStatusCallback
	return r
}

// The recording status events that will trigger calls to the URL specified in &#x60;recording_status_callback&#x60;. Can be: &#x60;in-progress&#x60;, &#x60;completed&#x60; and &#x60;absent&#x60;. Defaults to &#x60;completed&#x60;. Separate  multiple values with a space.
func (r ApiCreateCallRequest) RecordingStatusCallbackEvent(recordingStatusCallbackEvent []string) ApiCreateCallRequest {
	r.recordingStatusCallbackEvent = &recordingStatusCallbackEvent
	return r
}

// The HTTP method we should use when calling the &#x60;recording_status_callback&#x60; URL. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;.
func (r ApiCreateCallRequest) RecordingStatusCallbackMethod(recordingStatusCallbackMethod string) ApiCreateCallRequest {
	r.recordingStatusCallbackMethod = &recordingStatusCallbackMethod
	return r
}

// The audio track to record for the call. Can be: &#x60;inbound&#x60;, &#x60;outbound&#x60; or &#x60;both&#x60;. The default is &#x60;both&#x60;. &#x60;inbound&#x60; records the audio that is received by Twilio. &#x60;outbound&#x60; records the audio that is generated from Twilio. &#x60;both&#x60; records the audio that is received and generated by Twilio.
func (r ApiCreateCallRequest) RecordingTrack(recordingTrack string) ApiCreateCallRequest {
	r.recordingTrack = &recordingTrack
	return r
}

// A string of keys to dial after connecting to the number, maximum of 32 digits. Valid digits in the string include: any digit (&#x60;0&#x60;-&#x60;9&#x60;), &#39;&#x60;#&#x60;&#39;, &#39;&#x60;*&#x60;&#39; and &#39;&#x60;w&#x60;&#39;, to insert a half second pause. For example, if you connected to a company phone number and wanted to pause for one second, and then dial extension 1234 followed by the pound key, the value of this parameter would be &#x60;ww1234#&#x60;. Remember to URL-encode this string, since the &#39;&#x60;#&#x60;&#39; character has special meaning in a URL. If both &#x60;SendDigits&#x60; and &#x60;MachineDetection&#x60; parameters are provided, then &#x60;MachineDetection&#x60; will be ignored.
func (r ApiCreateCallRequest) SendDigits(sendDigits string) ApiCreateCallRequest {
	r.sendDigits = &sendDigits
	return r
}

// The password required to authenticate the user account specified in &#x60;sip_auth_username&#x60;.
func (r ApiCreateCallRequest) SipAuthPassword(sipAuthPassword string) ApiCreateCallRequest {
	r.sipAuthPassword = &sipAuthPassword
	return r
}

// The username used to authenticate the caller making a SIP call.
func (r ApiCreateCallRequest) SipAuthUsername(sipAuthUsername string) ApiCreateCallRequest {
	r.sipAuthUsername = &sipAuthUsername
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application. If no &#x60;status_callback_event&#x60; is specified, we will send the &#x60;completed&#x60; status. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored. URLs must contain a valid hostname (underscores are not permitted).
func (r ApiCreateCallRequest) StatusCallback(statusCallback string) ApiCreateCallRequest {
	r.statusCallback = &statusCallback
	return r
}

// The call progress events that we will send to the &#x60;status_callback&#x60; URL. Can be: &#x60;initiated&#x60;, &#x60;ringing&#x60;, &#x60;answered&#x60;, and &#x60;completed&#x60;. If no event is specified, we send the &#x60;completed&#x60; status. If you want to receive multiple events, specify each one in a separate &#x60;status_callback_event&#x60; parameter. See the code sample for [monitoring call progress](https://www.twilio.com/docs/voice/api/call-resource?code-sample&#x3D;code-create-a-call-resource-and-specify-a-statuscallbackevent&amp;code-sdk-version&#x3D;json). If an &#x60;application_sid&#x60; is present, this parameter is ignored.
func (r ApiCreateCallRequest) StatusCallbackEvent(statusCallbackEvent []string) ApiCreateCallRequest {
	r.statusCallbackEvent = &statusCallbackEvent
	return r
}

// The HTTP method we should use when calling the &#x60;status_callback&#x60; URL. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiCreateCallRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateCallRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The maximum duration of the call in seconds. Constraints depend on account and configuration.
func (r ApiCreateCallRequest) TimeLimit(timeLimit int32) ApiCreateCallRequest {
	r.timeLimit = &timeLimit
	return r
}

// The integer number of seconds that we should allow the phone to ring before assuming there is no answer. The default is &#x60;60&#x60; seconds and the maximum is &#x60;600&#x60; seconds. For some call flows, we will add a 5-second buffer to the timeout value you provide. For this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds. You can set this to a short time, such as &#x60;15&#x60; seconds, to hang up before reaching an answering machine or voicemail.
func (r ApiCreateCallRequest) Timeout(timeout int32) ApiCreateCallRequest {
	r.timeout = &timeout
	return r
}

// Whether to trim any leading and trailing silence from the recording. Can be: &#x60;trim-silence&#x60; or &#x60;do-not-trim&#x60; and the default is &#x60;trim-silence&#x60;.
func (r ApiCreateCallRequest) Trim(trim string) ApiCreateCallRequest {
	r.trim = &trim
	return r
}

// TwiML instructions for the call Twilio will use without fetching Twiml from url parameter. If both &#x60;twiml&#x60; and &#x60;url&#x60; are provided then &#x60;twiml&#x60; parameter will be ignored. Max 4000 characters.
func (r ApiCreateCallRequest) Twiml(twiml string) ApiCreateCallRequest {
	r.twiml = &twiml
	return r
}

// The absolute URL that returns the TwiML instructions for the call. We will call this URL using the &#x60;method&#x60; when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls).
func (r ApiCreateCallRequest) Url(url string) ApiCreateCallRequest {
	r.url = &url
	return r
}

func (r ApiCreateCallRequest) Execute() (*ApiV2010AccountCall, *http.Response, error) {
	return r.ApiService.CreateCallExecute(r)
}

/*
CreateCall Method for CreateCall

Create a new outgoing call to phones, SIP-enabled endpoints or Twilio Client connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateCallRequest
*/
func (a *DefaultApiService) CreateCall(ctx context.Context, accountSid string) ApiCreateCallRequest {
	return ApiCreateCallRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCall
func (a *DefaultApiService) CreateCallExecute(r ApiCreateCallRequest) (*ApiV2010AccountCall, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.applicationSid != nil {
		localVarFormParams.Add("ApplicationSid", parameterToString(*r.applicationSid, ""))
	}
	if r.asyncAmd != nil {
		localVarFormParams.Add("AsyncAmd", parameterToString(*r.asyncAmd, ""))
	}
	if r.asyncAmdStatusCallback != nil {
		localVarFormParams.Add("AsyncAmdStatusCallback", parameterToString(*r.asyncAmdStatusCallback, ""))
	}
	if r.asyncAmdStatusCallbackMethod != nil {
		localVarFormParams.Add("AsyncAmdStatusCallbackMethod", parameterToString(*r.asyncAmdStatusCallbackMethod, ""))
	}
	if r.byoc != nil {
		localVarFormParams.Add("Byoc", parameterToString(*r.byoc, ""))
	}
	if r.callReason != nil {
		localVarFormParams.Add("CallReason", parameterToString(*r.callReason, ""))
	}
	if r.callToken != nil {
		localVarFormParams.Add("CallToken", parameterToString(*r.callToken, ""))
	}
	if r.callerId != nil {
		localVarFormParams.Add("CallerId", parameterToString(*r.callerId, ""))
	}
	if r.fallbackMethod != nil {
		localVarFormParams.Add("FallbackMethod", parameterToString(*r.fallbackMethod, ""))
	}
	if r.fallbackUrl != nil {
		localVarFormParams.Add("FallbackUrl", parameterToString(*r.fallbackUrl, ""))
	}
	localVarFormParams.Add("From", parameterToString(*r.from, ""))
	if r.machineDetection != nil {
		localVarFormParams.Add("MachineDetection", parameterToString(*r.machineDetection, ""))
	}
	if r.machineDetectionSilenceTimeout != nil {
		localVarFormParams.Add("MachineDetectionSilenceTimeout", parameterToString(*r.machineDetectionSilenceTimeout, ""))
	}
	if r.machineDetectionSpeechEndThreshold != nil {
		localVarFormParams.Add("MachineDetectionSpeechEndThreshold", parameterToString(*r.machineDetectionSpeechEndThreshold, ""))
	}
	if r.machineDetectionSpeechThreshold != nil {
		localVarFormParams.Add("MachineDetectionSpeechThreshold", parameterToString(*r.machineDetectionSpeechThreshold, ""))
	}
	if r.machineDetectionTimeout != nil {
		localVarFormParams.Add("MachineDetectionTimeout", parameterToString(*r.machineDetectionTimeout, ""))
	}
	if r.method != nil {
		localVarFormParams.Add("Method", parameterToString(*r.method, ""))
	}
	if r.record != nil {
		localVarFormParams.Add("Record", parameterToString(*r.record, ""))
	}
	if r.recordingChannels != nil {
		localVarFormParams.Add("RecordingChannels", parameterToString(*r.recordingChannels, ""))
	}
	if r.recordingStatusCallback != nil {
		localVarFormParams.Add("RecordingStatusCallback", parameterToString(*r.recordingStatusCallback, ""))
	}
	if r.recordingStatusCallbackEvent != nil {
		localVarFormParams.Add("RecordingStatusCallbackEvent", parameterToString(*r.recordingStatusCallbackEvent, "csv"))
	}
	if r.recordingStatusCallbackMethod != nil {
		localVarFormParams.Add("RecordingStatusCallbackMethod", parameterToString(*r.recordingStatusCallbackMethod, ""))
	}
	if r.recordingTrack != nil {
		localVarFormParams.Add("RecordingTrack", parameterToString(*r.recordingTrack, ""))
	}
	if r.sendDigits != nil {
		localVarFormParams.Add("SendDigits", parameterToString(*r.sendDigits, ""))
	}
	if r.sipAuthPassword != nil {
		localVarFormParams.Add("SipAuthPassword", parameterToString(*r.sipAuthPassword, ""))
	}
	if r.sipAuthUsername != nil {
		localVarFormParams.Add("SipAuthUsername", parameterToString(*r.sipAuthUsername, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackEvent != nil {
		localVarFormParams.Add("StatusCallbackEvent", parameterToString(*r.statusCallbackEvent, "csv"))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.timeLimit != nil {
		localVarFormParams.Add("TimeLimit", parameterToString(*r.timeLimit, ""))
	}
	if r.timeout != nil {
		localVarFormParams.Add("Timeout", parameterToString(*r.timeout, ""))
	}
	localVarFormParams.Add("To", parameterToString(*r.to, ""))
	if r.trim != nil {
		localVarFormParams.Add("Trim", parameterToString(*r.trim, ""))
	}
	if r.twiml != nil {
		localVarFormParams.Add("Twiml", parameterToString(*r.twiml, ""))
	}
	if r.url != nil {
		localVarFormParams.Add("Url", parameterToString(*r.url, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCallFeedbackSummaryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	endDate *string
	startDate *string
	includeSubaccounts *bool
	statusCallback *string
	statusCallbackMethod *string
}

// Only include feedback given on or before this date. Format is &#x60;YYYY-MM-DD&#x60; and specified in UTC.
func (r ApiCreateCallFeedbackSummaryRequest) EndDate(endDate string) ApiCreateCallFeedbackSummaryRequest {
	r.endDate = &endDate
	return r
}

// Only include feedback given on or after this date. Format is &#x60;YYYY-MM-DD&#x60; and specified in UTC.
func (r ApiCreateCallFeedbackSummaryRequest) StartDate(startDate string) ApiCreateCallFeedbackSummaryRequest {
	r.startDate = &startDate
	return r
}

// Whether to also include Feedback resources from all subaccounts. &#x60;true&#x60; includes feedback from all subaccounts and &#x60;false&#x60;, the default, includes feedback from only the specified account.
func (r ApiCreateCallFeedbackSummaryRequest) IncludeSubaccounts(includeSubaccounts bool) ApiCreateCallFeedbackSummaryRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// The URL that we will request when the feedback summary is complete.
func (r ApiCreateCallFeedbackSummaryRequest) StatusCallback(statusCallback string) ApiCreateCallFeedbackSummaryRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method (&#x60;GET&#x60; or &#x60;POST&#x60;) we use to make the request to the &#x60;StatusCallback&#x60; URL.
func (r ApiCreateCallFeedbackSummaryRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateCallFeedbackSummaryRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

func (r ApiCreateCallFeedbackSummaryRequest) Execute() (*ApiV2010AccountCallCallFeedbackSummary, *http.Response, error) {
	return r.ApiService.CreateCallFeedbackSummaryExecute(r)
}

/*
CreateCallFeedbackSummary Method for CreateCallFeedbackSummary

Create a FeedbackSummary resource for a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @return ApiCreateCallFeedbackSummaryRequest
*/
func (a *DefaultApiService) CreateCallFeedbackSummary(ctx context.Context, accountSid string) ApiCreateCallFeedbackSummaryRequest {
	return ApiCreateCallFeedbackSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallFeedbackSummary
func (a *DefaultApiService) CreateCallFeedbackSummaryExecute(r ApiCreateCallFeedbackSummaryRequest) (*ApiV2010AccountCallCallFeedbackSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallFeedbackSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateCallFeedbackSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("EndDate", parameterToString(*r.endDate, ""))
	if r.includeSubaccounts != nil {
		localVarFormParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	localVarFormParams.Add("StartDate", parameterToString(*r.startDate, ""))
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCallRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	recordingChannels *string
	recordingStatusCallback *string
	recordingStatusCallbackEvent *[]string
	recordingStatusCallbackMethod *string
	recordingTrack *string
	trim *string
}

// The number of channels used in the recording. Can be: &#x60;mono&#x60; or &#x60;dual&#x60; and the default is &#x60;mono&#x60;. &#x60;mono&#x60; records all parties of the call into one channel. &#x60;dual&#x60; records each party of a 2-party call into separate channels.
func (r ApiCreateCallRecordingRequest) RecordingChannels(recordingChannels string) ApiCreateCallRecordingRequest {
	r.recordingChannels = &recordingChannels
	return r
}

// The URL we should call using the &#x60;recording_status_callback_method&#x60; on each recording event specified in  &#x60;recording_status_callback_event&#x60;. For more information, see [RecordingStatusCallback parameters](https://www.twilio.com/docs/voice/api/recording#recordingstatuscallback).
func (r ApiCreateCallRecordingRequest) RecordingStatusCallback(recordingStatusCallback string) ApiCreateCallRecordingRequest {
	r.recordingStatusCallback = &recordingStatusCallback
	return r
}

// The recording status events on which we should call the &#x60;recording_status_callback&#x60; URL. Can be: &#x60;in-progress&#x60;, &#x60;completed&#x60; and &#x60;absent&#x60; and the default is &#x60;completed&#x60;. Separate multiple event values with a space.
func (r ApiCreateCallRecordingRequest) RecordingStatusCallbackEvent(recordingStatusCallbackEvent []string) ApiCreateCallRecordingRequest {
	r.recordingStatusCallbackEvent = &recordingStatusCallbackEvent
	return r
}

// The HTTP method we should use to call &#x60;recording_status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;.
func (r ApiCreateCallRecordingRequest) RecordingStatusCallbackMethod(recordingStatusCallbackMethod string) ApiCreateCallRecordingRequest {
	r.recordingStatusCallbackMethod = &recordingStatusCallbackMethod
	return r
}

// The audio track to record for the call. Can be: &#x60;inbound&#x60;, &#x60;outbound&#x60; or &#x60;both&#x60;. The default is &#x60;both&#x60;. &#x60;inbound&#x60; records the audio that is received by Twilio. &#x60;outbound&#x60; records the audio that is generated from Twilio. &#x60;both&#x60; records the audio that is received and generated by Twilio.
func (r ApiCreateCallRecordingRequest) RecordingTrack(recordingTrack string) ApiCreateCallRecordingRequest {
	r.recordingTrack = &recordingTrack
	return r
}

// Whether to trim any leading and trailing silence in the recording. Can be: &#x60;trim-silence&#x60; or &#x60;do-not-trim&#x60; and the default is &#x60;do-not-trim&#x60;. &#x60;trim-silence&#x60; trims the silence from the beginning and end of the recording and &#x60;do-not-trim&#x60; does not.
func (r ApiCreateCallRecordingRequest) Trim(trim string) ApiCreateCallRecordingRequest {
	r.trim = &trim
	return r
}

func (r ApiCreateCallRecordingRequest) Execute() (*ApiV2010AccountCallCallRecording, *http.Response, error) {
	return r.ApiService.CreateCallRecordingExecute(r)
}

/*
CreateCallRecording Method for CreateCallRecording

Create a recording for the call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param callSid The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) to associate the resource with.
 @return ApiCreateCallRecordingRequest
*/
func (a *DefaultApiService) CreateCallRecording(ctx context.Context, accountSid string, callSid string) ApiCreateCallRecordingRequest {
	return ApiCreateCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallRecording
func (a *DefaultApiService) CreateCallRecordingExecute(r ApiCreateCallRecordingRequest) (*ApiV2010AccountCallCallRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.recordingChannels != nil {
		localVarFormParams.Add("RecordingChannels", parameterToString(*r.recordingChannels, ""))
	}
	if r.recordingStatusCallback != nil {
		localVarFormParams.Add("RecordingStatusCallback", parameterToString(*r.recordingStatusCallback, ""))
	}
	if r.recordingStatusCallbackEvent != nil {
		localVarFormParams.Add("RecordingStatusCallbackEvent", parameterToString(*r.recordingStatusCallbackEvent, "csv"))
	}
	if r.recordingStatusCallbackMethod != nil {
		localVarFormParams.Add("RecordingStatusCallbackMethod", parameterToString(*r.recordingStatusCallbackMethod, ""))
	}
	if r.recordingTrack != nil {
		localVarFormParams.Add("RecordingTrack", parameterToString(*r.recordingTrack, ""))
	}
	if r.trim != nil {
		localVarFormParams.Add("Trim", parameterToString(*r.trim, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIncomingPhoneNumberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	addressSid *string
	apiVersion *string
	areaCode *string
	bundleSid *string
	emergencyAddressSid *string
	emergencyStatus *string
	friendlyName *string
	identitySid *string
	phoneNumber *string
	smsApplicationSid *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	trunkSid *string
	voiceApplicationSid *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceReceiveMode *string
	voiceUrl *string
}

// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
func (r ApiCreateIncomingPhoneNumberRequest) AddressSid(addressSid string) ApiCreateIncomingPhoneNumberRequest {
	r.addressSid = &addressSid
	return r
}

// The API version to use for incoming calls made to the new phone number. The default is &#x60;2010-04-01&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) ApiVersion(apiVersion string) ApiCreateIncomingPhoneNumberRequest {
	r.apiVersion = &apiVersion
	return r
}

// The desired area code for your new incoming phone number. Can be any three-digit, US or Canada area code. We will provision an available phone number within this area code for you. **You must provide an &#x60;area_code&#x60; or a &#x60;phone_number&#x60;.** (US and Canada only).
func (r ApiCreateIncomingPhoneNumberRequest) AreaCode(areaCode string) ApiCreateIncomingPhoneNumberRequest {
	r.areaCode = &areaCode
	return r
}

// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
func (r ApiCreateIncomingPhoneNumberRequest) BundleSid(bundleSid string) ApiCreateIncomingPhoneNumberRequest {
	r.bundleSid = &bundleSid
	return r
}

// The SID of the emergency address configuration to use for emergency calling from the new phone number.
func (r ApiCreateIncomingPhoneNumberRequest) EmergencyAddressSid(emergencyAddressSid string) ApiCreateIncomingPhoneNumberRequest {
	r.emergencyAddressSid = &emergencyAddressSid
	return r
}

// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
func (r ApiCreateIncomingPhoneNumberRequest) EmergencyStatus(emergencyStatus string) ApiCreateIncomingPhoneNumberRequest {
	r.emergencyStatus = &emergencyStatus
	return r
}

// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the new phone number.
func (r ApiCreateIncomingPhoneNumberRequest) FriendlyName(friendlyName string) ApiCreateIncomingPhoneNumberRequest {
	r.friendlyName = &friendlyName
	return r
}

// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
func (r ApiCreateIncomingPhoneNumberRequest) IdentitySid(identitySid string) ApiCreateIncomingPhoneNumberRequest {
	r.identitySid = &identitySid
	return r
}

// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
func (r ApiCreateIncomingPhoneNumberRequest) PhoneNumber(phoneNumber string) ApiCreateIncomingPhoneNumberRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// The SID of the application that should handle SMS messages sent to the new phone number. If an &#x60;sms_application_sid&#x60; is present, we ignore all of the &#x60;sms_*_url&#x60; urls and use those set on the application.
func (r ApiCreateIncomingPhoneNumberRequest) SmsApplicationSid(smsApplicationSid string) ApiCreateIncomingPhoneNumberRequest {
	r.smsApplicationSid = &smsApplicationSid
	return r
}

// The HTTP method that we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) SmsFallbackMethod(smsFallbackMethod string) ApiCreateIncomingPhoneNumberRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while requesting or executing the TwiML defined by &#x60;sms_url&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) SmsFallbackUrl(smsFallbackUrl string) ApiCreateIncomingPhoneNumberRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) SmsMethod(smsMethod string) ApiCreateIncomingPhoneNumberRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call when the new phone number receives an incoming SMS message.
func (r ApiCreateIncomingPhoneNumberRequest) SmsUrl(smsUrl string) ApiCreateIncomingPhoneNumberRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiCreateIncomingPhoneNumberRequest) StatusCallback(statusCallback string) ApiCreateIncomingPhoneNumberRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateIncomingPhoneNumberRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The SID of the Trunk we should use to handle calls to the new phone number. If a &#x60;trunk_sid&#x60; is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a &#x60;trunk_sid&#x60; will automatically delete your &#x60;voice_application_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberRequest) TrunkSid(trunkSid string) ApiCreateIncomingPhoneNumberRequest {
	r.trunkSid = &trunkSid
	return r
}

// The SID of the application we should use to handle calls to the new phone number. If a &#x60;voice_application_sid&#x60; is present, we ignore all of the voice urls and use only those set on the application. Setting a &#x60;voice_application_sid&#x60; will automatically delete your &#x60;trunk_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceApplicationSid(voiceApplicationSid string) ApiCreateIncomingPhoneNumberRequest {
	r.voiceApplicationSid = &voiceApplicationSid
	return r
}

// Whether to lookup the caller&#39;s name from the CNAM database and post it to your app. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiCreateIncomingPhoneNumberRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method that we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiCreateIncomingPhoneNumberRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiCreateIncomingPhoneNumberRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceMethod(voiceMethod string) ApiCreateIncomingPhoneNumberRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: &#x60;fax&#x60; or &#x60;voice&#x60; and defaults to &#x60;voice&#x60;.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceReceiveMode(voiceReceiveMode string) ApiCreateIncomingPhoneNumberRequest {
	r.voiceReceiveMode = &voiceReceiveMode
	return r
}

// The URL that we should call to answer a call to the new phone number. The &#x60;voice_url&#x60; will not be called if a &#x60;voice_application_sid&#x60; or a &#x60;trunk_sid&#x60; is set.
func (r ApiCreateIncomingPhoneNumberRequest) VoiceUrl(voiceUrl string) ApiCreateIncomingPhoneNumberRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiCreateIncomingPhoneNumberRequest) Execute() (*ApiV2010AccountIncomingPhoneNumber, *http.Response, error) {
	return r.ApiService.CreateIncomingPhoneNumberExecute(r)
}

/*
CreateIncomingPhoneNumber Method for CreateIncomingPhoneNumber

Purchase a phone-number for the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateIncomingPhoneNumberRequest
*/
func (a *DefaultApiService) CreateIncomingPhoneNumber(ctx context.Context, accountSid string) ApiCreateIncomingPhoneNumberRequest {
	return ApiCreateIncomingPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumber
func (a *DefaultApiService) CreateIncomingPhoneNumberExecute(r ApiCreateIncomingPhoneNumberRequest) (*ApiV2010AccountIncomingPhoneNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIncomingPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.addressSid != nil {
		localVarFormParams.Add("AddressSid", parameterToString(*r.addressSid, ""))
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.areaCode != nil {
		localVarFormParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.bundleSid != nil {
		localVarFormParams.Add("BundleSid", parameterToString(*r.bundleSid, ""))
	}
	if r.emergencyAddressSid != nil {
		localVarFormParams.Add("EmergencyAddressSid", parameterToString(*r.emergencyAddressSid, ""))
	}
	if r.emergencyStatus != nil {
		localVarFormParams.Add("EmergencyStatus", parameterToString(*r.emergencyStatus, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.identitySid != nil {
		localVarFormParams.Add("IdentitySid", parameterToString(*r.identitySid, ""))
	}
	if r.phoneNumber != nil {
		localVarFormParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	}
	if r.smsApplicationSid != nil {
		localVarFormParams.Add("SmsApplicationSid", parameterToString(*r.smsApplicationSid, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.trunkSid != nil {
		localVarFormParams.Add("TrunkSid", parameterToString(*r.trunkSid, ""))
	}
	if r.voiceApplicationSid != nil {
		localVarFormParams.Add("VoiceApplicationSid", parameterToString(*r.voiceApplicationSid, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceReceiveMode != nil {
		localVarFormParams.Add("VoiceReceiveMode", parameterToString(*r.voiceReceiveMode, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIncomingPhoneNumberAssignedAddOnRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	resourceSid string
	installedAddOnSid *string
}

// The SID that identifies the Add-on installation.
func (r ApiCreateIncomingPhoneNumberAssignedAddOnRequest) InstalledAddOnSid(installedAddOnSid string) ApiCreateIncomingPhoneNumberAssignedAddOnRequest {
	r.installedAddOnSid = &installedAddOnSid
	return r
}

func (r ApiCreateIncomingPhoneNumberAssignedAddOnRequest) Execute() (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn, *http.Response, error) {
	return r.ApiService.CreateIncomingPhoneNumberAssignedAddOnExecute(r)
}

/*
CreateIncomingPhoneNumberAssignedAddOn Method for CreateIncomingPhoneNumberAssignedAddOn

Assign an Add-on installation to the Number specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param resourceSid The SID of the Phone Number to assign the Add-on.
 @return ApiCreateIncomingPhoneNumberAssignedAddOnRequest
*/
func (a *DefaultApiService) CreateIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string) ApiCreateIncomingPhoneNumberAssignedAddOnRequest {
	return ApiCreateIncomingPhoneNumberAssignedAddOnRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		resourceSid: resourceSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
func (a *DefaultApiService) CreateIncomingPhoneNumberAssignedAddOnExecute(r ApiCreateIncomingPhoneNumberAssignedAddOnRequest) (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIncomingPhoneNumberAssignedAddOn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ResourceSid"+"}", url.PathEscape(parameterToString(r.resourceSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.resourceSid) < 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have at least 34 elements")
	}
	if strlen(r.resourceSid) > 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have less than 34 elements")
	}
	if r.installedAddOnSid == nil {
		return localVarReturnValue, nil, reportError("installedAddOnSid is required and must be specified")
	}
	if strlen(*r.installedAddOnSid) < 34 {
		return localVarReturnValue, nil, reportError("installedAddOnSid must have at least 34 elements")
	}
	if strlen(*r.installedAddOnSid) > 34 {
		return localVarReturnValue, nil, reportError("installedAddOnSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("InstalledAddOnSid", parameterToString(*r.installedAddOnSid, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIncomingPhoneNumberLocalRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	phoneNumber *string
	addressSid *string
	apiVersion *string
	bundleSid *string
	emergencyAddressSid *string
	emergencyStatus *string
	friendlyName *string
	identitySid *string
	smsApplicationSid *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	trunkSid *string
	voiceApplicationSid *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceReceiveMode *string
	voiceUrl *string
}

// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
func (r ApiCreateIncomingPhoneNumberLocalRequest) PhoneNumber(phoneNumber string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
func (r ApiCreateIncomingPhoneNumberLocalRequest) AddressSid(addressSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.addressSid = &addressSid
	return r
}

// The API version to use for incoming calls made to the new phone number. The default is &#x60;2010-04-01&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) ApiVersion(apiVersion string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.apiVersion = &apiVersion
	return r
}

// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
func (r ApiCreateIncomingPhoneNumberLocalRequest) BundleSid(bundleSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.bundleSid = &bundleSid
	return r
}

// The SID of the emergency address configuration to use for emergency calling from the new phone number.
func (r ApiCreateIncomingPhoneNumberLocalRequest) EmergencyAddressSid(emergencyAddressSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.emergencyAddressSid = &emergencyAddressSid
	return r
}

// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
func (r ApiCreateIncomingPhoneNumberLocalRequest) EmergencyStatus(emergencyStatus string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.emergencyStatus = &emergencyStatus
	return r
}

// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
func (r ApiCreateIncomingPhoneNumberLocalRequest) FriendlyName(friendlyName string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.friendlyName = &friendlyName
	return r
}

// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
func (r ApiCreateIncomingPhoneNumberLocalRequest) IdentitySid(identitySid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.identitySid = &identitySid
	return r
}

// The SID of the application that should handle SMS messages sent to the new phone number. If an &#x60;sms_application_sid&#x60; is present, we ignore all of the &#x60;sms_*_url&#x60; urls and use those set on the application.
func (r ApiCreateIncomingPhoneNumberLocalRequest) SmsApplicationSid(smsApplicationSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.smsApplicationSid = &smsApplicationSid
	return r
}

// The HTTP method that we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) SmsFallbackMethod(smsFallbackMethod string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while requesting or executing the TwiML defined by &#x60;sms_url&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) SmsFallbackUrl(smsFallbackUrl string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) SmsMethod(smsMethod string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call when the new phone number receives an incoming SMS message.
func (r ApiCreateIncomingPhoneNumberLocalRequest) SmsUrl(smsUrl string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiCreateIncomingPhoneNumberLocalRequest) StatusCallback(statusCallback string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The SID of the Trunk we should use to handle calls to the new phone number. If a &#x60;trunk_sid&#x60; is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a &#x60;trunk_sid&#x60; will automatically delete your &#x60;voice_application_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberLocalRequest) TrunkSid(trunkSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.trunkSid = &trunkSid
	return r
}

// The SID of the application we should use to handle calls to the new phone number. If a &#x60;voice_application_sid&#x60; is present, we ignore all of the voice urls and use only those set on the application. Setting a &#x60;voice_application_sid&#x60; will automatically delete your &#x60;trunk_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceApplicationSid(voiceApplicationSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceApplicationSid = &voiceApplicationSid
	return r
}

// Whether to lookup the caller&#39;s name from the CNAM database and post it to your app. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method that we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceMethod(voiceMethod string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: &#x60;fax&#x60; or &#x60;voice&#x60; and defaults to &#x60;voice&#x60;.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceReceiveMode(voiceReceiveMode string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceReceiveMode = &voiceReceiveMode
	return r
}

// The URL that we should call to answer a call to the new phone number. The &#x60;voice_url&#x60; will not be called if a &#x60;voice_application_sid&#x60; or a &#x60;trunk_sid&#x60; is set.
func (r ApiCreateIncomingPhoneNumberLocalRequest) VoiceUrl(voiceUrl string) ApiCreateIncomingPhoneNumberLocalRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiCreateIncomingPhoneNumberLocalRequest) Execute() (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal, *http.Response, error) {
	return r.ApiService.CreateIncomingPhoneNumberLocalExecute(r)
}

/*
CreateIncomingPhoneNumberLocal Method for CreateIncomingPhoneNumberLocal



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateIncomingPhoneNumberLocalRequest
*/
func (a *DefaultApiService) CreateIncomingPhoneNumberLocal(ctx context.Context, accountSid string) ApiCreateIncomingPhoneNumberLocalRequest {
	return ApiCreateIncomingPhoneNumberLocalRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal
func (a *DefaultApiService) CreateIncomingPhoneNumberLocalExecute(r ApiCreateIncomingPhoneNumberLocalRequest) (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIncomingPhoneNumberLocal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.phoneNumber == nil {
		return localVarReturnValue, nil, reportError("phoneNumber is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.addressSid != nil {
		localVarFormParams.Add("AddressSid", parameterToString(*r.addressSid, ""))
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.bundleSid != nil {
		localVarFormParams.Add("BundleSid", parameterToString(*r.bundleSid, ""))
	}
	if r.emergencyAddressSid != nil {
		localVarFormParams.Add("EmergencyAddressSid", parameterToString(*r.emergencyAddressSid, ""))
	}
	if r.emergencyStatus != nil {
		localVarFormParams.Add("EmergencyStatus", parameterToString(*r.emergencyStatus, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.identitySid != nil {
		localVarFormParams.Add("IdentitySid", parameterToString(*r.identitySid, ""))
	}
	localVarFormParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	if r.smsApplicationSid != nil {
		localVarFormParams.Add("SmsApplicationSid", parameterToString(*r.smsApplicationSid, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.trunkSid != nil {
		localVarFormParams.Add("TrunkSid", parameterToString(*r.trunkSid, ""))
	}
	if r.voiceApplicationSid != nil {
		localVarFormParams.Add("VoiceApplicationSid", parameterToString(*r.voiceApplicationSid, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceReceiveMode != nil {
		localVarFormParams.Add("VoiceReceiveMode", parameterToString(*r.voiceReceiveMode, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIncomingPhoneNumberMobileRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	phoneNumber *string
	addressSid *string
	apiVersion *string
	bundleSid *string
	emergencyAddressSid *string
	emergencyStatus *string
	friendlyName *string
	identitySid *string
	smsApplicationSid *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	trunkSid *string
	voiceApplicationSid *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceReceiveMode *string
	voiceUrl *string
}

// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
func (r ApiCreateIncomingPhoneNumberMobileRequest) PhoneNumber(phoneNumber string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
func (r ApiCreateIncomingPhoneNumberMobileRequest) AddressSid(addressSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.addressSid = &addressSid
	return r
}

// The API version to use for incoming calls made to the new phone number. The default is &#x60;2010-04-01&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) ApiVersion(apiVersion string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.apiVersion = &apiVersion
	return r
}

// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
func (r ApiCreateIncomingPhoneNumberMobileRequest) BundleSid(bundleSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.bundleSid = &bundleSid
	return r
}

// The SID of the emergency address configuration to use for emergency calling from the new phone number.
func (r ApiCreateIncomingPhoneNumberMobileRequest) EmergencyAddressSid(emergencyAddressSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.emergencyAddressSid = &emergencyAddressSid
	return r
}

// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
func (r ApiCreateIncomingPhoneNumberMobileRequest) EmergencyStatus(emergencyStatus string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.emergencyStatus = &emergencyStatus
	return r
}

// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, the is a formatted version of the phone number.
func (r ApiCreateIncomingPhoneNumberMobileRequest) FriendlyName(friendlyName string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.friendlyName = &friendlyName
	return r
}

// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
func (r ApiCreateIncomingPhoneNumberMobileRequest) IdentitySid(identitySid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.identitySid = &identitySid
	return r
}

// The SID of the application that should handle SMS messages sent to the new phone number. If an &#x60;sms_application_sid&#x60; is present, we ignore all of the &#x60;sms_*_url&#x60; urls and use those of the application.
func (r ApiCreateIncomingPhoneNumberMobileRequest) SmsApplicationSid(smsApplicationSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.smsApplicationSid = &smsApplicationSid
	return r
}

// The HTTP method that we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) SmsFallbackMethod(smsFallbackMethod string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while requesting or executing the TwiML defined by &#x60;sms_url&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) SmsFallbackUrl(smsFallbackUrl string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) SmsMethod(smsMethod string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call when the new phone number receives an incoming SMS message.
func (r ApiCreateIncomingPhoneNumberMobileRequest) SmsUrl(smsUrl string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiCreateIncomingPhoneNumberMobileRequest) StatusCallback(statusCallback string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The SID of the Trunk we should use to handle calls to the new phone number. If a &#x60;trunk_sid&#x60; is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a &#x60;trunk_sid&#x60; will automatically delete your &#x60;voice_application_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberMobileRequest) TrunkSid(trunkSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.trunkSid = &trunkSid
	return r
}

// The SID of the application we should use to handle calls to the new phone number. If a &#x60;voice_application_sid&#x60; is present, we ignore all of the voice urls and use only those set on the application. Setting a &#x60;voice_application_sid&#x60; will automatically delete your &#x60;trunk_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceApplicationSid(voiceApplicationSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceApplicationSid = &voiceApplicationSid
	return r
}

// Whether to lookup the caller&#39;s name from the CNAM database and post it to your app. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method that we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceMethod(voiceMethod string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: &#x60;fax&#x60; or &#x60;voice&#x60; and defaults to &#x60;voice&#x60;.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceReceiveMode(voiceReceiveMode string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceReceiveMode = &voiceReceiveMode
	return r
}

// The URL that we should call to answer a call to the new phone number. The &#x60;voice_url&#x60; will not be called if a &#x60;voice_application_sid&#x60; or a &#x60;trunk_sid&#x60; is set.
func (r ApiCreateIncomingPhoneNumberMobileRequest) VoiceUrl(voiceUrl string) ApiCreateIncomingPhoneNumberMobileRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiCreateIncomingPhoneNumberMobileRequest) Execute() (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile, *http.Response, error) {
	return r.ApiService.CreateIncomingPhoneNumberMobileExecute(r)
}

/*
CreateIncomingPhoneNumberMobile Method for CreateIncomingPhoneNumberMobile



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateIncomingPhoneNumberMobileRequest
*/
func (a *DefaultApiService) CreateIncomingPhoneNumberMobile(ctx context.Context, accountSid string) ApiCreateIncomingPhoneNumberMobileRequest {
	return ApiCreateIncomingPhoneNumberMobileRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile
func (a *DefaultApiService) CreateIncomingPhoneNumberMobileExecute(r ApiCreateIncomingPhoneNumberMobileRequest) (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIncomingPhoneNumberMobile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.phoneNumber == nil {
		return localVarReturnValue, nil, reportError("phoneNumber is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.addressSid != nil {
		localVarFormParams.Add("AddressSid", parameterToString(*r.addressSid, ""))
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.bundleSid != nil {
		localVarFormParams.Add("BundleSid", parameterToString(*r.bundleSid, ""))
	}
	if r.emergencyAddressSid != nil {
		localVarFormParams.Add("EmergencyAddressSid", parameterToString(*r.emergencyAddressSid, ""))
	}
	if r.emergencyStatus != nil {
		localVarFormParams.Add("EmergencyStatus", parameterToString(*r.emergencyStatus, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.identitySid != nil {
		localVarFormParams.Add("IdentitySid", parameterToString(*r.identitySid, ""))
	}
	localVarFormParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	if r.smsApplicationSid != nil {
		localVarFormParams.Add("SmsApplicationSid", parameterToString(*r.smsApplicationSid, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.trunkSid != nil {
		localVarFormParams.Add("TrunkSid", parameterToString(*r.trunkSid, ""))
	}
	if r.voiceApplicationSid != nil {
		localVarFormParams.Add("VoiceApplicationSid", parameterToString(*r.voiceApplicationSid, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceReceiveMode != nil {
		localVarFormParams.Add("VoiceReceiveMode", parameterToString(*r.voiceReceiveMode, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIncomingPhoneNumberTollFreeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	phoneNumber *string
	addressSid *string
	apiVersion *string
	bundleSid *string
	emergencyAddressSid *string
	emergencyStatus *string
	friendlyName *string
	identitySid *string
	smsApplicationSid *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	trunkSid *string
	voiceApplicationSid *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceReceiveMode *string
	voiceUrl *string
}

// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) PhoneNumber(phoneNumber string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) AddressSid(addressSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.addressSid = &addressSid
	return r
}

// The API version to use for incoming calls made to the new phone number. The default is &#x60;2010-04-01&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) ApiVersion(apiVersion string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.apiVersion = &apiVersion
	return r
}

// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) BundleSid(bundleSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.bundleSid = &bundleSid
	return r
}

// The SID of the emergency address configuration to use for emergency calling from the new phone number.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) EmergencyAddressSid(emergencyAddressSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.emergencyAddressSid = &emergencyAddressSid
	return r
}

// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) EmergencyStatus(emergencyStatus string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.emergencyStatus = &emergencyStatus
	return r
}

// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) FriendlyName(friendlyName string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.friendlyName = &friendlyName
	return r
}

// The SID of the Identity resource that we should associate with the new phone number. Some regions require an Identity to meet local regulations.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) IdentitySid(identitySid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.identitySid = &identitySid
	return r
}

// The SID of the application that should handle SMS messages sent to the new phone number. If an &#x60;sms_application_sid&#x60; is present, we ignore all &#x60;sms_*_url&#x60; values and use those of the application.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) SmsApplicationSid(smsApplicationSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.smsApplicationSid = &smsApplicationSid
	return r
}

// The HTTP method that we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) SmsFallbackMethod(smsFallbackMethod string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while requesting or executing the TwiML defined by &#x60;sms_url&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) SmsFallbackUrl(smsFallbackUrl string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) SmsMethod(smsMethod string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call when the new phone number receives an incoming SMS message.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) SmsUrl(smsUrl string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) StatusCallback(statusCallback string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The SID of the Trunk we should use to handle calls to the new phone number. If a &#x60;trunk_sid&#x60; is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a &#x60;trunk_sid&#x60; will automatically delete your &#x60;voice_application_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) TrunkSid(trunkSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.trunkSid = &trunkSid
	return r
}

// The SID of the application we should use to handle calls to the new phone number. If a &#x60;voice_application_sid&#x60; is present, we ignore all of the voice urls and use those set on the application. Setting a &#x60;voice_application_sid&#x60; will automatically delete your &#x60;trunk_sid&#x60; and vice versa.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceApplicationSid(voiceApplicationSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceApplicationSid = &voiceApplicationSid
	return r
}

// Whether to lookup the caller&#39;s name from the CNAM database and post it to your app. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method that we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceMethod(voiceMethod string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: &#x60;fax&#x60; or &#x60;voice&#x60; and defaults to &#x60;voice&#x60;.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceReceiveMode(voiceReceiveMode string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceReceiveMode = &voiceReceiveMode
	return r
}

// The URL that we should call to answer a call to the new phone number. The &#x60;voice_url&#x60; will not be called if a &#x60;voice_application_sid&#x60; or a &#x60;trunk_sid&#x60; is set.
func (r ApiCreateIncomingPhoneNumberTollFreeRequest) VoiceUrl(voiceUrl string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiCreateIncomingPhoneNumberTollFreeRequest) Execute() (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree, *http.Response, error) {
	return r.ApiService.CreateIncomingPhoneNumberTollFreeExecute(r)
}

/*
CreateIncomingPhoneNumberTollFree Method for CreateIncomingPhoneNumberTollFree



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateIncomingPhoneNumberTollFreeRequest
*/
func (a *DefaultApiService) CreateIncomingPhoneNumberTollFree(ctx context.Context, accountSid string) ApiCreateIncomingPhoneNumberTollFreeRequest {
	return ApiCreateIncomingPhoneNumberTollFreeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree
func (a *DefaultApiService) CreateIncomingPhoneNumberTollFreeExecute(r ApiCreateIncomingPhoneNumberTollFreeRequest) (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIncomingPhoneNumberTollFree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.phoneNumber == nil {
		return localVarReturnValue, nil, reportError("phoneNumber is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.addressSid != nil {
		localVarFormParams.Add("AddressSid", parameterToString(*r.addressSid, ""))
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.bundleSid != nil {
		localVarFormParams.Add("BundleSid", parameterToString(*r.bundleSid, ""))
	}
	if r.emergencyAddressSid != nil {
		localVarFormParams.Add("EmergencyAddressSid", parameterToString(*r.emergencyAddressSid, ""))
	}
	if r.emergencyStatus != nil {
		localVarFormParams.Add("EmergencyStatus", parameterToString(*r.emergencyStatus, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.identitySid != nil {
		localVarFormParams.Add("IdentitySid", parameterToString(*r.identitySid, ""))
	}
	localVarFormParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	if r.smsApplicationSid != nil {
		localVarFormParams.Add("SmsApplicationSid", parameterToString(*r.smsApplicationSid, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.trunkSid != nil {
		localVarFormParams.Add("TrunkSid", parameterToString(*r.trunkSid, ""))
	}
	if r.voiceApplicationSid != nil {
		localVarFormParams.Add("VoiceApplicationSid", parameterToString(*r.voiceApplicationSid, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceReceiveMode != nil {
		localVarFormParams.Add("VoiceReceiveMode", parameterToString(*r.voiceReceiveMode, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	to *string
	addressRetention *string
	applicationSid *string
	attempt *int32
	body *string
	contentRetention *string
	forceDelivery *bool
	from *string
	maxPrice *float32
	mediaUrl *[]string
	messagingServiceSid *string
	persistentAction *[]string
	provideFeedback *bool
	scheduleType *string
	sendAsMms *bool
	sendAt *time.Time
	smartEncoded *bool
	statusCallback *string
	validityPeriod *int32
}

// The destination phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format for SMS/MMS or [Channel user address](https://www.twilio.com/docs/sms/channels#channel-addresses) for other 3rd-party channels.
func (r ApiCreateMessageRequest) To(to string) ApiCreateMessageRequest {
	r.to = &to
	return r
}

// Determines if the address can be stored or obfuscated based on privacy settings
func (r ApiCreateMessageRequest) AddressRetention(addressRetention string) ApiCreateMessageRequest {
	r.addressRetention = &addressRetention
	return r
}

// The SID of the application that should receive message status. We POST a &#x60;message_sid&#x60; parameter and a &#x60;message_status&#x60; parameter with a value of &#x60;sent&#x60; or &#x60;failed&#x60; to the [application](https://www.twilio.com/docs/usage/api/applications)&#39;s &#x60;message_status_callback&#x60;. If a &#x60;status_callback&#x60; parameter is also passed, it will be ignored and the application&#39;s &#x60;message_status_callback&#x60; parameter will be used.
func (r ApiCreateMessageRequest) ApplicationSid(applicationSid string) ApiCreateMessageRequest {
	r.applicationSid = &applicationSid
	return r
}

// Total number of attempts made ( including this ) to send out the message regardless of the provider used
func (r ApiCreateMessageRequest) Attempt(attempt int32) ApiCreateMessageRequest {
	r.attempt = &attempt
	return r
}

// The text of the message you want to send. Can be up to 1,600 characters in length.
func (r ApiCreateMessageRequest) Body(body string) ApiCreateMessageRequest {
	r.body = &body
	return r
}

// Determines if the message content can be stored or redacted based on privacy settings
func (r ApiCreateMessageRequest) ContentRetention(contentRetention string) ApiCreateMessageRequest {
	r.contentRetention = &contentRetention
	return r
}

// Reserved
func (r ApiCreateMessageRequest) ForceDelivery(forceDelivery bool) ApiCreateMessageRequest {
	r.forceDelivery = &forceDelivery
	return r
}

// A Twilio phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, an [alphanumeric sender ID](https://www.twilio.com/docs/sms/send-messages#use-an-alphanumeric-sender-id), or a [Channel Endpoint address](https://www.twilio.com/docs/sms/channels#channel-addresses) that is enabled for the type of message you want to send. Phone numbers or [short codes](https://www.twilio.com/docs/sms/api/short-code) purchased from Twilio also work here. You cannot, for example, spoof messages from a private cell phone number. If you are using &#x60;messaging_service_sid&#x60;, this parameter must be empty.
func (r ApiCreateMessageRequest) From(from string) ApiCreateMessageRequest {
	r.from = &from
	return r
}

// The maximum total price in US dollars that you will pay for the message to be delivered. Can be a decimal value that has up to 4 decimal places. All messages are queued for delivery and the message cost is checked before the message is sent. If the cost exceeds &#x60;max_price&#x60;, the message will fail and a status of &#x60;Failed&#x60; is sent to the status callback. If &#x60;MaxPrice&#x60; is not set, the message cost is not checked.
func (r ApiCreateMessageRequest) MaxPrice(maxPrice float32) ApiCreateMessageRequest {
	r.maxPrice = &maxPrice
	return r
}

// The URL of the media to send with the message. The media can be of type &#x60;gif&#x60;, &#x60;png&#x60;, and &#x60;jpeg&#x60; and will be formatted correctly on the recipient&#39;s device. The media size limit is 5MB for supported file types (JPEG, PNG, GIF) and 500KB for [other types](https://www.twilio.com/docs/sms/accepted-mime-types) of accepted media. To send more than one image in the message body, provide multiple &#x60;media_url&#x60; parameters in the POST request. You can include up to 10 &#x60;media_url&#x60; parameters per message. You can send images in an SMS message in only the US and Canada.
func (r ApiCreateMessageRequest) MediaUrl(mediaUrl []string) ApiCreateMessageRequest {
	r.mediaUrl = &mediaUrl
	return r
}

// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services#send-a-message-with-copilot) you want to associate with the Message. Set this parameter to use the [Messaging Service Settings and Copilot Features](https://www.twilio.com/console/sms/services) you have configured and leave the &#x60;from&#x60; parameter empty. When only this parameter is set, Twilio will use your enabled Copilot Features to select the &#x60;from&#x60; phone number for delivery.
func (r ApiCreateMessageRequest) MessagingServiceSid(messagingServiceSid string) ApiCreateMessageRequest {
	r.messagingServiceSid = &messagingServiceSid
	return r
}

// Rich actions for Channels Messages.
func (r ApiCreateMessageRequest) PersistentAction(persistentAction []string) ApiCreateMessageRequest {
	r.persistentAction = &persistentAction
	return r
}

// Whether to confirm delivery of the message. Set this value to &#x60;true&#x60; if you are sending messages that have a trackable user action and you intend to confirm delivery of the message using the [Message Feedback API](https://www.twilio.com/docs/sms/api/message-feedback-resource). This parameter is &#x60;false&#x60; by default.
func (r ApiCreateMessageRequest) ProvideFeedback(provideFeedback bool) ApiCreateMessageRequest {
	r.provideFeedback = &provideFeedback
	return r
}

// Indicates your intent to schedule a message. Pass the value &#x60;fixed&#x60; to schedule a message at a fixed time.
func (r ApiCreateMessageRequest) ScheduleType(scheduleType string) ApiCreateMessageRequest {
	r.scheduleType = &scheduleType
	return r
}

// If set to True, Twilio will deliver the message as a single MMS message, regardless of the presence of media.
func (r ApiCreateMessageRequest) SendAsMms(sendAsMms bool) ApiCreateMessageRequest {
	r.sendAsMms = &sendAsMms
	return r
}

// The time that Twilio will send the message. Must be in ISO 8601 format.
func (r ApiCreateMessageRequest) SendAt(sendAt time.Time) ApiCreateMessageRequest {
	r.sendAt = &sendAt
	return r
}

// Whether to detect Unicode characters that have a similar GSM-7 character and replace them. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiCreateMessageRequest) SmartEncoded(smartEncoded bool) ApiCreateMessageRequest {
	r.smartEncoded = &smartEncoded
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application. If specified, we POST these message status changes to the URL: &#x60;queued&#x60;, &#x60;failed&#x60;, &#x60;sent&#x60;, &#x60;delivered&#x60;, or &#x60;undelivered&#x60;. Twilio will POST its [standard request parameters](https://www.twilio.com/docs/sms/twiml#request-parameters) as well as some additional parameters including &#x60;MessageSid&#x60;, &#x60;MessageStatus&#x60;, and &#x60;ErrorCode&#x60;. If you include this parameter with the &#x60;messaging_service_sid&#x60;, we use this URL instead of the Status Callback URL of the [Messaging Service](https://www.twilio.com/docs/sms/services/api). URLs must contain a valid hostname and underscores are not allowed.
func (r ApiCreateMessageRequest) StatusCallback(statusCallback string) ApiCreateMessageRequest {
	r.statusCallback = &statusCallback
	return r
}

// How long in seconds the message can remain in our outgoing message queue. After this period elapses, the message fails and we call your status callback. Can be between 1 and the default value of 14,400 seconds. After a message has been accepted by a carrier, however, we cannot guarantee that the message will not be queued after this period. We recommend that this value be at least 5 seconds.
func (r ApiCreateMessageRequest) ValidityPeriod(validityPeriod int32) ApiCreateMessageRequest {
	r.validityPeriod = &validityPeriod
	return r
}

func (r ApiCreateMessageRequest) Execute() (*ApiV2010AccountMessage, *http.Response, error) {
	return r.ApiService.CreateMessageExecute(r)
}

/*
CreateMessage Method for CreateMessage

Send a message from the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateMessageRequest
*/
func (a *DefaultApiService) CreateMessage(ctx context.Context, accountSid string) ApiCreateMessageRequest {
	return ApiCreateMessageRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountMessage
func (a *DefaultApiService) CreateMessageExecute(r ApiCreateMessageRequest) (*ApiV2010AccountMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.addressRetention != nil {
		localVarFormParams.Add("AddressRetention", parameterToString(*r.addressRetention, ""))
	}
	if r.applicationSid != nil {
		localVarFormParams.Add("ApplicationSid", parameterToString(*r.applicationSid, ""))
	}
	if r.attempt != nil {
		localVarFormParams.Add("Attempt", parameterToString(*r.attempt, ""))
	}
	if r.body != nil {
		localVarFormParams.Add("Body", parameterToString(*r.body, ""))
	}
	if r.contentRetention != nil {
		localVarFormParams.Add("ContentRetention", parameterToString(*r.contentRetention, ""))
	}
	if r.forceDelivery != nil {
		localVarFormParams.Add("ForceDelivery", parameterToString(*r.forceDelivery, ""))
	}
	if r.from != nil {
		localVarFormParams.Add("From", parameterToString(*r.from, ""))
	}
	if r.maxPrice != nil {
		localVarFormParams.Add("MaxPrice", parameterToString(*r.maxPrice, ""))
	}
	if r.mediaUrl != nil {
		localVarFormParams.Add("MediaUrl", parameterToString(*r.mediaUrl, "csv"))
	}
	if r.messagingServiceSid != nil {
		localVarFormParams.Add("MessagingServiceSid", parameterToString(*r.messagingServiceSid, ""))
	}
	if r.persistentAction != nil {
		localVarFormParams.Add("PersistentAction", parameterToString(*r.persistentAction, "csv"))
	}
	if r.provideFeedback != nil {
		localVarFormParams.Add("ProvideFeedback", parameterToString(*r.provideFeedback, ""))
	}
	if r.scheduleType != nil {
		localVarFormParams.Add("ScheduleType", parameterToString(*r.scheduleType, ""))
	}
	if r.sendAsMms != nil {
		localVarFormParams.Add("SendAsMms", parameterToString(*r.sendAsMms, ""))
	}
	if r.sendAt != nil {
		localVarFormParams.Add("SendAt", parameterToString(*r.sendAt, ""))
	}
	if r.smartEncoded != nil {
		localVarFormParams.Add("SmartEncoded", parameterToString(*r.smartEncoded, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	localVarFormParams.Add("To", parameterToString(*r.to, ""))
	if r.validityPeriod != nil {
		localVarFormParams.Add("ValidityPeriod", parameterToString(*r.validityPeriod, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMessageFeedbackRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	messageSid string
	outcome *string
}

// Whether the feedback has arrived. Can be: &#x60;unconfirmed&#x60; or &#x60;confirmed&#x60;. If &#x60;provide_feedback&#x60;&#x3D;&#x60;true&#x60; in [the initial HTTP POST](https://www.twilio.com/docs/sms/api/message-resource#create-a-message-resource), the initial value of this property is &#x60;unconfirmed&#x60;. After the message arrives, update the value to &#x60;confirmed&#x60;.
func (r ApiCreateMessageFeedbackRequest) Outcome(outcome string) ApiCreateMessageFeedbackRequest {
	r.outcome = &outcome
	return r
}

func (r ApiCreateMessageFeedbackRequest) Execute() (*ApiV2010AccountMessageMessageFeedback, *http.Response, error) {
	return r.ApiService.CreateMessageFeedbackExecute(r)
}

/*
CreateMessageFeedback Method for CreateMessageFeedback



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param messageSid The SID of the Message resource for which the feedback was provided.
 @return ApiCreateMessageFeedbackRequest
*/
func (a *DefaultApiService) CreateMessageFeedback(ctx context.Context, accountSid string, messageSid string) ApiCreateMessageFeedbackRequest {
	return ApiCreateMessageFeedbackRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		messageSid: messageSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountMessageMessageFeedback
func (a *DefaultApiService) CreateMessageFeedbackExecute(r ApiCreateMessageFeedbackRequest) (*ApiV2010AccountMessageMessageFeedback, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountMessageMessageFeedback
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMessageFeedback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MessageSid"+"}", url.PathEscape(parameterToString(r.messageSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.messageSid) < 34 {
		return localVarReturnValue, nil, reportError("messageSid must have at least 34 elements")
	}
	if strlen(r.messageSid) > 34 {
		return localVarReturnValue, nil, reportError("messageSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.outcome != nil {
		localVarFormParams.Add("Outcome", parameterToString(*r.outcome, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNewKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiCreateNewKeyRequest) FriendlyName(friendlyName string) ApiCreateNewKeyRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiCreateNewKeyRequest) Execute() (*ApiV2010AccountNewKey, *http.Response, error) {
	return r.ApiService.CreateNewKeyExecute(r)
}

/*
CreateNewKey Method for CreateNewKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Key resource.
 @return ApiCreateNewKeyRequest
*/
func (a *DefaultApiService) CreateNewKey(ctx context.Context, accountSid string) ApiCreateNewKeyRequest {
	return ApiCreateNewKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountNewKey
func (a *DefaultApiService) CreateNewKeyExecute(r ApiCreateNewKeyRequest) (*ApiV2010AccountNewKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountNewKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateNewKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Keys.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNewSigningKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiCreateNewSigningKeyRequest) FriendlyName(friendlyName string) ApiCreateNewSigningKeyRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiCreateNewSigningKeyRequest) Execute() (*ApiV2010AccountNewSigningKey, *http.Response, error) {
	return r.ApiService.CreateNewSigningKeyExecute(r)
}

/*
CreateNewSigningKey Method for CreateNewSigningKey

Create a new Signing Key for the account making the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Key resource.
 @return ApiCreateNewSigningKeyRequest
*/
func (a *DefaultApiService) CreateNewSigningKey(ctx context.Context, accountSid string) ApiCreateNewSigningKeyRequest {
	return ApiCreateNewSigningKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountNewSigningKey
func (a *DefaultApiService) CreateNewSigningKeyExecute(r ApiCreateNewSigningKeyRequest) (*ApiV2010AccountNewSigningKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountNewSigningKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateNewSigningKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SigningKeys.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateParticipantRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	from *string
	to *string
	beep *string
	byoc *string
	callReason *string
	callSidToCoach *string
	callerId *string
	coaching *bool
	conferenceRecord *string
	conferenceRecordingStatusCallback *string
	conferenceRecordingStatusCallbackEvent *[]string
	conferenceRecordingStatusCallbackMethod *string
	conferenceStatusCallback *string
	conferenceStatusCallbackEvent *[]string
	conferenceStatusCallbackMethod *string
	conferenceTrim *string
	earlyMedia *bool
	endConferenceOnExit *bool
	jitterBufferSize *string
	label *string
	maxParticipants *int32
	muted *bool
	record *bool
	recordingChannels *string
	recordingStatusCallback *string
	recordingStatusCallbackEvent *[]string
	recordingStatusCallbackMethod *string
	recordingTrack *string
	region *string
	sipAuthPassword *string
	sipAuthUsername *string
	startConferenceOnEnter *bool
	statusCallback *string
	statusCallbackEvent *[]string
	statusCallbackMethod *string
	timeLimit *int32
	timeout *int32
	waitMethod *string
	waitUrl *string
}

// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted &#x60;client:name&#x60;. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the &#x60;to&#x60; parameter is a phone number, &#x60;from&#x60; must also be a phone number. If &#x60;to&#x60; is sip address, this value of &#x60;from&#x60; should be a username portion to be used to populate the P-Asserted-Identity header that is passed to the SIP endpoint.
func (r ApiCreateParticipantRequest) From(from string) ApiCreateParticipantRequest {
	r.from = &from
	return r
}

// The phone number, SIP address, or Client identifier that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as &#x60;sip:name@company.com&#x60;. Client identifiers are formatted &#x60;client:name&#x60;. [Custom parameters](https://www.twilio.com/docs/voice/api/conference-participant-resource#custom-parameters) may also be specified.
func (r ApiCreateParticipantRequest) To(to string) ApiCreateParticipantRequest {
	r.to = &to
	return r
}

// Whether to play a notification beep to the conference when the participant joins. Can be: &#x60;true&#x60;, &#x60;false&#x60;, &#x60;onEnter&#x60;, or &#x60;onExit&#x60;. The default value is &#x60;true&#x60;.
func (r ApiCreateParticipantRequest) Beep(beep string) ApiCreateParticipantRequest {
	r.beep = &beep
	return r
}

// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that &#x60;byoc&#x60; is only meaningful when &#x60;to&#x60; is a phone number; it will otherwise be ignored. (Beta)
func (r ApiCreateParticipantRequest) Byoc(byoc string) ApiCreateParticipantRequest {
	r.byoc = &byoc
	return r
}

// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party&#39;s phone. (Branded Calls Beta)
func (r ApiCreateParticipantRequest) CallReason(callReason string) ApiCreateParticipantRequest {
	r.callReason = &callReason
	return r
}

// The SID of the participant who is being &#x60;coached&#x60;. The participant being coached is the only participant who can hear the participant who is &#x60;coaching&#x60;.
func (r ApiCreateParticipantRequest) CallSidToCoach(callSidToCoach string) ApiCreateParticipantRequest {
	r.callSidToCoach = &callSidToCoach
	return r
}

// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted &#x60;client:name&#x60;. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the &#x60;to&#x60; parameter is a phone number, &#x60;callerId&#x60; must also be a phone number. If &#x60;to&#x60; is sip address, this value of &#x60;callerId&#x60; should be a username portion to be used to populate the From header that is passed to the SIP endpoint.
func (r ApiCreateParticipantRequest) CallerId(callerId string) ApiCreateParticipantRequest {
	r.callerId = &callerId
	return r
}

// Whether the participant is coaching another call. Can be: &#x60;true&#x60; or &#x60;false&#x60;. If not present, defaults to &#x60;false&#x60; unless &#x60;call_sid_to_coach&#x60; is defined. If &#x60;true&#x60;, &#x60;call_sid_to_coach&#x60; must be defined.
func (r ApiCreateParticipantRequest) Coaching(coaching bool) ApiCreateParticipantRequest {
	r.coaching = &coaching
	return r
}

// Whether to record the conference the participant is joining. Can be: &#x60;true&#x60;, &#x60;false&#x60;, &#x60;record-from-start&#x60;, and &#x60;do-not-record&#x60;. The default value is &#x60;false&#x60;.
func (r ApiCreateParticipantRequest) ConferenceRecord(conferenceRecord string) ApiCreateParticipantRequest {
	r.conferenceRecord = &conferenceRecord
	return r
}

// The URL we should call using the &#x60;conference_recording_status_callback_method&#x60; when the conference recording is available.
func (r ApiCreateParticipantRequest) ConferenceRecordingStatusCallback(conferenceRecordingStatusCallback string) ApiCreateParticipantRequest {
	r.conferenceRecordingStatusCallback = &conferenceRecordingStatusCallback
	return r
}

// The conference recording state changes that generate a call to &#x60;conference_recording_status_callback&#x60;. Can be: &#x60;in-progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, and &#x60;absent&#x60;. Separate multiple values with a space, ex: &#x60;&#39;in-progress completed failed&#39;&#x60;
func (r ApiCreateParticipantRequest) ConferenceRecordingStatusCallbackEvent(conferenceRecordingStatusCallbackEvent []string) ApiCreateParticipantRequest {
	r.conferenceRecordingStatusCallbackEvent = &conferenceRecordingStatusCallbackEvent
	return r
}

// The HTTP method we should use to call &#x60;conference_recording_status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateParticipantRequest) ConferenceRecordingStatusCallbackMethod(conferenceRecordingStatusCallbackMethod string) ApiCreateParticipantRequest {
	r.conferenceRecordingStatusCallbackMethod = &conferenceRecordingStatusCallbackMethod
	return r
}

// The URL we should call using the &#x60;conference_status_callback_method&#x60; when the conference events in &#x60;conference_status_callback_event&#x60; occur. Only the value set by the first participant to join the conference is used. Subsequent &#x60;conference_status_callback&#x60; values are ignored.
func (r ApiCreateParticipantRequest) ConferenceStatusCallback(conferenceStatusCallback string) ApiCreateParticipantRequest {
	r.conferenceStatusCallback = &conferenceStatusCallback
	return r
}

// The conference state changes that should generate a call to &#x60;conference_status_callback&#x60;. Can be: &#x60;start&#x60;, &#x60;end&#x60;, &#x60;join&#x60;, &#x60;leave&#x60;, &#x60;mute&#x60;, &#x60;hold&#x60;, &#x60;modify&#x60;, &#x60;speaker&#x60;, and &#x60;announcement&#x60;. Separate multiple values with a space. Defaults to &#x60;start end&#x60;.
func (r ApiCreateParticipantRequest) ConferenceStatusCallbackEvent(conferenceStatusCallbackEvent []string) ApiCreateParticipantRequest {
	r.conferenceStatusCallbackEvent = &conferenceStatusCallbackEvent
	return r
}

// The HTTP method we should use to call &#x60;conference_status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateParticipantRequest) ConferenceStatusCallbackMethod(conferenceStatusCallbackMethod string) ApiCreateParticipantRequest {
	r.conferenceStatusCallbackMethod = &conferenceStatusCallbackMethod
	return r
}

// Whether to trim leading and trailing silence from your recorded conference audio files. Can be: &#x60;trim-silence&#x60; or &#x60;do-not-trim&#x60; and defaults to &#x60;trim-silence&#x60;.
func (r ApiCreateParticipantRequest) ConferenceTrim(conferenceTrim string) ApiCreateParticipantRequest {
	r.conferenceTrim = &conferenceTrim
	return r
}

// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;true&#x60;.
func (r ApiCreateParticipantRequest) EarlyMedia(earlyMedia bool) ApiCreateParticipantRequest {
	r.earlyMedia = &earlyMedia
	return r
}

// Whether to end the conference when the participant leaves. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiCreateParticipantRequest) EndConferenceOnExit(endConferenceOnExit bool) ApiCreateParticipantRequest {
	r.endConferenceOnExit = &endConferenceOnExit
	return r
}

// Jitter buffer size for the connecting participant. Twilio will use this setting to apply Jitter Buffer before participant&#39;s audio is mixed into the conference. Can be: &#x60;off&#x60;, &#x60;small&#x60;, &#x60;medium&#x60;, and &#x60;large&#x60;. Default to &#x60;large&#x60;.
func (r ApiCreateParticipantRequest) JitterBufferSize(jitterBufferSize string) ApiCreateParticipantRequest {
	r.jitterBufferSize = &jitterBufferSize
	return r
}

// A label for this participant. If one is supplied, it may subsequently be used to fetch, update or delete the participant.
func (r ApiCreateParticipantRequest) Label(label string) ApiCreateParticipantRequest {
	r.label = &label
	return r
}

// The maximum number of participants in the conference. Can be a positive integer from &#x60;2&#x60; to &#x60;250&#x60;. The default value is &#x60;250&#x60;.
func (r ApiCreateParticipantRequest) MaxParticipants(maxParticipants int32) ApiCreateParticipantRequest {
	r.maxParticipants = &maxParticipants
	return r
}

// Whether the agent is muted in the conference. Can be &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiCreateParticipantRequest) Muted(muted bool) ApiCreateParticipantRequest {
	r.muted = &muted
	return r
}

// Whether to record the participant and their conferences, including the time between conferences. Can be &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiCreateParticipantRequest) Record(record bool) ApiCreateParticipantRequest {
	r.record = &record
	return r
}

// The recording channels for the final recording. Can be: &#x60;mono&#x60; or &#x60;dual&#x60; and the default is &#x60;mono&#x60;.
func (r ApiCreateParticipantRequest) RecordingChannels(recordingChannels string) ApiCreateParticipantRequest {
	r.recordingChannels = &recordingChannels
	return r
}

// The URL that we should call using the &#x60;recording_status_callback_method&#x60; when the recording status changes.
func (r ApiCreateParticipantRequest) RecordingStatusCallback(recordingStatusCallback string) ApiCreateParticipantRequest {
	r.recordingStatusCallback = &recordingStatusCallback
	return r
}

// The recording state changes that should generate a call to &#x60;recording_status_callback&#x60;. Can be: &#x60;started&#x60;, &#x60;in-progress&#x60;, &#x60;paused&#x60;, &#x60;resumed&#x60;, &#x60;stopped&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, and &#x60;absent&#x60;. Separate multiple values with a space, ex: &#x60;&#39;in-progress completed failed&#39;&#x60;.
func (r ApiCreateParticipantRequest) RecordingStatusCallbackEvent(recordingStatusCallbackEvent []string) ApiCreateParticipantRequest {
	r.recordingStatusCallbackEvent = &recordingStatusCallbackEvent
	return r
}

// The HTTP method we should use when we call &#x60;recording_status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateParticipantRequest) RecordingStatusCallbackMethod(recordingStatusCallbackMethod string) ApiCreateParticipantRequest {
	r.recordingStatusCallbackMethod = &recordingStatusCallbackMethod
	return r
}

// The audio track to record for the call. Can be: &#x60;inbound&#x60;, &#x60;outbound&#x60; or &#x60;both&#x60;. The default is &#x60;both&#x60;. &#x60;inbound&#x60; records the audio that is received by Twilio. &#x60;outbound&#x60; records the audio that is sent from Twilio. &#x60;both&#x60; records the audio that is received and sent by Twilio.
func (r ApiCreateParticipantRequest) RecordingTrack(recordingTrack string) ApiCreateParticipantRequest {
	r.recordingTrack = &recordingTrack
	return r
}

// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:&#x60;us1&#x60;, &#x60;ie1&#x60;, &#x60;de1&#x60;, &#x60;sg1&#x60;, &#x60;br1&#x60;, &#x60;au1&#x60;, or &#x60;jp1&#x60;.
func (r ApiCreateParticipantRequest) Region(region string) ApiCreateParticipantRequest {
	r.region = &region
	return r
}

// The SIP password for authentication.
func (r ApiCreateParticipantRequest) SipAuthPassword(sipAuthPassword string) ApiCreateParticipantRequest {
	r.sipAuthPassword = &sipAuthPassword
	return r
}

// The SIP username used for authentication.
func (r ApiCreateParticipantRequest) SipAuthUsername(sipAuthUsername string) ApiCreateParticipantRequest {
	r.sipAuthUsername = &sipAuthUsername
	return r
}

// Whether to start the conference when the participant joins, if it has not already started. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;. If &#x60;false&#x60; and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
func (r ApiCreateParticipantRequest) StartConferenceOnEnter(startConferenceOnEnter bool) ApiCreateParticipantRequest {
	r.startConferenceOnEnter = &startConferenceOnEnter
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiCreateParticipantRequest) StatusCallback(statusCallback string) ApiCreateParticipantRequest {
	r.statusCallback = &statusCallback
	return r
}

// The conference state changes that should generate a call to &#x60;status_callback&#x60;. Can be: &#x60;initiated&#x60;, &#x60;ringing&#x60;, &#x60;answered&#x60;, and &#x60;completed&#x60;. Separate multiple values with a space. The default value is &#x60;completed&#x60;.
func (r ApiCreateParticipantRequest) StatusCallbackEvent(statusCallbackEvent []string) ApiCreateParticipantRequest {
	r.statusCallbackEvent = &statusCallbackEvent
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; and &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiCreateParticipantRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateParticipantRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The maximum duration of the call in seconds. Constraints depend on account and configuration.
func (r ApiCreateParticipantRequest) TimeLimit(timeLimit int32) ApiCreateParticipantRequest {
	r.timeLimit = &timeLimit
	return r
}

// The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between &#x60;5&#x60; and &#x60;600&#x60;, inclusive. The default value is &#x60;60&#x60;. We always add a 5-second timeout buffer to outgoing calls, so  value of 10 would result in an actual timeout that was closer to 15 seconds.
func (r ApiCreateParticipantRequest) Timeout(timeout int32) ApiCreateParticipantRequest {
	r.timeout = &timeout
	return r
}

// The HTTP method we should use to call &#x60;wait_url&#x60;. Can be &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. When using a static audio file, this should be &#x60;GET&#x60; so that we can cache the file.
func (r ApiCreateParticipantRequest) WaitMethod(waitMethod string) ApiCreateParticipantRequest {
	r.waitMethod = &waitMethod
	return r
}

// The URL we should call using the &#x60;wait_method&#x60; for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
func (r ApiCreateParticipantRequest) WaitUrl(waitUrl string) ApiCreateParticipantRequest {
	r.waitUrl = &waitUrl
	return r
}

func (r ApiCreateParticipantRequest) Execute() (*ApiV2010AccountConferenceParticipant, *http.Response, error) {
	return r.ApiService.CreateParticipantExecute(r)
}

/*
CreateParticipant Method for CreateParticipant



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param conferenceSid The SID of the participant's conference.
 @return ApiCreateParticipantRequest
*/
func (a *DefaultApiService) CreateParticipant(ctx context.Context, accountSid string, conferenceSid string) ApiCreateParticipantRequest {
	return ApiCreateParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConferenceParticipant
func (a *DefaultApiService) CreateParticipantExecute(r ApiCreateParticipantRequest) (*ApiV2010AccountConferenceParticipant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConferenceParticipant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.beep != nil {
		localVarFormParams.Add("Beep", parameterToString(*r.beep, ""))
	}
	if r.byoc != nil {
		localVarFormParams.Add("Byoc", parameterToString(*r.byoc, ""))
	}
	if r.callReason != nil {
		localVarFormParams.Add("CallReason", parameterToString(*r.callReason, ""))
	}
	if r.callSidToCoach != nil {
		localVarFormParams.Add("CallSidToCoach", parameterToString(*r.callSidToCoach, ""))
	}
	if r.callerId != nil {
		localVarFormParams.Add("CallerId", parameterToString(*r.callerId, ""))
	}
	if r.coaching != nil {
		localVarFormParams.Add("Coaching", parameterToString(*r.coaching, ""))
	}
	if r.conferenceRecord != nil {
		localVarFormParams.Add("ConferenceRecord", parameterToString(*r.conferenceRecord, ""))
	}
	if r.conferenceRecordingStatusCallback != nil {
		localVarFormParams.Add("ConferenceRecordingStatusCallback", parameterToString(*r.conferenceRecordingStatusCallback, ""))
	}
	if r.conferenceRecordingStatusCallbackEvent != nil {
		localVarFormParams.Add("ConferenceRecordingStatusCallbackEvent", parameterToString(*r.conferenceRecordingStatusCallbackEvent, "csv"))
	}
	if r.conferenceRecordingStatusCallbackMethod != nil {
		localVarFormParams.Add("ConferenceRecordingStatusCallbackMethod", parameterToString(*r.conferenceRecordingStatusCallbackMethod, ""))
	}
	if r.conferenceStatusCallback != nil {
		localVarFormParams.Add("ConferenceStatusCallback", parameterToString(*r.conferenceStatusCallback, ""))
	}
	if r.conferenceStatusCallbackEvent != nil {
		localVarFormParams.Add("ConferenceStatusCallbackEvent", parameterToString(*r.conferenceStatusCallbackEvent, "csv"))
	}
	if r.conferenceStatusCallbackMethod != nil {
		localVarFormParams.Add("ConferenceStatusCallbackMethod", parameterToString(*r.conferenceStatusCallbackMethod, ""))
	}
	if r.conferenceTrim != nil {
		localVarFormParams.Add("ConferenceTrim", parameterToString(*r.conferenceTrim, ""))
	}
	if r.earlyMedia != nil {
		localVarFormParams.Add("EarlyMedia", parameterToString(*r.earlyMedia, ""))
	}
	if r.endConferenceOnExit != nil {
		localVarFormParams.Add("EndConferenceOnExit", parameterToString(*r.endConferenceOnExit, ""))
	}
	localVarFormParams.Add("From", parameterToString(*r.from, ""))
	if r.jitterBufferSize != nil {
		localVarFormParams.Add("JitterBufferSize", parameterToString(*r.jitterBufferSize, ""))
	}
	if r.label != nil {
		localVarFormParams.Add("Label", parameterToString(*r.label, ""))
	}
	if r.maxParticipants != nil {
		localVarFormParams.Add("MaxParticipants", parameterToString(*r.maxParticipants, ""))
	}
	if r.muted != nil {
		localVarFormParams.Add("Muted", parameterToString(*r.muted, ""))
	}
	if r.record != nil {
		localVarFormParams.Add("Record", parameterToString(*r.record, ""))
	}
	if r.recordingChannels != nil {
		localVarFormParams.Add("RecordingChannels", parameterToString(*r.recordingChannels, ""))
	}
	if r.recordingStatusCallback != nil {
		localVarFormParams.Add("RecordingStatusCallback", parameterToString(*r.recordingStatusCallback, ""))
	}
	if r.recordingStatusCallbackEvent != nil {
		localVarFormParams.Add("RecordingStatusCallbackEvent", parameterToString(*r.recordingStatusCallbackEvent, "csv"))
	}
	if r.recordingStatusCallbackMethod != nil {
		localVarFormParams.Add("RecordingStatusCallbackMethod", parameterToString(*r.recordingStatusCallbackMethod, ""))
	}
	if r.recordingTrack != nil {
		localVarFormParams.Add("RecordingTrack", parameterToString(*r.recordingTrack, ""))
	}
	if r.region != nil {
		localVarFormParams.Add("Region", parameterToString(*r.region, ""))
	}
	if r.sipAuthPassword != nil {
		localVarFormParams.Add("SipAuthPassword", parameterToString(*r.sipAuthPassword, ""))
	}
	if r.sipAuthUsername != nil {
		localVarFormParams.Add("SipAuthUsername", parameterToString(*r.sipAuthUsername, ""))
	}
	if r.startConferenceOnEnter != nil {
		localVarFormParams.Add("StartConferenceOnEnter", parameterToString(*r.startConferenceOnEnter, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackEvent != nil {
		localVarFormParams.Add("StatusCallbackEvent", parameterToString(*r.statusCallbackEvent, "csv"))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.timeLimit != nil {
		localVarFormParams.Add("TimeLimit", parameterToString(*r.timeLimit, ""))
	}
	if r.timeout != nil {
		localVarFormParams.Add("Timeout", parameterToString(*r.timeout, ""))
	}
	localVarFormParams.Add("To", parameterToString(*r.to, ""))
	if r.waitMethod != nil {
		localVarFormParams.Add("WaitMethod", parameterToString(*r.waitMethod, ""))
	}
	if r.waitUrl != nil {
		localVarFormParams.Add("WaitUrl", parameterToString(*r.waitUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePaymentsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	idempotencyKey *string
	statusCallback *string
	bankAccountType *string
	chargeAmount *float32
	currency *string
	description *string
	input *string
	minPostalCodeLength *int32
	parameter *interface{}
	paymentConnector *string
	paymentMethod *string
	postalCode *bool
	securityCode *bool
	timeout *int32
	tokenType *string
	validCardTypes *string
}

// A unique token that will be used to ensure that multiple API calls with the same information do not result in multiple transactions. This should be a unique string value per API call and can be a randomly generated.
func (r ApiCreatePaymentsRequest) IdempotencyKey(idempotencyKey string) ApiCreatePaymentsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [expected StatusCallback values](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback)
func (r ApiCreatePaymentsRequest) StatusCallback(statusCallback string) ApiCreatePaymentsRequest {
	r.statusCallback = &statusCallback
	return r
}

// Type of bank account if payment source is ACH. One of &#x60;consumer-checking&#x60;, &#x60;consumer-savings&#x60;, or &#x60;commercial-checking&#x60;. The default value is &#x60;consumer-checking&#x60;.
func (r ApiCreatePaymentsRequest) BankAccountType(bankAccountType string) ApiCreatePaymentsRequest {
	r.bankAccountType = &bankAccountType
	return r
}

// A positive decimal value less than 1,000,000 to charge against the credit card or bank account. Default currency can be overwritten with &#x60;currency&#x60; field. Leave blank or set to 0 to tokenize.
func (r ApiCreatePaymentsRequest) ChargeAmount(chargeAmount float32) ApiCreatePaymentsRequest {
	r.chargeAmount = &chargeAmount
	return r
}

// The currency of the &#x60;charge_amount&#x60;, formatted as [ISO 4127](http://www.iso.org/iso/home/standards/currency_codes.htm) format. The default value is &#x60;USD&#x60; and all values allowed from the &lt;Pay&gt; Connector are accepted.
func (r ApiCreatePaymentsRequest) Currency(currency string) ApiCreatePaymentsRequest {
	r.currency = &currency
	return r
}

// The description can be used to provide more details regarding the transaction. This information is submitted along with the payment details to the Payment Connector which are then posted on the transactions.
func (r ApiCreatePaymentsRequest) Description(description string) ApiCreatePaymentsRequest {
	r.description = &description
	return r
}

// A list of inputs that should be accepted. Currently only &#x60;dtmf&#x60; is supported. All digits captured during a pay session are redacted from the logs.
func (r ApiCreatePaymentsRequest) Input(input string) ApiCreatePaymentsRequest {
	r.input = &input
	return r
}

// A positive integer that is used to validate the length of the &#x60;PostalCode&#x60; inputted by the user. User must enter this many digits.
func (r ApiCreatePaymentsRequest) MinPostalCodeLength(minPostalCodeLength int32) ApiCreatePaymentsRequest {
	r.minPostalCodeLength = &minPostalCodeLength
	return r
}

// A single-level JSON object used to pass custom parameters to payment processors. (Required for ACH payments). The information that has to be included here depends on the &lt;Pay&gt; Connector. [Read more](https://www.twilio.com/console/voice/pay-connectors).
func (r ApiCreatePaymentsRequest) Parameter(parameter interface{}) ApiCreatePaymentsRequest {
	r.parameter = &parameter
	return r
}

// This is the unique name corresponding to the Payment Gateway Connector installed in the Twilio Add-ons. Learn more about [&lt;Pay&gt; Connectors](https://www.twilio.com/console/voice/pay-connectors). The default value is &#x60;Default&#x60;.
func (r ApiCreatePaymentsRequest) PaymentConnector(paymentConnector string) ApiCreatePaymentsRequest {
	r.paymentConnector = &paymentConnector
	return r
}

// Type of payment being captured. One of &#x60;credit-card&#x60; or &#x60;ach-debit&#x60;. The default value is &#x60;credit-card&#x60;.
func (r ApiCreatePaymentsRequest) PaymentMethod(paymentMethod string) ApiCreatePaymentsRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Indicates whether the credit card postal code (zip code) is a required piece of payment information that must be provided by the caller. The default is &#x60;true&#x60;.
func (r ApiCreatePaymentsRequest) PostalCode(postalCode bool) ApiCreatePaymentsRequest {
	r.postalCode = &postalCode
	return r
}

// Indicates whether the credit card security code is a required piece of payment information that must be provided by the caller. The default is &#x60;true&#x60;.
func (r ApiCreatePaymentsRequest) SecurityCode(securityCode bool) ApiCreatePaymentsRequest {
	r.securityCode = &securityCode
	return r
}

// The number of seconds that &lt;Pay&gt; should wait for the caller to press a digit between each subsequent digit, after the first one, before moving on to validate the digits captured. The default is &#x60;5&#x60;, maximum is &#x60;600&#x60;.
func (r ApiCreatePaymentsRequest) Timeout(timeout int32) ApiCreatePaymentsRequest {
	r.timeout = &timeout
	return r
}

// Indicates whether the payment method should be tokenized as a &#x60;one-time&#x60; or &#x60;reusable&#x60; token. The default value is &#x60;reusable&#x60;. Do not enter a charge amount when tokenizing. If a charge amount is entered, the payment method will be charged and not tokenized.
func (r ApiCreatePaymentsRequest) TokenType(tokenType string) ApiCreatePaymentsRequest {
	r.tokenType = &tokenType
	return r
}

// Credit card types separated by space that Pay should accept. The default value is &#x60;visa mastercard amex&#x60;
func (r ApiCreatePaymentsRequest) ValidCardTypes(validCardTypes string) ApiCreatePaymentsRequest {
	r.validCardTypes = &validCardTypes
	return r
}

func (r ApiCreatePaymentsRequest) Execute() (*ApiV2010AccountCallPayments, *http.Response, error) {
	return r.ApiService.CreatePaymentsExecute(r)
}

/*
CreatePayments Method for CreatePayments

create an instance of payments. This will start a new payments session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param callSid The SID of the call that will create the resource. Call leg associated with this sid is expected to provide payment information thru DTMF.
 @return ApiCreatePaymentsRequest
*/
func (a *DefaultApiService) CreatePayments(ctx context.Context, accountSid string, callSid string) ApiCreatePaymentsRequest {
	return ApiCreatePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallPayments
func (a *DefaultApiService) CreatePaymentsExecute(r ApiCreatePaymentsRequest) (*ApiV2010AccountCallPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.statusCallback == nil {
		return localVarReturnValue, nil, reportError("statusCallback is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.bankAccountType != nil {
		localVarFormParams.Add("BankAccountType", parameterToString(*r.bankAccountType, ""))
	}
	if r.chargeAmount != nil {
		localVarFormParams.Add("ChargeAmount", parameterToString(*r.chargeAmount, ""))
	}
	if r.currency != nil {
		localVarFormParams.Add("Currency", parameterToString(*r.currency, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("Description", parameterToString(*r.description, ""))
	}
	localVarFormParams.Add("IdempotencyKey", parameterToString(*r.idempotencyKey, ""))
	if r.input != nil {
		localVarFormParams.Add("Input", parameterToString(*r.input, ""))
	}
	if r.minPostalCodeLength != nil {
		localVarFormParams.Add("MinPostalCodeLength", parameterToString(*r.minPostalCodeLength, ""))
	}
	if r.parameter != nil {
		localVarFormParams.Add("Parameter", parameterToString(*r.parameter, ""))
	}
	if r.paymentConnector != nil {
		localVarFormParams.Add("PaymentConnector", parameterToString(*r.paymentConnector, ""))
	}
	if r.paymentMethod != nil {
		localVarFormParams.Add("PaymentMethod", parameterToString(*r.paymentMethod, ""))
	}
	if r.postalCode != nil {
		localVarFormParams.Add("PostalCode", parameterToString(*r.postalCode, ""))
	}
	if r.securityCode != nil {
		localVarFormParams.Add("SecurityCode", parameterToString(*r.securityCode, ""))
	}
	localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	if r.timeout != nil {
		localVarFormParams.Add("Timeout", parameterToString(*r.timeout, ""))
	}
	if r.tokenType != nil {
		localVarFormParams.Add("TokenType", parameterToString(*r.tokenType, ""))
	}
	if r.validCardTypes != nil {
		localVarFormParams.Add("ValidCardTypes", parameterToString(*r.validCardTypes, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateQueueRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
	maxSize *int32
}

// A descriptive string that you created to describe this resource. It can be up to 64 characters long.
func (r ApiCreateQueueRequest) FriendlyName(friendlyName string) ApiCreateQueueRequest {
	r.friendlyName = &friendlyName
	return r
}

// The maximum number of calls allowed to be in the queue. The default is 100. The maximum is 5000.
func (r ApiCreateQueueRequest) MaxSize(maxSize int32) ApiCreateQueueRequest {
	r.maxSize = &maxSize
	return r
}

func (r ApiCreateQueueRequest) Execute() (*ApiV2010AccountQueue, *http.Response, error) {
	return r.ApiService.CreateQueueExecute(r)
}

/*
CreateQueue Method for CreateQueue

Create a queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateQueueRequest
*/
func (a *DefaultApiService) CreateQueue(ctx context.Context, accountSid string) ApiCreateQueueRequest {
	return ApiCreateQueueRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountQueue
func (a *DefaultApiService) CreateQueueExecute(r ApiCreateQueueRequest) (*ApiV2010AccountQueue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountQueue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.friendlyName == nil {
		return localVarReturnValue, nil, reportError("friendlyName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	if r.maxSize != nil {
		localVarFormParams.Add("MaxSize", parameterToString(*r.maxSize, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipAuthCallsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	credentialListSid *string
}

// The SID of the CredentialList resource to map to the SIP domain.
func (r ApiCreateSipAuthCallsCredentialListMappingRequest) CredentialListSid(credentialListSid string) ApiCreateSipAuthCallsCredentialListMappingRequest {
	r.credentialListSid = &credentialListSid
	return r
}

func (r ApiCreateSipAuthCallsCredentialListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping, *http.Response, error) {
	return r.ApiService.CreateSipAuthCallsCredentialListMappingExecute(r)
}

/*
CreateSipAuthCallsCredentialListMapping Method for CreateSipAuthCallsCredentialListMapping

Create a new credential list mapping resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param domainSid The SID of the SIP domain that will contain the new resource.
 @return ApiCreateSipAuthCallsCredentialListMappingRequest
*/
func (a *DefaultApiService) CreateSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string) ApiCreateSipAuthCallsCredentialListMappingRequest {
	return ApiCreateSipAuthCallsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
func (a *DefaultApiService) CreateSipAuthCallsCredentialListMappingExecute(r ApiCreateSipAuthCallsCredentialListMappingRequest) (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipAuthCallsCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if r.credentialListSid == nil {
		return localVarReturnValue, nil, reportError("credentialListSid is required and must be specified")
	}
	if strlen(*r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(*r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("CredentialListSid", parameterToString(*r.credentialListSid, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipAuthCallsIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	ipAccessControlListSid *string
}

// The SID of the IpAccessControlList resource to map to the SIP domain.
func (r ApiCreateSipAuthCallsIpAccessControlListMappingRequest) IpAccessControlListSid(ipAccessControlListSid string) ApiCreateSipAuthCallsIpAccessControlListMappingRequest {
	r.ipAccessControlListSid = &ipAccessControlListSid
	return r
}

func (r ApiCreateSipAuthCallsIpAccessControlListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping, *http.Response, error) {
	return r.ApiService.CreateSipAuthCallsIpAccessControlListMappingExecute(r)
}

/*
CreateSipAuthCallsIpAccessControlListMapping Method for CreateSipAuthCallsIpAccessControlListMapping

Create a new IP Access Control List mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param domainSid The SID of the SIP domain that will contain the new resource.
 @return ApiCreateSipAuthCallsIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) CreateSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string) ApiCreateSipAuthCallsIpAccessControlListMappingRequest {
	return ApiCreateSipAuthCallsIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
func (a *DefaultApiService) CreateSipAuthCallsIpAccessControlListMappingExecute(r ApiCreateSipAuthCallsIpAccessControlListMappingRequest) (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipAuthCallsIpAccessControlListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if r.ipAccessControlListSid == nil {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid is required and must be specified")
	}
	if strlen(*r.ipAccessControlListSid) < 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(*r.ipAccessControlListSid) > 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("IpAccessControlListSid", parameterToString(*r.ipAccessControlListSid, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipAuthRegistrationsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	credentialListSid *string
}

// The SID of the CredentialList resource to map to the SIP domain.
func (r ApiCreateSipAuthRegistrationsCredentialListMappingRequest) CredentialListSid(credentialListSid string) ApiCreateSipAuthRegistrationsCredentialListMappingRequest {
	r.credentialListSid = &credentialListSid
	return r
}

func (r ApiCreateSipAuthRegistrationsCredentialListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping, *http.Response, error) {
	return r.ApiService.CreateSipAuthRegistrationsCredentialListMappingExecute(r)
}

/*
CreateSipAuthRegistrationsCredentialListMapping Method for CreateSipAuthRegistrationsCredentialListMapping

Create a new credential list mapping resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @param domainSid The SID of the SIP domain that will contain the new resource.
 @return ApiCreateSipAuthRegistrationsCredentialListMappingRequest
*/
func (a *DefaultApiService) CreateSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string) ApiCreateSipAuthRegistrationsCredentialListMappingRequest {
	return ApiCreateSipAuthRegistrationsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
func (a *DefaultApiService) CreateSipAuthRegistrationsCredentialListMappingExecute(r ApiCreateSipAuthRegistrationsCredentialListMappingRequest) (*ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipAuthRegistrationsCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if r.credentialListSid == nil {
		return localVarReturnValue, nil, reportError("credentialListSid is required and must be specified")
	}
	if strlen(*r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(*r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("CredentialListSid", parameterToString(*r.credentialListSid, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipCredentialRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	credentialListSid string
	password *string
	username *string
}

// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg &#x60;IWasAtSignal2018&#x60;)
func (r ApiCreateSipCredentialRequest) Password(password string) ApiCreateSipCredentialRequest {
	r.password = &password
	return r
}

// The username that will be passed when authenticating SIP requests. The username should be sent in response to Twilio&#39;s challenge of the initial INVITE. It can be up to 32 characters long.
func (r ApiCreateSipCredentialRequest) Username(username string) ApiCreateSipCredentialRequest {
	r.username = &username
	return r
}

func (r ApiCreateSipCredentialRequest) Execute() (*ApiV2010AccountSipSipCredentialListSipCredential, *http.Response, error) {
	return r.ApiService.CreateSipCredentialExecute(r)
}

/*
CreateSipCredential Method for CreateSipCredential

Create a new credential resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param credentialListSid The unique id that identifies the credential list to include the created credential.
 @return ApiCreateSipCredentialRequest
*/
func (a *DefaultApiService) CreateSipCredential(ctx context.Context, accountSid string, credentialListSid string) ApiCreateSipCredentialRequest {
	return ApiCreateSipCredentialRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		credentialListSid: credentialListSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipCredentialListSipCredential
func (a *DefaultApiService) CreateSipCredentialExecute(r ApiCreateSipCredentialRequest) (*ApiV2010AccountSipSipCredentialListSipCredential, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipCredentialListSipCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CredentialListSid"+"}", url.PathEscape(parameterToString(r.credentialListSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("Password", parameterToString(*r.password, ""))
	localVarFormParams.Add("Username", parameterToString(*r.username, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipCredentialListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
}

// A human readable descriptive text that describes the CredentialList, up to 64 characters long.
func (r ApiCreateSipCredentialListRequest) FriendlyName(friendlyName string) ApiCreateSipCredentialListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiCreateSipCredentialListRequest) Execute() (*ApiV2010AccountSipSipCredentialList, *http.Response, error) {
	return r.ApiService.CreateSipCredentialListExecute(r)
}

/*
CreateSipCredentialList Method for CreateSipCredentialList

Create a Credential List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @return ApiCreateSipCredentialListRequest
*/
func (a *DefaultApiService) CreateSipCredentialList(ctx context.Context, accountSid string) ApiCreateSipCredentialListRequest {
	return ApiCreateSipCredentialListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipCredentialList
func (a *DefaultApiService) CreateSipCredentialListExecute(r ApiCreateSipCredentialListRequest) (*ApiV2010AccountSipSipCredentialList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipCredentialList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipCredentialList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.friendlyName == nil {
		return localVarReturnValue, nil, reportError("friendlyName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	credentialListSid *string
}

// A 34 character string that uniquely identifies the CredentialList resource to map to the SIP domain.
func (r ApiCreateSipCredentialListMappingRequest) CredentialListSid(credentialListSid string) ApiCreateSipCredentialListMappingRequest {
	r.credentialListSid = &credentialListSid
	return r
}

func (r ApiCreateSipCredentialListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipCredentialListMapping, *http.Response, error) {
	return r.ApiService.CreateSipCredentialListMappingExecute(r)
}

/*
CreateSipCredentialListMapping Method for CreateSipCredentialListMapping

Create a CredentialListMapping resource for an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP Domain for which the CredentialList resource will be mapped.
 @return ApiCreateSipCredentialListMappingRequest
*/
func (a *DefaultApiService) CreateSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string) ApiCreateSipCredentialListMappingRequest {
	return ApiCreateSipCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipCredentialListMapping
func (a *DefaultApiService) CreateSipCredentialListMappingExecute(r ApiCreateSipCredentialListMappingRequest) (*ApiV2010AccountSipSipDomainSipCredentialListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipCredentialListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if r.credentialListSid == nil {
		return localVarReturnValue, nil, reportError("credentialListSid is required and must be specified")
	}
	if strlen(*r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(*r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("CredentialListSid", parameterToString(*r.credentialListSid, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipDomainRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainName *string
	byocTrunkSid *string
	emergencyCallerSid *string
	emergencyCallingEnabled *bool
	friendlyName *string
	secure *bool
	sipRegistration *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceStatusCallbackMethod *string
	voiceStatusCallbackUrl *string
	voiceUrl *string
}

// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and \\\&quot;-\\\&quot; and must end with &#x60;sip.twilio.com&#x60;.
func (r ApiCreateSipDomainRequest) DomainName(domainName string) ApiCreateSipDomainRequest {
	r.domainName = &domainName
	return r
}

// The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will be associated with.
func (r ApiCreateSipDomainRequest) ByocTrunkSid(byocTrunkSid string) ApiCreateSipDomainRequest {
	r.byocTrunkSid = &byocTrunkSid
	return r
}

// Whether an emergency caller sid is configured for the domain. If present, this phone number will be used as the callback for the emergency call.
func (r ApiCreateSipDomainRequest) EmergencyCallerSid(emergencyCallerSid string) ApiCreateSipDomainRequest {
	r.emergencyCallerSid = &emergencyCallerSid
	return r
}

// Whether emergency calling is enabled for the domain. If enabled, allows emergency calls on the domain from phone numbers with validated addresses.
func (r ApiCreateSipDomainRequest) EmergencyCallingEnabled(emergencyCallingEnabled bool) ApiCreateSipDomainRequest {
	r.emergencyCallingEnabled = &emergencyCallingEnabled
	return r
}

// A descriptive string that you created to describe the resource. It can be up to 64 characters long.
func (r ApiCreateSipDomainRequest) FriendlyName(friendlyName string) ApiCreateSipDomainRequest {
	r.friendlyName = &friendlyName
	return r
}

// Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and SRTP will be negotiated on all incoming calls to this sip domain.
func (r ApiCreateSipDomainRequest) Secure(secure bool) ApiCreateSipDomainRequest {
	r.secure = &secure
	return r
}

// Whether to allow SIP Endpoints to register with the domain to receive calls. Can be &#x60;true&#x60; or &#x60;false&#x60;. &#x60;true&#x60; allows SIP Endpoints to register with the domain to receive calls, &#x60;false&#x60; does not.
func (r ApiCreateSipDomainRequest) SipRegistration(sipRegistration bool) ApiCreateSipDomainRequest {
	r.sipRegistration = &sipRegistration
	return r
}

// The HTTP method we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateSipDomainRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiCreateSipDomainRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs while retrieving or executing the TwiML from &#x60;voice_url&#x60;.
func (r ApiCreateSipDomainRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiCreateSipDomainRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateSipDomainRequest) VoiceMethod(voiceMethod string) ApiCreateSipDomainRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The HTTP method we should use to call &#x60;voice_status_callback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiCreateSipDomainRequest) VoiceStatusCallbackMethod(voiceStatusCallbackMethod string) ApiCreateSipDomainRequest {
	r.voiceStatusCallbackMethod = &voiceStatusCallbackMethod
	return r
}

// The URL that we should call to pass status parameters (such as call ended) to your application.
func (r ApiCreateSipDomainRequest) VoiceStatusCallbackUrl(voiceStatusCallbackUrl string) ApiCreateSipDomainRequest {
	r.voiceStatusCallbackUrl = &voiceStatusCallbackUrl
	return r
}

// The URL we should when the domain receives a call.
func (r ApiCreateSipDomainRequest) VoiceUrl(voiceUrl string) ApiCreateSipDomainRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiCreateSipDomainRequest) Execute() (*ApiV2010AccountSipSipDomain, *http.Response, error) {
	return r.ApiService.CreateSipDomainExecute(r)
}

/*
CreateSipDomain Method for CreateSipDomain

Create a new Domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateSipDomainRequest
*/
func (a *DefaultApiService) CreateSipDomain(ctx context.Context, accountSid string) ApiCreateSipDomainRequest {
	return ApiCreateSipDomainRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomain
func (a *DefaultApiService) CreateSipDomainExecute(r ApiCreateSipDomainRequest) (*ApiV2010AccountSipSipDomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.domainName == nil {
		return localVarReturnValue, nil, reportError("domainName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.byocTrunkSid != nil {
		localVarFormParams.Add("ByocTrunkSid", parameterToString(*r.byocTrunkSid, ""))
	}
	localVarFormParams.Add("DomainName", parameterToString(*r.domainName, ""))
	if r.emergencyCallerSid != nil {
		localVarFormParams.Add("EmergencyCallerSid", parameterToString(*r.emergencyCallerSid, ""))
	}
	if r.emergencyCallingEnabled != nil {
		localVarFormParams.Add("EmergencyCallingEnabled", parameterToString(*r.emergencyCallingEnabled, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.secure != nil {
		localVarFormParams.Add("Secure", parameterToString(*r.secure, ""))
	}
	if r.sipRegistration != nil {
		localVarFormParams.Add("SipRegistration", parameterToString(*r.sipRegistration, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceStatusCallbackMethod != nil {
		localVarFormParams.Add("VoiceStatusCallbackMethod", parameterToString(*r.voiceStatusCallbackMethod, ""))
	}
	if r.voiceStatusCallbackUrl != nil {
		localVarFormParams.Add("VoiceStatusCallbackUrl", parameterToString(*r.voiceStatusCallbackUrl, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipIpAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
}

// A human readable descriptive text that describes the IpAccessControlList, up to 64 characters long.
func (r ApiCreateSipIpAccessControlListRequest) FriendlyName(friendlyName string) ApiCreateSipIpAccessControlListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiCreateSipIpAccessControlListRequest) Execute() (*ApiV2010AccountSipSipIpAccessControlList, *http.Response, error) {
	return r.ApiService.CreateSipIpAccessControlListExecute(r)
}

/*
CreateSipIpAccessControlList Method for CreateSipIpAccessControlList

Create a new IpAccessControlList resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @return ApiCreateSipIpAccessControlListRequest
*/
func (a *DefaultApiService) CreateSipIpAccessControlList(ctx context.Context, accountSid string) ApiCreateSipIpAccessControlListRequest {
	return ApiCreateSipIpAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipIpAccessControlList
func (a *DefaultApiService) CreateSipIpAccessControlListExecute(r ApiCreateSipIpAccessControlListRequest) (*ApiV2010AccountSipSipIpAccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipIpAccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipIpAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.friendlyName == nil {
		return localVarReturnValue, nil, reportError("friendlyName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	ipAccessControlListSid *string
}

// The unique id of the IP access control list to map to the SIP domain.
func (r ApiCreateSipIpAccessControlListMappingRequest) IpAccessControlListSid(ipAccessControlListSid string) ApiCreateSipIpAccessControlListMappingRequest {
	r.ipAccessControlListSid = &ipAccessControlListSid
	return r
}

func (r ApiCreateSipIpAccessControlListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipIpAccessControlListMapping, *http.Response, error) {
	return r.ApiService.CreateSipIpAccessControlListMappingExecute(r)
}

/*
CreateSipIpAccessControlListMapping Method for CreateSipIpAccessControlListMapping

Create a new IpAccessControlListMapping resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP domain.
 @return ApiCreateSipIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) CreateSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string) ApiCreateSipIpAccessControlListMappingRequest {
	return ApiCreateSipIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
func (a *DefaultApiService) CreateSipIpAccessControlListMappingExecute(r ApiCreateSipIpAccessControlListMappingRequest) (*ApiV2010AccountSipSipDomainSipIpAccessControlListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipIpAccessControlListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if r.ipAccessControlListSid == nil {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid is required and must be specified")
	}
	if strlen(*r.ipAccessControlListSid) < 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(*r.ipAccessControlListSid) > 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("IpAccessControlListSid", parameterToString(*r.ipAccessControlListSid, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSipIpAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	ipAccessControlListSid string
	friendlyName *string
	ipAddress *string
	cidrPrefixLength *int32
}

// A human readable descriptive text for this resource, up to 64 characters long.
func (r ApiCreateSipIpAddressRequest) FriendlyName(friendlyName string) ApiCreateSipIpAddressRequest {
	r.friendlyName = &friendlyName
	return r
}

// An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.
func (r ApiCreateSipIpAddressRequest) IpAddress(ipAddress string) ApiCreateSipIpAddressRequest {
	r.ipAddress = &ipAddress
	return r
}

// An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.
func (r ApiCreateSipIpAddressRequest) CidrPrefixLength(cidrPrefixLength int32) ApiCreateSipIpAddressRequest {
	r.cidrPrefixLength = &cidrPrefixLength
	return r
}

func (r ApiCreateSipIpAddressRequest) Execute() (*ApiV2010AccountSipSipIpAccessControlListSipIpAddress, *http.Response, error) {
	return r.ApiService.CreateSipIpAddressExecute(r)
}

/*
CreateSipIpAddress Method for CreateSipIpAddress

Create a new IpAddress resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param ipAccessControlListSid The IpAccessControlList Sid with which to associate the created IpAddress resource.
 @return ApiCreateSipIpAddressRequest
*/
func (a *DefaultApiService) CreateSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string) ApiCreateSipIpAddressRequest {
	return ApiCreateSipIpAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		ipAccessControlListSid: ipAccessControlListSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipIpAccessControlListSipIpAddress
func (a *DefaultApiService) CreateSipIpAddressExecute(r ApiCreateSipIpAddressRequest) (*ApiV2010AccountSipSipIpAccessControlListSipIpAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipIpAccessControlListSipIpAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSipIpAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"IpAccessControlListSid"+"}", url.PathEscape(parameterToString(r.ipAccessControlListSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.ipAccessControlListSid) < 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(r.ipAccessControlListSid) > 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}
	if r.friendlyName == nil {
		return localVarReturnValue, nil, reportError("friendlyName is required and must be specified")
	}
	if r.ipAddress == nil {
		return localVarReturnValue, nil, reportError("ipAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cidrPrefixLength != nil {
		localVarFormParams.Add("CidrPrefixLength", parameterToString(*r.cidrPrefixLength, ""))
	}
	localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	localVarFormParams.Add("IpAddress", parameterToString(*r.ipAddress, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSiprecRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	connectorName *string
	name *string
	parameter1Name *string
	parameter1Value *string
	parameter10Name *string
	parameter10Value *string
	parameter11Name *string
	parameter11Value *string
	parameter12Name *string
	parameter12Value *string
	parameter13Name *string
	parameter13Value *string
	parameter14Name *string
	parameter14Value *string
	parameter15Name *string
	parameter15Value *string
	parameter16Name *string
	parameter16Value *string
	parameter17Name *string
	parameter17Value *string
	parameter18Name *string
	parameter18Value *string
	parameter19Name *string
	parameter19Value *string
	parameter2Name *string
	parameter2Value *string
	parameter20Name *string
	parameter20Value *string
	parameter21Name *string
	parameter21Value *string
	parameter22Name *string
	parameter22Value *string
	parameter23Name *string
	parameter23Value *string
	parameter24Name *string
	parameter24Value *string
	parameter25Name *string
	parameter25Value *string
	parameter26Name *string
	parameter26Value *string
	parameter27Name *string
	parameter27Value *string
	parameter28Name *string
	parameter28Value *string
	parameter29Name *string
	parameter29Value *string
	parameter3Name *string
	parameter3Value *string
	parameter30Name *string
	parameter30Value *string
	parameter31Name *string
	parameter31Value *string
	parameter32Name *string
	parameter32Value *string
	parameter33Name *string
	parameter33Value *string
	parameter34Name *string
	parameter34Value *string
	parameter35Name *string
	parameter35Value *string
	parameter36Name *string
	parameter36Value *string
	parameter37Name *string
	parameter37Value *string
	parameter38Name *string
	parameter38Value *string
	parameter39Name *string
	parameter39Value *string
	parameter4Name *string
	parameter4Value *string
	parameter40Name *string
	parameter40Value *string
	parameter41Name *string
	parameter41Value *string
	parameter42Name *string
	parameter42Value *string
	parameter43Name *string
	parameter43Value *string
	parameter44Name *string
	parameter44Value *string
	parameter45Name *string
	parameter45Value *string
	parameter46Name *string
	parameter46Value *string
	parameter47Name *string
	parameter47Value *string
	parameter48Name *string
	parameter48Value *string
	parameter49Name *string
	parameter49Value *string
	parameter5Name *string
	parameter5Value *string
	parameter50Name *string
	parameter50Value *string
	parameter51Name *string
	parameter51Value *string
	parameter52Name *string
	parameter52Value *string
	parameter53Name *string
	parameter53Value *string
	parameter54Name *string
	parameter54Value *string
	parameter55Name *string
	parameter55Value *string
	parameter56Name *string
	parameter56Value *string
	parameter57Name *string
	parameter57Value *string
	parameter58Name *string
	parameter58Value *string
	parameter59Name *string
	parameter59Value *string
	parameter6Name *string
	parameter6Value *string
	parameter60Name *string
	parameter60Value *string
	parameter61Name *string
	parameter61Value *string
	parameter62Name *string
	parameter62Value *string
	parameter63Name *string
	parameter63Value *string
	parameter64Name *string
	parameter64Value *string
	parameter65Name *string
	parameter65Value *string
	parameter66Name *string
	parameter66Value *string
	parameter67Name *string
	parameter67Value *string
	parameter68Name *string
	parameter68Value *string
	parameter69Name *string
	parameter69Value *string
	parameter7Name *string
	parameter7Value *string
	parameter70Name *string
	parameter70Value *string
	parameter71Name *string
	parameter71Value *string
	parameter72Name *string
	parameter72Value *string
	parameter73Name *string
	parameter73Value *string
	parameter74Name *string
	parameter74Value *string
	parameter75Name *string
	parameter75Value *string
	parameter76Name *string
	parameter76Value *string
	parameter77Name *string
	parameter77Value *string
	parameter78Name *string
	parameter78Value *string
	parameter79Name *string
	parameter79Value *string
	parameter8Name *string
	parameter8Value *string
	parameter80Name *string
	parameter80Value *string
	parameter81Name *string
	parameter81Value *string
	parameter82Name *string
	parameter82Value *string
	parameter83Name *string
	parameter83Value *string
	parameter84Name *string
	parameter84Value *string
	parameter85Name *string
	parameter85Value *string
	parameter86Name *string
	parameter86Value *string
	parameter87Name *string
	parameter87Value *string
	parameter88Name *string
	parameter88Value *string
	parameter89Name *string
	parameter89Value *string
	parameter9Name *string
	parameter9Value *string
	parameter90Name *string
	parameter90Value *string
	parameter91Name *string
	parameter91Value *string
	parameter92Name *string
	parameter92Value *string
	parameter93Name *string
	parameter93Value *string
	parameter94Name *string
	parameter94Value *string
	parameter95Name *string
	parameter95Value *string
	parameter96Name *string
	parameter96Value *string
	parameter97Name *string
	parameter97Value *string
	parameter98Name *string
	parameter98Value *string
	parameter99Name *string
	parameter99Value *string
	statusCallback *string
	statusCallbackMethod *string
	track *string
}

// Unique name used when configuring the connector via Marketplace Add-on.
func (r ApiCreateSiprecRequest) ConnectorName(connectorName string) ApiCreateSiprecRequest {
	r.connectorName = &connectorName
	return r
}

// The user-specified name of this Siprec, if one was given when the Siprec was created. This may be used to stop the Siprec.
func (r ApiCreateSiprecRequest) Name(name string) ApiCreateSiprecRequest {
	r.name = &name
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter1Name(parameter1Name string) ApiCreateSiprecRequest {
	r.parameter1Name = &parameter1Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter1Value(parameter1Value string) ApiCreateSiprecRequest {
	r.parameter1Value = &parameter1Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter10Name(parameter10Name string) ApiCreateSiprecRequest {
	r.parameter10Name = &parameter10Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter10Value(parameter10Value string) ApiCreateSiprecRequest {
	r.parameter10Value = &parameter10Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter11Name(parameter11Name string) ApiCreateSiprecRequest {
	r.parameter11Name = &parameter11Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter11Value(parameter11Value string) ApiCreateSiprecRequest {
	r.parameter11Value = &parameter11Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter12Name(parameter12Name string) ApiCreateSiprecRequest {
	r.parameter12Name = &parameter12Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter12Value(parameter12Value string) ApiCreateSiprecRequest {
	r.parameter12Value = &parameter12Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter13Name(parameter13Name string) ApiCreateSiprecRequest {
	r.parameter13Name = &parameter13Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter13Value(parameter13Value string) ApiCreateSiprecRequest {
	r.parameter13Value = &parameter13Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter14Name(parameter14Name string) ApiCreateSiprecRequest {
	r.parameter14Name = &parameter14Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter14Value(parameter14Value string) ApiCreateSiprecRequest {
	r.parameter14Value = &parameter14Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter15Name(parameter15Name string) ApiCreateSiprecRequest {
	r.parameter15Name = &parameter15Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter15Value(parameter15Value string) ApiCreateSiprecRequest {
	r.parameter15Value = &parameter15Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter16Name(parameter16Name string) ApiCreateSiprecRequest {
	r.parameter16Name = &parameter16Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter16Value(parameter16Value string) ApiCreateSiprecRequest {
	r.parameter16Value = &parameter16Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter17Name(parameter17Name string) ApiCreateSiprecRequest {
	r.parameter17Name = &parameter17Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter17Value(parameter17Value string) ApiCreateSiprecRequest {
	r.parameter17Value = &parameter17Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter18Name(parameter18Name string) ApiCreateSiprecRequest {
	r.parameter18Name = &parameter18Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter18Value(parameter18Value string) ApiCreateSiprecRequest {
	r.parameter18Value = &parameter18Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter19Name(parameter19Name string) ApiCreateSiprecRequest {
	r.parameter19Name = &parameter19Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter19Value(parameter19Value string) ApiCreateSiprecRequest {
	r.parameter19Value = &parameter19Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter2Name(parameter2Name string) ApiCreateSiprecRequest {
	r.parameter2Name = &parameter2Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter2Value(parameter2Value string) ApiCreateSiprecRequest {
	r.parameter2Value = &parameter2Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter20Name(parameter20Name string) ApiCreateSiprecRequest {
	r.parameter20Name = &parameter20Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter20Value(parameter20Value string) ApiCreateSiprecRequest {
	r.parameter20Value = &parameter20Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter21Name(parameter21Name string) ApiCreateSiprecRequest {
	r.parameter21Name = &parameter21Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter21Value(parameter21Value string) ApiCreateSiprecRequest {
	r.parameter21Value = &parameter21Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter22Name(parameter22Name string) ApiCreateSiprecRequest {
	r.parameter22Name = &parameter22Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter22Value(parameter22Value string) ApiCreateSiprecRequest {
	r.parameter22Value = &parameter22Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter23Name(parameter23Name string) ApiCreateSiprecRequest {
	r.parameter23Name = &parameter23Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter23Value(parameter23Value string) ApiCreateSiprecRequest {
	r.parameter23Value = &parameter23Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter24Name(parameter24Name string) ApiCreateSiprecRequest {
	r.parameter24Name = &parameter24Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter24Value(parameter24Value string) ApiCreateSiprecRequest {
	r.parameter24Value = &parameter24Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter25Name(parameter25Name string) ApiCreateSiprecRequest {
	r.parameter25Name = &parameter25Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter25Value(parameter25Value string) ApiCreateSiprecRequest {
	r.parameter25Value = &parameter25Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter26Name(parameter26Name string) ApiCreateSiprecRequest {
	r.parameter26Name = &parameter26Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter26Value(parameter26Value string) ApiCreateSiprecRequest {
	r.parameter26Value = &parameter26Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter27Name(parameter27Name string) ApiCreateSiprecRequest {
	r.parameter27Name = &parameter27Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter27Value(parameter27Value string) ApiCreateSiprecRequest {
	r.parameter27Value = &parameter27Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter28Name(parameter28Name string) ApiCreateSiprecRequest {
	r.parameter28Name = &parameter28Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter28Value(parameter28Value string) ApiCreateSiprecRequest {
	r.parameter28Value = &parameter28Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter29Name(parameter29Name string) ApiCreateSiprecRequest {
	r.parameter29Name = &parameter29Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter29Value(parameter29Value string) ApiCreateSiprecRequest {
	r.parameter29Value = &parameter29Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter3Name(parameter3Name string) ApiCreateSiprecRequest {
	r.parameter3Name = &parameter3Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter3Value(parameter3Value string) ApiCreateSiprecRequest {
	r.parameter3Value = &parameter3Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter30Name(parameter30Name string) ApiCreateSiprecRequest {
	r.parameter30Name = &parameter30Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter30Value(parameter30Value string) ApiCreateSiprecRequest {
	r.parameter30Value = &parameter30Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter31Name(parameter31Name string) ApiCreateSiprecRequest {
	r.parameter31Name = &parameter31Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter31Value(parameter31Value string) ApiCreateSiprecRequest {
	r.parameter31Value = &parameter31Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter32Name(parameter32Name string) ApiCreateSiprecRequest {
	r.parameter32Name = &parameter32Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter32Value(parameter32Value string) ApiCreateSiprecRequest {
	r.parameter32Value = &parameter32Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter33Name(parameter33Name string) ApiCreateSiprecRequest {
	r.parameter33Name = &parameter33Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter33Value(parameter33Value string) ApiCreateSiprecRequest {
	r.parameter33Value = &parameter33Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter34Name(parameter34Name string) ApiCreateSiprecRequest {
	r.parameter34Name = &parameter34Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter34Value(parameter34Value string) ApiCreateSiprecRequest {
	r.parameter34Value = &parameter34Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter35Name(parameter35Name string) ApiCreateSiprecRequest {
	r.parameter35Name = &parameter35Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter35Value(parameter35Value string) ApiCreateSiprecRequest {
	r.parameter35Value = &parameter35Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter36Name(parameter36Name string) ApiCreateSiprecRequest {
	r.parameter36Name = &parameter36Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter36Value(parameter36Value string) ApiCreateSiprecRequest {
	r.parameter36Value = &parameter36Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter37Name(parameter37Name string) ApiCreateSiprecRequest {
	r.parameter37Name = &parameter37Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter37Value(parameter37Value string) ApiCreateSiprecRequest {
	r.parameter37Value = &parameter37Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter38Name(parameter38Name string) ApiCreateSiprecRequest {
	r.parameter38Name = &parameter38Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter38Value(parameter38Value string) ApiCreateSiprecRequest {
	r.parameter38Value = &parameter38Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter39Name(parameter39Name string) ApiCreateSiprecRequest {
	r.parameter39Name = &parameter39Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter39Value(parameter39Value string) ApiCreateSiprecRequest {
	r.parameter39Value = &parameter39Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter4Name(parameter4Name string) ApiCreateSiprecRequest {
	r.parameter4Name = &parameter4Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter4Value(parameter4Value string) ApiCreateSiprecRequest {
	r.parameter4Value = &parameter4Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter40Name(parameter40Name string) ApiCreateSiprecRequest {
	r.parameter40Name = &parameter40Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter40Value(parameter40Value string) ApiCreateSiprecRequest {
	r.parameter40Value = &parameter40Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter41Name(parameter41Name string) ApiCreateSiprecRequest {
	r.parameter41Name = &parameter41Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter41Value(parameter41Value string) ApiCreateSiprecRequest {
	r.parameter41Value = &parameter41Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter42Name(parameter42Name string) ApiCreateSiprecRequest {
	r.parameter42Name = &parameter42Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter42Value(parameter42Value string) ApiCreateSiprecRequest {
	r.parameter42Value = &parameter42Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter43Name(parameter43Name string) ApiCreateSiprecRequest {
	r.parameter43Name = &parameter43Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter43Value(parameter43Value string) ApiCreateSiprecRequest {
	r.parameter43Value = &parameter43Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter44Name(parameter44Name string) ApiCreateSiprecRequest {
	r.parameter44Name = &parameter44Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter44Value(parameter44Value string) ApiCreateSiprecRequest {
	r.parameter44Value = &parameter44Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter45Name(parameter45Name string) ApiCreateSiprecRequest {
	r.parameter45Name = &parameter45Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter45Value(parameter45Value string) ApiCreateSiprecRequest {
	r.parameter45Value = &parameter45Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter46Name(parameter46Name string) ApiCreateSiprecRequest {
	r.parameter46Name = &parameter46Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter46Value(parameter46Value string) ApiCreateSiprecRequest {
	r.parameter46Value = &parameter46Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter47Name(parameter47Name string) ApiCreateSiprecRequest {
	r.parameter47Name = &parameter47Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter47Value(parameter47Value string) ApiCreateSiprecRequest {
	r.parameter47Value = &parameter47Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter48Name(parameter48Name string) ApiCreateSiprecRequest {
	r.parameter48Name = &parameter48Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter48Value(parameter48Value string) ApiCreateSiprecRequest {
	r.parameter48Value = &parameter48Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter49Name(parameter49Name string) ApiCreateSiprecRequest {
	r.parameter49Name = &parameter49Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter49Value(parameter49Value string) ApiCreateSiprecRequest {
	r.parameter49Value = &parameter49Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter5Name(parameter5Name string) ApiCreateSiprecRequest {
	r.parameter5Name = &parameter5Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter5Value(parameter5Value string) ApiCreateSiprecRequest {
	r.parameter5Value = &parameter5Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter50Name(parameter50Name string) ApiCreateSiprecRequest {
	r.parameter50Name = &parameter50Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter50Value(parameter50Value string) ApiCreateSiprecRequest {
	r.parameter50Value = &parameter50Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter51Name(parameter51Name string) ApiCreateSiprecRequest {
	r.parameter51Name = &parameter51Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter51Value(parameter51Value string) ApiCreateSiprecRequest {
	r.parameter51Value = &parameter51Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter52Name(parameter52Name string) ApiCreateSiprecRequest {
	r.parameter52Name = &parameter52Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter52Value(parameter52Value string) ApiCreateSiprecRequest {
	r.parameter52Value = &parameter52Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter53Name(parameter53Name string) ApiCreateSiprecRequest {
	r.parameter53Name = &parameter53Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter53Value(parameter53Value string) ApiCreateSiprecRequest {
	r.parameter53Value = &parameter53Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter54Name(parameter54Name string) ApiCreateSiprecRequest {
	r.parameter54Name = &parameter54Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter54Value(parameter54Value string) ApiCreateSiprecRequest {
	r.parameter54Value = &parameter54Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter55Name(parameter55Name string) ApiCreateSiprecRequest {
	r.parameter55Name = &parameter55Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter55Value(parameter55Value string) ApiCreateSiprecRequest {
	r.parameter55Value = &parameter55Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter56Name(parameter56Name string) ApiCreateSiprecRequest {
	r.parameter56Name = &parameter56Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter56Value(parameter56Value string) ApiCreateSiprecRequest {
	r.parameter56Value = &parameter56Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter57Name(parameter57Name string) ApiCreateSiprecRequest {
	r.parameter57Name = &parameter57Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter57Value(parameter57Value string) ApiCreateSiprecRequest {
	r.parameter57Value = &parameter57Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter58Name(parameter58Name string) ApiCreateSiprecRequest {
	r.parameter58Name = &parameter58Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter58Value(parameter58Value string) ApiCreateSiprecRequest {
	r.parameter58Value = &parameter58Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter59Name(parameter59Name string) ApiCreateSiprecRequest {
	r.parameter59Name = &parameter59Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter59Value(parameter59Value string) ApiCreateSiprecRequest {
	r.parameter59Value = &parameter59Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter6Name(parameter6Name string) ApiCreateSiprecRequest {
	r.parameter6Name = &parameter6Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter6Value(parameter6Value string) ApiCreateSiprecRequest {
	r.parameter6Value = &parameter6Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter60Name(parameter60Name string) ApiCreateSiprecRequest {
	r.parameter60Name = &parameter60Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter60Value(parameter60Value string) ApiCreateSiprecRequest {
	r.parameter60Value = &parameter60Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter61Name(parameter61Name string) ApiCreateSiprecRequest {
	r.parameter61Name = &parameter61Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter61Value(parameter61Value string) ApiCreateSiprecRequest {
	r.parameter61Value = &parameter61Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter62Name(parameter62Name string) ApiCreateSiprecRequest {
	r.parameter62Name = &parameter62Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter62Value(parameter62Value string) ApiCreateSiprecRequest {
	r.parameter62Value = &parameter62Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter63Name(parameter63Name string) ApiCreateSiprecRequest {
	r.parameter63Name = &parameter63Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter63Value(parameter63Value string) ApiCreateSiprecRequest {
	r.parameter63Value = &parameter63Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter64Name(parameter64Name string) ApiCreateSiprecRequest {
	r.parameter64Name = &parameter64Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter64Value(parameter64Value string) ApiCreateSiprecRequest {
	r.parameter64Value = &parameter64Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter65Name(parameter65Name string) ApiCreateSiprecRequest {
	r.parameter65Name = &parameter65Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter65Value(parameter65Value string) ApiCreateSiprecRequest {
	r.parameter65Value = &parameter65Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter66Name(parameter66Name string) ApiCreateSiprecRequest {
	r.parameter66Name = &parameter66Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter66Value(parameter66Value string) ApiCreateSiprecRequest {
	r.parameter66Value = &parameter66Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter67Name(parameter67Name string) ApiCreateSiprecRequest {
	r.parameter67Name = &parameter67Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter67Value(parameter67Value string) ApiCreateSiprecRequest {
	r.parameter67Value = &parameter67Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter68Name(parameter68Name string) ApiCreateSiprecRequest {
	r.parameter68Name = &parameter68Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter68Value(parameter68Value string) ApiCreateSiprecRequest {
	r.parameter68Value = &parameter68Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter69Name(parameter69Name string) ApiCreateSiprecRequest {
	r.parameter69Name = &parameter69Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter69Value(parameter69Value string) ApiCreateSiprecRequest {
	r.parameter69Value = &parameter69Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter7Name(parameter7Name string) ApiCreateSiprecRequest {
	r.parameter7Name = &parameter7Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter7Value(parameter7Value string) ApiCreateSiprecRequest {
	r.parameter7Value = &parameter7Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter70Name(parameter70Name string) ApiCreateSiprecRequest {
	r.parameter70Name = &parameter70Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter70Value(parameter70Value string) ApiCreateSiprecRequest {
	r.parameter70Value = &parameter70Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter71Name(parameter71Name string) ApiCreateSiprecRequest {
	r.parameter71Name = &parameter71Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter71Value(parameter71Value string) ApiCreateSiprecRequest {
	r.parameter71Value = &parameter71Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter72Name(parameter72Name string) ApiCreateSiprecRequest {
	r.parameter72Name = &parameter72Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter72Value(parameter72Value string) ApiCreateSiprecRequest {
	r.parameter72Value = &parameter72Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter73Name(parameter73Name string) ApiCreateSiprecRequest {
	r.parameter73Name = &parameter73Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter73Value(parameter73Value string) ApiCreateSiprecRequest {
	r.parameter73Value = &parameter73Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter74Name(parameter74Name string) ApiCreateSiprecRequest {
	r.parameter74Name = &parameter74Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter74Value(parameter74Value string) ApiCreateSiprecRequest {
	r.parameter74Value = &parameter74Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter75Name(parameter75Name string) ApiCreateSiprecRequest {
	r.parameter75Name = &parameter75Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter75Value(parameter75Value string) ApiCreateSiprecRequest {
	r.parameter75Value = &parameter75Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter76Name(parameter76Name string) ApiCreateSiprecRequest {
	r.parameter76Name = &parameter76Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter76Value(parameter76Value string) ApiCreateSiprecRequest {
	r.parameter76Value = &parameter76Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter77Name(parameter77Name string) ApiCreateSiprecRequest {
	r.parameter77Name = &parameter77Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter77Value(parameter77Value string) ApiCreateSiprecRequest {
	r.parameter77Value = &parameter77Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter78Name(parameter78Name string) ApiCreateSiprecRequest {
	r.parameter78Name = &parameter78Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter78Value(parameter78Value string) ApiCreateSiprecRequest {
	r.parameter78Value = &parameter78Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter79Name(parameter79Name string) ApiCreateSiprecRequest {
	r.parameter79Name = &parameter79Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter79Value(parameter79Value string) ApiCreateSiprecRequest {
	r.parameter79Value = &parameter79Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter8Name(parameter8Name string) ApiCreateSiprecRequest {
	r.parameter8Name = &parameter8Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter8Value(parameter8Value string) ApiCreateSiprecRequest {
	r.parameter8Value = &parameter8Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter80Name(parameter80Name string) ApiCreateSiprecRequest {
	r.parameter80Name = &parameter80Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter80Value(parameter80Value string) ApiCreateSiprecRequest {
	r.parameter80Value = &parameter80Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter81Name(parameter81Name string) ApiCreateSiprecRequest {
	r.parameter81Name = &parameter81Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter81Value(parameter81Value string) ApiCreateSiprecRequest {
	r.parameter81Value = &parameter81Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter82Name(parameter82Name string) ApiCreateSiprecRequest {
	r.parameter82Name = &parameter82Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter82Value(parameter82Value string) ApiCreateSiprecRequest {
	r.parameter82Value = &parameter82Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter83Name(parameter83Name string) ApiCreateSiprecRequest {
	r.parameter83Name = &parameter83Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter83Value(parameter83Value string) ApiCreateSiprecRequest {
	r.parameter83Value = &parameter83Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter84Name(parameter84Name string) ApiCreateSiprecRequest {
	r.parameter84Name = &parameter84Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter84Value(parameter84Value string) ApiCreateSiprecRequest {
	r.parameter84Value = &parameter84Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter85Name(parameter85Name string) ApiCreateSiprecRequest {
	r.parameter85Name = &parameter85Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter85Value(parameter85Value string) ApiCreateSiprecRequest {
	r.parameter85Value = &parameter85Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter86Name(parameter86Name string) ApiCreateSiprecRequest {
	r.parameter86Name = &parameter86Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter86Value(parameter86Value string) ApiCreateSiprecRequest {
	r.parameter86Value = &parameter86Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter87Name(parameter87Name string) ApiCreateSiprecRequest {
	r.parameter87Name = &parameter87Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter87Value(parameter87Value string) ApiCreateSiprecRequest {
	r.parameter87Value = &parameter87Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter88Name(parameter88Name string) ApiCreateSiprecRequest {
	r.parameter88Name = &parameter88Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter88Value(parameter88Value string) ApiCreateSiprecRequest {
	r.parameter88Value = &parameter88Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter89Name(parameter89Name string) ApiCreateSiprecRequest {
	r.parameter89Name = &parameter89Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter89Value(parameter89Value string) ApiCreateSiprecRequest {
	r.parameter89Value = &parameter89Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter9Name(parameter9Name string) ApiCreateSiprecRequest {
	r.parameter9Name = &parameter9Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter9Value(parameter9Value string) ApiCreateSiprecRequest {
	r.parameter9Value = &parameter9Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter90Name(parameter90Name string) ApiCreateSiprecRequest {
	r.parameter90Name = &parameter90Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter90Value(parameter90Value string) ApiCreateSiprecRequest {
	r.parameter90Value = &parameter90Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter91Name(parameter91Name string) ApiCreateSiprecRequest {
	r.parameter91Name = &parameter91Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter91Value(parameter91Value string) ApiCreateSiprecRequest {
	r.parameter91Value = &parameter91Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter92Name(parameter92Name string) ApiCreateSiprecRequest {
	r.parameter92Name = &parameter92Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter92Value(parameter92Value string) ApiCreateSiprecRequest {
	r.parameter92Value = &parameter92Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter93Name(parameter93Name string) ApiCreateSiprecRequest {
	r.parameter93Name = &parameter93Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter93Value(parameter93Value string) ApiCreateSiprecRequest {
	r.parameter93Value = &parameter93Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter94Name(parameter94Name string) ApiCreateSiprecRequest {
	r.parameter94Name = &parameter94Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter94Value(parameter94Value string) ApiCreateSiprecRequest {
	r.parameter94Value = &parameter94Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter95Name(parameter95Name string) ApiCreateSiprecRequest {
	r.parameter95Name = &parameter95Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter95Value(parameter95Value string) ApiCreateSiprecRequest {
	r.parameter95Value = &parameter95Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter96Name(parameter96Name string) ApiCreateSiprecRequest {
	r.parameter96Name = &parameter96Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter96Value(parameter96Value string) ApiCreateSiprecRequest {
	r.parameter96Value = &parameter96Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter97Name(parameter97Name string) ApiCreateSiprecRequest {
	r.parameter97Name = &parameter97Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter97Value(parameter97Value string) ApiCreateSiprecRequest {
	r.parameter97Value = &parameter97Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter98Name(parameter98Name string) ApiCreateSiprecRequest {
	r.parameter98Name = &parameter98Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter98Value(parameter98Value string) ApiCreateSiprecRequest {
	r.parameter98Value = &parameter98Value
	return r
}

// Parameter name
func (r ApiCreateSiprecRequest) Parameter99Name(parameter99Name string) ApiCreateSiprecRequest {
	r.parameter99Name = &parameter99Name
	return r
}

// Parameter value
func (r ApiCreateSiprecRequest) Parameter99Value(parameter99Value string) ApiCreateSiprecRequest {
	r.parameter99Value = &parameter99Value
	return r
}

// Absolute URL of the status callback.
func (r ApiCreateSiprecRequest) StatusCallback(statusCallback string) ApiCreateSiprecRequest {
	r.statusCallback = &statusCallback
	return r
}

// The http method for the status_callback (one of GET, POST).
func (r ApiCreateSiprecRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateSiprecRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// One of &#x60;inbound_track&#x60;, &#x60;outbound_track&#x60;, &#x60;both_tracks&#x60;.
func (r ApiCreateSiprecRequest) Track(track string) ApiCreateSiprecRequest {
	r.track = &track
	return r
}

func (r ApiCreateSiprecRequest) Execute() (*ApiV2010AccountCallSiprec, *http.Response, error) {
	return r.ApiService.CreateSiprecExecute(r)
}

/*
CreateSiprec Method for CreateSiprec

Create a Siprec

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created this Siprec resource.
 @param callSid The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the Siprec resource is associated with.
 @return ApiCreateSiprecRequest
*/
func (a *DefaultApiService) CreateSiprec(ctx context.Context, accountSid string, callSid string) ApiCreateSiprecRequest {
	return ApiCreateSiprecRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallSiprec
func (a *DefaultApiService) CreateSiprecExecute(r ApiCreateSiprecRequest) (*ApiV2010AccountCallSiprec, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallSiprec
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSiprec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.connectorName != nil {
		localVarFormParams.Add("ConnectorName", parameterToString(*r.connectorName, ""))
	}
	if r.name != nil {
		localVarFormParams.Add("Name", parameterToString(*r.name, ""))
	}
	if r.parameter1Name != nil {
		localVarFormParams.Add("Parameter1.Name", parameterToString(*r.parameter1Name, ""))
	}
	if r.parameter1Value != nil {
		localVarFormParams.Add("Parameter1.Value", parameterToString(*r.parameter1Value, ""))
	}
	if r.parameter10Name != nil {
		localVarFormParams.Add("Parameter10.Name", parameterToString(*r.parameter10Name, ""))
	}
	if r.parameter10Value != nil {
		localVarFormParams.Add("Parameter10.Value", parameterToString(*r.parameter10Value, ""))
	}
	if r.parameter11Name != nil {
		localVarFormParams.Add("Parameter11.Name", parameterToString(*r.parameter11Name, ""))
	}
	if r.parameter11Value != nil {
		localVarFormParams.Add("Parameter11.Value", parameterToString(*r.parameter11Value, ""))
	}
	if r.parameter12Name != nil {
		localVarFormParams.Add("Parameter12.Name", parameterToString(*r.parameter12Name, ""))
	}
	if r.parameter12Value != nil {
		localVarFormParams.Add("Parameter12.Value", parameterToString(*r.parameter12Value, ""))
	}
	if r.parameter13Name != nil {
		localVarFormParams.Add("Parameter13.Name", parameterToString(*r.parameter13Name, ""))
	}
	if r.parameter13Value != nil {
		localVarFormParams.Add("Parameter13.Value", parameterToString(*r.parameter13Value, ""))
	}
	if r.parameter14Name != nil {
		localVarFormParams.Add("Parameter14.Name", parameterToString(*r.parameter14Name, ""))
	}
	if r.parameter14Value != nil {
		localVarFormParams.Add("Parameter14.Value", parameterToString(*r.parameter14Value, ""))
	}
	if r.parameter15Name != nil {
		localVarFormParams.Add("Parameter15.Name", parameterToString(*r.parameter15Name, ""))
	}
	if r.parameter15Value != nil {
		localVarFormParams.Add("Parameter15.Value", parameterToString(*r.parameter15Value, ""))
	}
	if r.parameter16Name != nil {
		localVarFormParams.Add("Parameter16.Name", parameterToString(*r.parameter16Name, ""))
	}
	if r.parameter16Value != nil {
		localVarFormParams.Add("Parameter16.Value", parameterToString(*r.parameter16Value, ""))
	}
	if r.parameter17Name != nil {
		localVarFormParams.Add("Parameter17.Name", parameterToString(*r.parameter17Name, ""))
	}
	if r.parameter17Value != nil {
		localVarFormParams.Add("Parameter17.Value", parameterToString(*r.parameter17Value, ""))
	}
	if r.parameter18Name != nil {
		localVarFormParams.Add("Parameter18.Name", parameterToString(*r.parameter18Name, ""))
	}
	if r.parameter18Value != nil {
		localVarFormParams.Add("Parameter18.Value", parameterToString(*r.parameter18Value, ""))
	}
	if r.parameter19Name != nil {
		localVarFormParams.Add("Parameter19.Name", parameterToString(*r.parameter19Name, ""))
	}
	if r.parameter19Value != nil {
		localVarFormParams.Add("Parameter19.Value", parameterToString(*r.parameter19Value, ""))
	}
	if r.parameter2Name != nil {
		localVarFormParams.Add("Parameter2.Name", parameterToString(*r.parameter2Name, ""))
	}
	if r.parameter2Value != nil {
		localVarFormParams.Add("Parameter2.Value", parameterToString(*r.parameter2Value, ""))
	}
	if r.parameter20Name != nil {
		localVarFormParams.Add("Parameter20.Name", parameterToString(*r.parameter20Name, ""))
	}
	if r.parameter20Value != nil {
		localVarFormParams.Add("Parameter20.Value", parameterToString(*r.parameter20Value, ""))
	}
	if r.parameter21Name != nil {
		localVarFormParams.Add("Parameter21.Name", parameterToString(*r.parameter21Name, ""))
	}
	if r.parameter21Value != nil {
		localVarFormParams.Add("Parameter21.Value", parameterToString(*r.parameter21Value, ""))
	}
	if r.parameter22Name != nil {
		localVarFormParams.Add("Parameter22.Name", parameterToString(*r.parameter22Name, ""))
	}
	if r.parameter22Value != nil {
		localVarFormParams.Add("Parameter22.Value", parameterToString(*r.parameter22Value, ""))
	}
	if r.parameter23Name != nil {
		localVarFormParams.Add("Parameter23.Name", parameterToString(*r.parameter23Name, ""))
	}
	if r.parameter23Value != nil {
		localVarFormParams.Add("Parameter23.Value", parameterToString(*r.parameter23Value, ""))
	}
	if r.parameter24Name != nil {
		localVarFormParams.Add("Parameter24.Name", parameterToString(*r.parameter24Name, ""))
	}
	if r.parameter24Value != nil {
		localVarFormParams.Add("Parameter24.Value", parameterToString(*r.parameter24Value, ""))
	}
	if r.parameter25Name != nil {
		localVarFormParams.Add("Parameter25.Name", parameterToString(*r.parameter25Name, ""))
	}
	if r.parameter25Value != nil {
		localVarFormParams.Add("Parameter25.Value", parameterToString(*r.parameter25Value, ""))
	}
	if r.parameter26Name != nil {
		localVarFormParams.Add("Parameter26.Name", parameterToString(*r.parameter26Name, ""))
	}
	if r.parameter26Value != nil {
		localVarFormParams.Add("Parameter26.Value", parameterToString(*r.parameter26Value, ""))
	}
	if r.parameter27Name != nil {
		localVarFormParams.Add("Parameter27.Name", parameterToString(*r.parameter27Name, ""))
	}
	if r.parameter27Value != nil {
		localVarFormParams.Add("Parameter27.Value", parameterToString(*r.parameter27Value, ""))
	}
	if r.parameter28Name != nil {
		localVarFormParams.Add("Parameter28.Name", parameterToString(*r.parameter28Name, ""))
	}
	if r.parameter28Value != nil {
		localVarFormParams.Add("Parameter28.Value", parameterToString(*r.parameter28Value, ""))
	}
	if r.parameter29Name != nil {
		localVarFormParams.Add("Parameter29.Name", parameterToString(*r.parameter29Name, ""))
	}
	if r.parameter29Value != nil {
		localVarFormParams.Add("Parameter29.Value", parameterToString(*r.parameter29Value, ""))
	}
	if r.parameter3Name != nil {
		localVarFormParams.Add("Parameter3.Name", parameterToString(*r.parameter3Name, ""))
	}
	if r.parameter3Value != nil {
		localVarFormParams.Add("Parameter3.Value", parameterToString(*r.parameter3Value, ""))
	}
	if r.parameter30Name != nil {
		localVarFormParams.Add("Parameter30.Name", parameterToString(*r.parameter30Name, ""))
	}
	if r.parameter30Value != nil {
		localVarFormParams.Add("Parameter30.Value", parameterToString(*r.parameter30Value, ""))
	}
	if r.parameter31Name != nil {
		localVarFormParams.Add("Parameter31.Name", parameterToString(*r.parameter31Name, ""))
	}
	if r.parameter31Value != nil {
		localVarFormParams.Add("Parameter31.Value", parameterToString(*r.parameter31Value, ""))
	}
	if r.parameter32Name != nil {
		localVarFormParams.Add("Parameter32.Name", parameterToString(*r.parameter32Name, ""))
	}
	if r.parameter32Value != nil {
		localVarFormParams.Add("Parameter32.Value", parameterToString(*r.parameter32Value, ""))
	}
	if r.parameter33Name != nil {
		localVarFormParams.Add("Parameter33.Name", parameterToString(*r.parameter33Name, ""))
	}
	if r.parameter33Value != nil {
		localVarFormParams.Add("Parameter33.Value", parameterToString(*r.parameter33Value, ""))
	}
	if r.parameter34Name != nil {
		localVarFormParams.Add("Parameter34.Name", parameterToString(*r.parameter34Name, ""))
	}
	if r.parameter34Value != nil {
		localVarFormParams.Add("Parameter34.Value", parameterToString(*r.parameter34Value, ""))
	}
	if r.parameter35Name != nil {
		localVarFormParams.Add("Parameter35.Name", parameterToString(*r.parameter35Name, ""))
	}
	if r.parameter35Value != nil {
		localVarFormParams.Add("Parameter35.Value", parameterToString(*r.parameter35Value, ""))
	}
	if r.parameter36Name != nil {
		localVarFormParams.Add("Parameter36.Name", parameterToString(*r.parameter36Name, ""))
	}
	if r.parameter36Value != nil {
		localVarFormParams.Add("Parameter36.Value", parameterToString(*r.parameter36Value, ""))
	}
	if r.parameter37Name != nil {
		localVarFormParams.Add("Parameter37.Name", parameterToString(*r.parameter37Name, ""))
	}
	if r.parameter37Value != nil {
		localVarFormParams.Add("Parameter37.Value", parameterToString(*r.parameter37Value, ""))
	}
	if r.parameter38Name != nil {
		localVarFormParams.Add("Parameter38.Name", parameterToString(*r.parameter38Name, ""))
	}
	if r.parameter38Value != nil {
		localVarFormParams.Add("Parameter38.Value", parameterToString(*r.parameter38Value, ""))
	}
	if r.parameter39Name != nil {
		localVarFormParams.Add("Parameter39.Name", parameterToString(*r.parameter39Name, ""))
	}
	if r.parameter39Value != nil {
		localVarFormParams.Add("Parameter39.Value", parameterToString(*r.parameter39Value, ""))
	}
	if r.parameter4Name != nil {
		localVarFormParams.Add("Parameter4.Name", parameterToString(*r.parameter4Name, ""))
	}
	if r.parameter4Value != nil {
		localVarFormParams.Add("Parameter4.Value", parameterToString(*r.parameter4Value, ""))
	}
	if r.parameter40Name != nil {
		localVarFormParams.Add("Parameter40.Name", parameterToString(*r.parameter40Name, ""))
	}
	if r.parameter40Value != nil {
		localVarFormParams.Add("Parameter40.Value", parameterToString(*r.parameter40Value, ""))
	}
	if r.parameter41Name != nil {
		localVarFormParams.Add("Parameter41.Name", parameterToString(*r.parameter41Name, ""))
	}
	if r.parameter41Value != nil {
		localVarFormParams.Add("Parameter41.Value", parameterToString(*r.parameter41Value, ""))
	}
	if r.parameter42Name != nil {
		localVarFormParams.Add("Parameter42.Name", parameterToString(*r.parameter42Name, ""))
	}
	if r.parameter42Value != nil {
		localVarFormParams.Add("Parameter42.Value", parameterToString(*r.parameter42Value, ""))
	}
	if r.parameter43Name != nil {
		localVarFormParams.Add("Parameter43.Name", parameterToString(*r.parameter43Name, ""))
	}
	if r.parameter43Value != nil {
		localVarFormParams.Add("Parameter43.Value", parameterToString(*r.parameter43Value, ""))
	}
	if r.parameter44Name != nil {
		localVarFormParams.Add("Parameter44.Name", parameterToString(*r.parameter44Name, ""))
	}
	if r.parameter44Value != nil {
		localVarFormParams.Add("Parameter44.Value", parameterToString(*r.parameter44Value, ""))
	}
	if r.parameter45Name != nil {
		localVarFormParams.Add("Parameter45.Name", parameterToString(*r.parameter45Name, ""))
	}
	if r.parameter45Value != nil {
		localVarFormParams.Add("Parameter45.Value", parameterToString(*r.parameter45Value, ""))
	}
	if r.parameter46Name != nil {
		localVarFormParams.Add("Parameter46.Name", parameterToString(*r.parameter46Name, ""))
	}
	if r.parameter46Value != nil {
		localVarFormParams.Add("Parameter46.Value", parameterToString(*r.parameter46Value, ""))
	}
	if r.parameter47Name != nil {
		localVarFormParams.Add("Parameter47.Name", parameterToString(*r.parameter47Name, ""))
	}
	if r.parameter47Value != nil {
		localVarFormParams.Add("Parameter47.Value", parameterToString(*r.parameter47Value, ""))
	}
	if r.parameter48Name != nil {
		localVarFormParams.Add("Parameter48.Name", parameterToString(*r.parameter48Name, ""))
	}
	if r.parameter48Value != nil {
		localVarFormParams.Add("Parameter48.Value", parameterToString(*r.parameter48Value, ""))
	}
	if r.parameter49Name != nil {
		localVarFormParams.Add("Parameter49.Name", parameterToString(*r.parameter49Name, ""))
	}
	if r.parameter49Value != nil {
		localVarFormParams.Add("Parameter49.Value", parameterToString(*r.parameter49Value, ""))
	}
	if r.parameter5Name != nil {
		localVarFormParams.Add("Parameter5.Name", parameterToString(*r.parameter5Name, ""))
	}
	if r.parameter5Value != nil {
		localVarFormParams.Add("Parameter5.Value", parameterToString(*r.parameter5Value, ""))
	}
	if r.parameter50Name != nil {
		localVarFormParams.Add("Parameter50.Name", parameterToString(*r.parameter50Name, ""))
	}
	if r.parameter50Value != nil {
		localVarFormParams.Add("Parameter50.Value", parameterToString(*r.parameter50Value, ""))
	}
	if r.parameter51Name != nil {
		localVarFormParams.Add("Parameter51.Name", parameterToString(*r.parameter51Name, ""))
	}
	if r.parameter51Value != nil {
		localVarFormParams.Add("Parameter51.Value", parameterToString(*r.parameter51Value, ""))
	}
	if r.parameter52Name != nil {
		localVarFormParams.Add("Parameter52.Name", parameterToString(*r.parameter52Name, ""))
	}
	if r.parameter52Value != nil {
		localVarFormParams.Add("Parameter52.Value", parameterToString(*r.parameter52Value, ""))
	}
	if r.parameter53Name != nil {
		localVarFormParams.Add("Parameter53.Name", parameterToString(*r.parameter53Name, ""))
	}
	if r.parameter53Value != nil {
		localVarFormParams.Add("Parameter53.Value", parameterToString(*r.parameter53Value, ""))
	}
	if r.parameter54Name != nil {
		localVarFormParams.Add("Parameter54.Name", parameterToString(*r.parameter54Name, ""))
	}
	if r.parameter54Value != nil {
		localVarFormParams.Add("Parameter54.Value", parameterToString(*r.parameter54Value, ""))
	}
	if r.parameter55Name != nil {
		localVarFormParams.Add("Parameter55.Name", parameterToString(*r.parameter55Name, ""))
	}
	if r.parameter55Value != nil {
		localVarFormParams.Add("Parameter55.Value", parameterToString(*r.parameter55Value, ""))
	}
	if r.parameter56Name != nil {
		localVarFormParams.Add("Parameter56.Name", parameterToString(*r.parameter56Name, ""))
	}
	if r.parameter56Value != nil {
		localVarFormParams.Add("Parameter56.Value", parameterToString(*r.parameter56Value, ""))
	}
	if r.parameter57Name != nil {
		localVarFormParams.Add("Parameter57.Name", parameterToString(*r.parameter57Name, ""))
	}
	if r.parameter57Value != nil {
		localVarFormParams.Add("Parameter57.Value", parameterToString(*r.parameter57Value, ""))
	}
	if r.parameter58Name != nil {
		localVarFormParams.Add("Parameter58.Name", parameterToString(*r.parameter58Name, ""))
	}
	if r.parameter58Value != nil {
		localVarFormParams.Add("Parameter58.Value", parameterToString(*r.parameter58Value, ""))
	}
	if r.parameter59Name != nil {
		localVarFormParams.Add("Parameter59.Name", parameterToString(*r.parameter59Name, ""))
	}
	if r.parameter59Value != nil {
		localVarFormParams.Add("Parameter59.Value", parameterToString(*r.parameter59Value, ""))
	}
	if r.parameter6Name != nil {
		localVarFormParams.Add("Parameter6.Name", parameterToString(*r.parameter6Name, ""))
	}
	if r.parameter6Value != nil {
		localVarFormParams.Add("Parameter6.Value", parameterToString(*r.parameter6Value, ""))
	}
	if r.parameter60Name != nil {
		localVarFormParams.Add("Parameter60.Name", parameterToString(*r.parameter60Name, ""))
	}
	if r.parameter60Value != nil {
		localVarFormParams.Add("Parameter60.Value", parameterToString(*r.parameter60Value, ""))
	}
	if r.parameter61Name != nil {
		localVarFormParams.Add("Parameter61.Name", parameterToString(*r.parameter61Name, ""))
	}
	if r.parameter61Value != nil {
		localVarFormParams.Add("Parameter61.Value", parameterToString(*r.parameter61Value, ""))
	}
	if r.parameter62Name != nil {
		localVarFormParams.Add("Parameter62.Name", parameterToString(*r.parameter62Name, ""))
	}
	if r.parameter62Value != nil {
		localVarFormParams.Add("Parameter62.Value", parameterToString(*r.parameter62Value, ""))
	}
	if r.parameter63Name != nil {
		localVarFormParams.Add("Parameter63.Name", parameterToString(*r.parameter63Name, ""))
	}
	if r.parameter63Value != nil {
		localVarFormParams.Add("Parameter63.Value", parameterToString(*r.parameter63Value, ""))
	}
	if r.parameter64Name != nil {
		localVarFormParams.Add("Parameter64.Name", parameterToString(*r.parameter64Name, ""))
	}
	if r.parameter64Value != nil {
		localVarFormParams.Add("Parameter64.Value", parameterToString(*r.parameter64Value, ""))
	}
	if r.parameter65Name != nil {
		localVarFormParams.Add("Parameter65.Name", parameterToString(*r.parameter65Name, ""))
	}
	if r.parameter65Value != nil {
		localVarFormParams.Add("Parameter65.Value", parameterToString(*r.parameter65Value, ""))
	}
	if r.parameter66Name != nil {
		localVarFormParams.Add("Parameter66.Name", parameterToString(*r.parameter66Name, ""))
	}
	if r.parameter66Value != nil {
		localVarFormParams.Add("Parameter66.Value", parameterToString(*r.parameter66Value, ""))
	}
	if r.parameter67Name != nil {
		localVarFormParams.Add("Parameter67.Name", parameterToString(*r.parameter67Name, ""))
	}
	if r.parameter67Value != nil {
		localVarFormParams.Add("Parameter67.Value", parameterToString(*r.parameter67Value, ""))
	}
	if r.parameter68Name != nil {
		localVarFormParams.Add("Parameter68.Name", parameterToString(*r.parameter68Name, ""))
	}
	if r.parameter68Value != nil {
		localVarFormParams.Add("Parameter68.Value", parameterToString(*r.parameter68Value, ""))
	}
	if r.parameter69Name != nil {
		localVarFormParams.Add("Parameter69.Name", parameterToString(*r.parameter69Name, ""))
	}
	if r.parameter69Value != nil {
		localVarFormParams.Add("Parameter69.Value", parameterToString(*r.parameter69Value, ""))
	}
	if r.parameter7Name != nil {
		localVarFormParams.Add("Parameter7.Name", parameterToString(*r.parameter7Name, ""))
	}
	if r.parameter7Value != nil {
		localVarFormParams.Add("Parameter7.Value", parameterToString(*r.parameter7Value, ""))
	}
	if r.parameter70Name != nil {
		localVarFormParams.Add("Parameter70.Name", parameterToString(*r.parameter70Name, ""))
	}
	if r.parameter70Value != nil {
		localVarFormParams.Add("Parameter70.Value", parameterToString(*r.parameter70Value, ""))
	}
	if r.parameter71Name != nil {
		localVarFormParams.Add("Parameter71.Name", parameterToString(*r.parameter71Name, ""))
	}
	if r.parameter71Value != nil {
		localVarFormParams.Add("Parameter71.Value", parameterToString(*r.parameter71Value, ""))
	}
	if r.parameter72Name != nil {
		localVarFormParams.Add("Parameter72.Name", parameterToString(*r.parameter72Name, ""))
	}
	if r.parameter72Value != nil {
		localVarFormParams.Add("Parameter72.Value", parameterToString(*r.parameter72Value, ""))
	}
	if r.parameter73Name != nil {
		localVarFormParams.Add("Parameter73.Name", parameterToString(*r.parameter73Name, ""))
	}
	if r.parameter73Value != nil {
		localVarFormParams.Add("Parameter73.Value", parameterToString(*r.parameter73Value, ""))
	}
	if r.parameter74Name != nil {
		localVarFormParams.Add("Parameter74.Name", parameterToString(*r.parameter74Name, ""))
	}
	if r.parameter74Value != nil {
		localVarFormParams.Add("Parameter74.Value", parameterToString(*r.parameter74Value, ""))
	}
	if r.parameter75Name != nil {
		localVarFormParams.Add("Parameter75.Name", parameterToString(*r.parameter75Name, ""))
	}
	if r.parameter75Value != nil {
		localVarFormParams.Add("Parameter75.Value", parameterToString(*r.parameter75Value, ""))
	}
	if r.parameter76Name != nil {
		localVarFormParams.Add("Parameter76.Name", parameterToString(*r.parameter76Name, ""))
	}
	if r.parameter76Value != nil {
		localVarFormParams.Add("Parameter76.Value", parameterToString(*r.parameter76Value, ""))
	}
	if r.parameter77Name != nil {
		localVarFormParams.Add("Parameter77.Name", parameterToString(*r.parameter77Name, ""))
	}
	if r.parameter77Value != nil {
		localVarFormParams.Add("Parameter77.Value", parameterToString(*r.parameter77Value, ""))
	}
	if r.parameter78Name != nil {
		localVarFormParams.Add("Parameter78.Name", parameterToString(*r.parameter78Name, ""))
	}
	if r.parameter78Value != nil {
		localVarFormParams.Add("Parameter78.Value", parameterToString(*r.parameter78Value, ""))
	}
	if r.parameter79Name != nil {
		localVarFormParams.Add("Parameter79.Name", parameterToString(*r.parameter79Name, ""))
	}
	if r.parameter79Value != nil {
		localVarFormParams.Add("Parameter79.Value", parameterToString(*r.parameter79Value, ""))
	}
	if r.parameter8Name != nil {
		localVarFormParams.Add("Parameter8.Name", parameterToString(*r.parameter8Name, ""))
	}
	if r.parameter8Value != nil {
		localVarFormParams.Add("Parameter8.Value", parameterToString(*r.parameter8Value, ""))
	}
	if r.parameter80Name != nil {
		localVarFormParams.Add("Parameter80.Name", parameterToString(*r.parameter80Name, ""))
	}
	if r.parameter80Value != nil {
		localVarFormParams.Add("Parameter80.Value", parameterToString(*r.parameter80Value, ""))
	}
	if r.parameter81Name != nil {
		localVarFormParams.Add("Parameter81.Name", parameterToString(*r.parameter81Name, ""))
	}
	if r.parameter81Value != nil {
		localVarFormParams.Add("Parameter81.Value", parameterToString(*r.parameter81Value, ""))
	}
	if r.parameter82Name != nil {
		localVarFormParams.Add("Parameter82.Name", parameterToString(*r.parameter82Name, ""))
	}
	if r.parameter82Value != nil {
		localVarFormParams.Add("Parameter82.Value", parameterToString(*r.parameter82Value, ""))
	}
	if r.parameter83Name != nil {
		localVarFormParams.Add("Parameter83.Name", parameterToString(*r.parameter83Name, ""))
	}
	if r.parameter83Value != nil {
		localVarFormParams.Add("Parameter83.Value", parameterToString(*r.parameter83Value, ""))
	}
	if r.parameter84Name != nil {
		localVarFormParams.Add("Parameter84.Name", parameterToString(*r.parameter84Name, ""))
	}
	if r.parameter84Value != nil {
		localVarFormParams.Add("Parameter84.Value", parameterToString(*r.parameter84Value, ""))
	}
	if r.parameter85Name != nil {
		localVarFormParams.Add("Parameter85.Name", parameterToString(*r.parameter85Name, ""))
	}
	if r.parameter85Value != nil {
		localVarFormParams.Add("Parameter85.Value", parameterToString(*r.parameter85Value, ""))
	}
	if r.parameter86Name != nil {
		localVarFormParams.Add("Parameter86.Name", parameterToString(*r.parameter86Name, ""))
	}
	if r.parameter86Value != nil {
		localVarFormParams.Add("Parameter86.Value", parameterToString(*r.parameter86Value, ""))
	}
	if r.parameter87Name != nil {
		localVarFormParams.Add("Parameter87.Name", parameterToString(*r.parameter87Name, ""))
	}
	if r.parameter87Value != nil {
		localVarFormParams.Add("Parameter87.Value", parameterToString(*r.parameter87Value, ""))
	}
	if r.parameter88Name != nil {
		localVarFormParams.Add("Parameter88.Name", parameterToString(*r.parameter88Name, ""))
	}
	if r.parameter88Value != nil {
		localVarFormParams.Add("Parameter88.Value", parameterToString(*r.parameter88Value, ""))
	}
	if r.parameter89Name != nil {
		localVarFormParams.Add("Parameter89.Name", parameterToString(*r.parameter89Name, ""))
	}
	if r.parameter89Value != nil {
		localVarFormParams.Add("Parameter89.Value", parameterToString(*r.parameter89Value, ""))
	}
	if r.parameter9Name != nil {
		localVarFormParams.Add("Parameter9.Name", parameterToString(*r.parameter9Name, ""))
	}
	if r.parameter9Value != nil {
		localVarFormParams.Add("Parameter9.Value", parameterToString(*r.parameter9Value, ""))
	}
	if r.parameter90Name != nil {
		localVarFormParams.Add("Parameter90.Name", parameterToString(*r.parameter90Name, ""))
	}
	if r.parameter90Value != nil {
		localVarFormParams.Add("Parameter90.Value", parameterToString(*r.parameter90Value, ""))
	}
	if r.parameter91Name != nil {
		localVarFormParams.Add("Parameter91.Name", parameterToString(*r.parameter91Name, ""))
	}
	if r.parameter91Value != nil {
		localVarFormParams.Add("Parameter91.Value", parameterToString(*r.parameter91Value, ""))
	}
	if r.parameter92Name != nil {
		localVarFormParams.Add("Parameter92.Name", parameterToString(*r.parameter92Name, ""))
	}
	if r.parameter92Value != nil {
		localVarFormParams.Add("Parameter92.Value", parameterToString(*r.parameter92Value, ""))
	}
	if r.parameter93Name != nil {
		localVarFormParams.Add("Parameter93.Name", parameterToString(*r.parameter93Name, ""))
	}
	if r.parameter93Value != nil {
		localVarFormParams.Add("Parameter93.Value", parameterToString(*r.parameter93Value, ""))
	}
	if r.parameter94Name != nil {
		localVarFormParams.Add("Parameter94.Name", parameterToString(*r.parameter94Name, ""))
	}
	if r.parameter94Value != nil {
		localVarFormParams.Add("Parameter94.Value", parameterToString(*r.parameter94Value, ""))
	}
	if r.parameter95Name != nil {
		localVarFormParams.Add("Parameter95.Name", parameterToString(*r.parameter95Name, ""))
	}
	if r.parameter95Value != nil {
		localVarFormParams.Add("Parameter95.Value", parameterToString(*r.parameter95Value, ""))
	}
	if r.parameter96Name != nil {
		localVarFormParams.Add("Parameter96.Name", parameterToString(*r.parameter96Name, ""))
	}
	if r.parameter96Value != nil {
		localVarFormParams.Add("Parameter96.Value", parameterToString(*r.parameter96Value, ""))
	}
	if r.parameter97Name != nil {
		localVarFormParams.Add("Parameter97.Name", parameterToString(*r.parameter97Name, ""))
	}
	if r.parameter97Value != nil {
		localVarFormParams.Add("Parameter97.Value", parameterToString(*r.parameter97Value, ""))
	}
	if r.parameter98Name != nil {
		localVarFormParams.Add("Parameter98.Name", parameterToString(*r.parameter98Name, ""))
	}
	if r.parameter98Value != nil {
		localVarFormParams.Add("Parameter98.Value", parameterToString(*r.parameter98Value, ""))
	}
	if r.parameter99Name != nil {
		localVarFormParams.Add("Parameter99.Name", parameterToString(*r.parameter99Name, ""))
	}
	if r.parameter99Value != nil {
		localVarFormParams.Add("Parameter99.Value", parameterToString(*r.parameter99Value, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.track != nil {
		localVarFormParams.Add("Track", parameterToString(*r.track, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStreamRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	url *string
	name *string
	parameter1Name *string
	parameter1Value *string
	parameter10Name *string
	parameter10Value *string
	parameter11Name *string
	parameter11Value *string
	parameter12Name *string
	parameter12Value *string
	parameter13Name *string
	parameter13Value *string
	parameter14Name *string
	parameter14Value *string
	parameter15Name *string
	parameter15Value *string
	parameter16Name *string
	parameter16Value *string
	parameter17Name *string
	parameter17Value *string
	parameter18Name *string
	parameter18Value *string
	parameter19Name *string
	parameter19Value *string
	parameter2Name *string
	parameter2Value *string
	parameter20Name *string
	parameter20Value *string
	parameter21Name *string
	parameter21Value *string
	parameter22Name *string
	parameter22Value *string
	parameter23Name *string
	parameter23Value *string
	parameter24Name *string
	parameter24Value *string
	parameter25Name *string
	parameter25Value *string
	parameter26Name *string
	parameter26Value *string
	parameter27Name *string
	parameter27Value *string
	parameter28Name *string
	parameter28Value *string
	parameter29Name *string
	parameter29Value *string
	parameter3Name *string
	parameter3Value *string
	parameter30Name *string
	parameter30Value *string
	parameter31Name *string
	parameter31Value *string
	parameter32Name *string
	parameter32Value *string
	parameter33Name *string
	parameter33Value *string
	parameter34Name *string
	parameter34Value *string
	parameter35Name *string
	parameter35Value *string
	parameter36Name *string
	parameter36Value *string
	parameter37Name *string
	parameter37Value *string
	parameter38Name *string
	parameter38Value *string
	parameter39Name *string
	parameter39Value *string
	parameter4Name *string
	parameter4Value *string
	parameter40Name *string
	parameter40Value *string
	parameter41Name *string
	parameter41Value *string
	parameter42Name *string
	parameter42Value *string
	parameter43Name *string
	parameter43Value *string
	parameter44Name *string
	parameter44Value *string
	parameter45Name *string
	parameter45Value *string
	parameter46Name *string
	parameter46Value *string
	parameter47Name *string
	parameter47Value *string
	parameter48Name *string
	parameter48Value *string
	parameter49Name *string
	parameter49Value *string
	parameter5Name *string
	parameter5Value *string
	parameter50Name *string
	parameter50Value *string
	parameter51Name *string
	parameter51Value *string
	parameter52Name *string
	parameter52Value *string
	parameter53Name *string
	parameter53Value *string
	parameter54Name *string
	parameter54Value *string
	parameter55Name *string
	parameter55Value *string
	parameter56Name *string
	parameter56Value *string
	parameter57Name *string
	parameter57Value *string
	parameter58Name *string
	parameter58Value *string
	parameter59Name *string
	parameter59Value *string
	parameter6Name *string
	parameter6Value *string
	parameter60Name *string
	parameter60Value *string
	parameter61Name *string
	parameter61Value *string
	parameter62Name *string
	parameter62Value *string
	parameter63Name *string
	parameter63Value *string
	parameter64Name *string
	parameter64Value *string
	parameter65Name *string
	parameter65Value *string
	parameter66Name *string
	parameter66Value *string
	parameter67Name *string
	parameter67Value *string
	parameter68Name *string
	parameter68Value *string
	parameter69Name *string
	parameter69Value *string
	parameter7Name *string
	parameter7Value *string
	parameter70Name *string
	parameter70Value *string
	parameter71Name *string
	parameter71Value *string
	parameter72Name *string
	parameter72Value *string
	parameter73Name *string
	parameter73Value *string
	parameter74Name *string
	parameter74Value *string
	parameter75Name *string
	parameter75Value *string
	parameter76Name *string
	parameter76Value *string
	parameter77Name *string
	parameter77Value *string
	parameter78Name *string
	parameter78Value *string
	parameter79Name *string
	parameter79Value *string
	parameter8Name *string
	parameter8Value *string
	parameter80Name *string
	parameter80Value *string
	parameter81Name *string
	parameter81Value *string
	parameter82Name *string
	parameter82Value *string
	parameter83Name *string
	parameter83Value *string
	parameter84Name *string
	parameter84Value *string
	parameter85Name *string
	parameter85Value *string
	parameter86Name *string
	parameter86Value *string
	parameter87Name *string
	parameter87Value *string
	parameter88Name *string
	parameter88Value *string
	parameter89Name *string
	parameter89Value *string
	parameter9Name *string
	parameter9Value *string
	parameter90Name *string
	parameter90Value *string
	parameter91Name *string
	parameter91Value *string
	parameter92Name *string
	parameter92Value *string
	parameter93Name *string
	parameter93Value *string
	parameter94Name *string
	parameter94Value *string
	parameter95Name *string
	parameter95Value *string
	parameter96Name *string
	parameter96Value *string
	parameter97Name *string
	parameter97Value *string
	parameter98Name *string
	parameter98Value *string
	parameter99Name *string
	parameter99Value *string
	statusCallback *string
	statusCallbackMethod *string
	track *string
}

// Relative or absolute url where WebSocket connection will be established.
func (r ApiCreateStreamRequest) Url(url string) ApiCreateStreamRequest {
	r.url = &url
	return r
}

// The user-specified name of this Stream, if one was given when the Stream was created. This may be used to stop the Stream.
func (r ApiCreateStreamRequest) Name(name string) ApiCreateStreamRequest {
	r.name = &name
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter1Name(parameter1Name string) ApiCreateStreamRequest {
	r.parameter1Name = &parameter1Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter1Value(parameter1Value string) ApiCreateStreamRequest {
	r.parameter1Value = &parameter1Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter10Name(parameter10Name string) ApiCreateStreamRequest {
	r.parameter10Name = &parameter10Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter10Value(parameter10Value string) ApiCreateStreamRequest {
	r.parameter10Value = &parameter10Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter11Name(parameter11Name string) ApiCreateStreamRequest {
	r.parameter11Name = &parameter11Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter11Value(parameter11Value string) ApiCreateStreamRequest {
	r.parameter11Value = &parameter11Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter12Name(parameter12Name string) ApiCreateStreamRequest {
	r.parameter12Name = &parameter12Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter12Value(parameter12Value string) ApiCreateStreamRequest {
	r.parameter12Value = &parameter12Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter13Name(parameter13Name string) ApiCreateStreamRequest {
	r.parameter13Name = &parameter13Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter13Value(parameter13Value string) ApiCreateStreamRequest {
	r.parameter13Value = &parameter13Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter14Name(parameter14Name string) ApiCreateStreamRequest {
	r.parameter14Name = &parameter14Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter14Value(parameter14Value string) ApiCreateStreamRequest {
	r.parameter14Value = &parameter14Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter15Name(parameter15Name string) ApiCreateStreamRequest {
	r.parameter15Name = &parameter15Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter15Value(parameter15Value string) ApiCreateStreamRequest {
	r.parameter15Value = &parameter15Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter16Name(parameter16Name string) ApiCreateStreamRequest {
	r.parameter16Name = &parameter16Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter16Value(parameter16Value string) ApiCreateStreamRequest {
	r.parameter16Value = &parameter16Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter17Name(parameter17Name string) ApiCreateStreamRequest {
	r.parameter17Name = &parameter17Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter17Value(parameter17Value string) ApiCreateStreamRequest {
	r.parameter17Value = &parameter17Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter18Name(parameter18Name string) ApiCreateStreamRequest {
	r.parameter18Name = &parameter18Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter18Value(parameter18Value string) ApiCreateStreamRequest {
	r.parameter18Value = &parameter18Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter19Name(parameter19Name string) ApiCreateStreamRequest {
	r.parameter19Name = &parameter19Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter19Value(parameter19Value string) ApiCreateStreamRequest {
	r.parameter19Value = &parameter19Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter2Name(parameter2Name string) ApiCreateStreamRequest {
	r.parameter2Name = &parameter2Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter2Value(parameter2Value string) ApiCreateStreamRequest {
	r.parameter2Value = &parameter2Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter20Name(parameter20Name string) ApiCreateStreamRequest {
	r.parameter20Name = &parameter20Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter20Value(parameter20Value string) ApiCreateStreamRequest {
	r.parameter20Value = &parameter20Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter21Name(parameter21Name string) ApiCreateStreamRequest {
	r.parameter21Name = &parameter21Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter21Value(parameter21Value string) ApiCreateStreamRequest {
	r.parameter21Value = &parameter21Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter22Name(parameter22Name string) ApiCreateStreamRequest {
	r.parameter22Name = &parameter22Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter22Value(parameter22Value string) ApiCreateStreamRequest {
	r.parameter22Value = &parameter22Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter23Name(parameter23Name string) ApiCreateStreamRequest {
	r.parameter23Name = &parameter23Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter23Value(parameter23Value string) ApiCreateStreamRequest {
	r.parameter23Value = &parameter23Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter24Name(parameter24Name string) ApiCreateStreamRequest {
	r.parameter24Name = &parameter24Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter24Value(parameter24Value string) ApiCreateStreamRequest {
	r.parameter24Value = &parameter24Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter25Name(parameter25Name string) ApiCreateStreamRequest {
	r.parameter25Name = &parameter25Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter25Value(parameter25Value string) ApiCreateStreamRequest {
	r.parameter25Value = &parameter25Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter26Name(parameter26Name string) ApiCreateStreamRequest {
	r.parameter26Name = &parameter26Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter26Value(parameter26Value string) ApiCreateStreamRequest {
	r.parameter26Value = &parameter26Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter27Name(parameter27Name string) ApiCreateStreamRequest {
	r.parameter27Name = &parameter27Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter27Value(parameter27Value string) ApiCreateStreamRequest {
	r.parameter27Value = &parameter27Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter28Name(parameter28Name string) ApiCreateStreamRequest {
	r.parameter28Name = &parameter28Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter28Value(parameter28Value string) ApiCreateStreamRequest {
	r.parameter28Value = &parameter28Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter29Name(parameter29Name string) ApiCreateStreamRequest {
	r.parameter29Name = &parameter29Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter29Value(parameter29Value string) ApiCreateStreamRequest {
	r.parameter29Value = &parameter29Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter3Name(parameter3Name string) ApiCreateStreamRequest {
	r.parameter3Name = &parameter3Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter3Value(parameter3Value string) ApiCreateStreamRequest {
	r.parameter3Value = &parameter3Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter30Name(parameter30Name string) ApiCreateStreamRequest {
	r.parameter30Name = &parameter30Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter30Value(parameter30Value string) ApiCreateStreamRequest {
	r.parameter30Value = &parameter30Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter31Name(parameter31Name string) ApiCreateStreamRequest {
	r.parameter31Name = &parameter31Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter31Value(parameter31Value string) ApiCreateStreamRequest {
	r.parameter31Value = &parameter31Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter32Name(parameter32Name string) ApiCreateStreamRequest {
	r.parameter32Name = &parameter32Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter32Value(parameter32Value string) ApiCreateStreamRequest {
	r.parameter32Value = &parameter32Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter33Name(parameter33Name string) ApiCreateStreamRequest {
	r.parameter33Name = &parameter33Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter33Value(parameter33Value string) ApiCreateStreamRequest {
	r.parameter33Value = &parameter33Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter34Name(parameter34Name string) ApiCreateStreamRequest {
	r.parameter34Name = &parameter34Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter34Value(parameter34Value string) ApiCreateStreamRequest {
	r.parameter34Value = &parameter34Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter35Name(parameter35Name string) ApiCreateStreamRequest {
	r.parameter35Name = &parameter35Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter35Value(parameter35Value string) ApiCreateStreamRequest {
	r.parameter35Value = &parameter35Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter36Name(parameter36Name string) ApiCreateStreamRequest {
	r.parameter36Name = &parameter36Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter36Value(parameter36Value string) ApiCreateStreamRequest {
	r.parameter36Value = &parameter36Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter37Name(parameter37Name string) ApiCreateStreamRequest {
	r.parameter37Name = &parameter37Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter37Value(parameter37Value string) ApiCreateStreamRequest {
	r.parameter37Value = &parameter37Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter38Name(parameter38Name string) ApiCreateStreamRequest {
	r.parameter38Name = &parameter38Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter38Value(parameter38Value string) ApiCreateStreamRequest {
	r.parameter38Value = &parameter38Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter39Name(parameter39Name string) ApiCreateStreamRequest {
	r.parameter39Name = &parameter39Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter39Value(parameter39Value string) ApiCreateStreamRequest {
	r.parameter39Value = &parameter39Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter4Name(parameter4Name string) ApiCreateStreamRequest {
	r.parameter4Name = &parameter4Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter4Value(parameter4Value string) ApiCreateStreamRequest {
	r.parameter4Value = &parameter4Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter40Name(parameter40Name string) ApiCreateStreamRequest {
	r.parameter40Name = &parameter40Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter40Value(parameter40Value string) ApiCreateStreamRequest {
	r.parameter40Value = &parameter40Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter41Name(parameter41Name string) ApiCreateStreamRequest {
	r.parameter41Name = &parameter41Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter41Value(parameter41Value string) ApiCreateStreamRequest {
	r.parameter41Value = &parameter41Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter42Name(parameter42Name string) ApiCreateStreamRequest {
	r.parameter42Name = &parameter42Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter42Value(parameter42Value string) ApiCreateStreamRequest {
	r.parameter42Value = &parameter42Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter43Name(parameter43Name string) ApiCreateStreamRequest {
	r.parameter43Name = &parameter43Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter43Value(parameter43Value string) ApiCreateStreamRequest {
	r.parameter43Value = &parameter43Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter44Name(parameter44Name string) ApiCreateStreamRequest {
	r.parameter44Name = &parameter44Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter44Value(parameter44Value string) ApiCreateStreamRequest {
	r.parameter44Value = &parameter44Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter45Name(parameter45Name string) ApiCreateStreamRequest {
	r.parameter45Name = &parameter45Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter45Value(parameter45Value string) ApiCreateStreamRequest {
	r.parameter45Value = &parameter45Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter46Name(parameter46Name string) ApiCreateStreamRequest {
	r.parameter46Name = &parameter46Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter46Value(parameter46Value string) ApiCreateStreamRequest {
	r.parameter46Value = &parameter46Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter47Name(parameter47Name string) ApiCreateStreamRequest {
	r.parameter47Name = &parameter47Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter47Value(parameter47Value string) ApiCreateStreamRequest {
	r.parameter47Value = &parameter47Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter48Name(parameter48Name string) ApiCreateStreamRequest {
	r.parameter48Name = &parameter48Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter48Value(parameter48Value string) ApiCreateStreamRequest {
	r.parameter48Value = &parameter48Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter49Name(parameter49Name string) ApiCreateStreamRequest {
	r.parameter49Name = &parameter49Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter49Value(parameter49Value string) ApiCreateStreamRequest {
	r.parameter49Value = &parameter49Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter5Name(parameter5Name string) ApiCreateStreamRequest {
	r.parameter5Name = &parameter5Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter5Value(parameter5Value string) ApiCreateStreamRequest {
	r.parameter5Value = &parameter5Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter50Name(parameter50Name string) ApiCreateStreamRequest {
	r.parameter50Name = &parameter50Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter50Value(parameter50Value string) ApiCreateStreamRequest {
	r.parameter50Value = &parameter50Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter51Name(parameter51Name string) ApiCreateStreamRequest {
	r.parameter51Name = &parameter51Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter51Value(parameter51Value string) ApiCreateStreamRequest {
	r.parameter51Value = &parameter51Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter52Name(parameter52Name string) ApiCreateStreamRequest {
	r.parameter52Name = &parameter52Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter52Value(parameter52Value string) ApiCreateStreamRequest {
	r.parameter52Value = &parameter52Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter53Name(parameter53Name string) ApiCreateStreamRequest {
	r.parameter53Name = &parameter53Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter53Value(parameter53Value string) ApiCreateStreamRequest {
	r.parameter53Value = &parameter53Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter54Name(parameter54Name string) ApiCreateStreamRequest {
	r.parameter54Name = &parameter54Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter54Value(parameter54Value string) ApiCreateStreamRequest {
	r.parameter54Value = &parameter54Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter55Name(parameter55Name string) ApiCreateStreamRequest {
	r.parameter55Name = &parameter55Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter55Value(parameter55Value string) ApiCreateStreamRequest {
	r.parameter55Value = &parameter55Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter56Name(parameter56Name string) ApiCreateStreamRequest {
	r.parameter56Name = &parameter56Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter56Value(parameter56Value string) ApiCreateStreamRequest {
	r.parameter56Value = &parameter56Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter57Name(parameter57Name string) ApiCreateStreamRequest {
	r.parameter57Name = &parameter57Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter57Value(parameter57Value string) ApiCreateStreamRequest {
	r.parameter57Value = &parameter57Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter58Name(parameter58Name string) ApiCreateStreamRequest {
	r.parameter58Name = &parameter58Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter58Value(parameter58Value string) ApiCreateStreamRequest {
	r.parameter58Value = &parameter58Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter59Name(parameter59Name string) ApiCreateStreamRequest {
	r.parameter59Name = &parameter59Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter59Value(parameter59Value string) ApiCreateStreamRequest {
	r.parameter59Value = &parameter59Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter6Name(parameter6Name string) ApiCreateStreamRequest {
	r.parameter6Name = &parameter6Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter6Value(parameter6Value string) ApiCreateStreamRequest {
	r.parameter6Value = &parameter6Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter60Name(parameter60Name string) ApiCreateStreamRequest {
	r.parameter60Name = &parameter60Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter60Value(parameter60Value string) ApiCreateStreamRequest {
	r.parameter60Value = &parameter60Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter61Name(parameter61Name string) ApiCreateStreamRequest {
	r.parameter61Name = &parameter61Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter61Value(parameter61Value string) ApiCreateStreamRequest {
	r.parameter61Value = &parameter61Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter62Name(parameter62Name string) ApiCreateStreamRequest {
	r.parameter62Name = &parameter62Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter62Value(parameter62Value string) ApiCreateStreamRequest {
	r.parameter62Value = &parameter62Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter63Name(parameter63Name string) ApiCreateStreamRequest {
	r.parameter63Name = &parameter63Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter63Value(parameter63Value string) ApiCreateStreamRequest {
	r.parameter63Value = &parameter63Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter64Name(parameter64Name string) ApiCreateStreamRequest {
	r.parameter64Name = &parameter64Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter64Value(parameter64Value string) ApiCreateStreamRequest {
	r.parameter64Value = &parameter64Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter65Name(parameter65Name string) ApiCreateStreamRequest {
	r.parameter65Name = &parameter65Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter65Value(parameter65Value string) ApiCreateStreamRequest {
	r.parameter65Value = &parameter65Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter66Name(parameter66Name string) ApiCreateStreamRequest {
	r.parameter66Name = &parameter66Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter66Value(parameter66Value string) ApiCreateStreamRequest {
	r.parameter66Value = &parameter66Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter67Name(parameter67Name string) ApiCreateStreamRequest {
	r.parameter67Name = &parameter67Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter67Value(parameter67Value string) ApiCreateStreamRequest {
	r.parameter67Value = &parameter67Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter68Name(parameter68Name string) ApiCreateStreamRequest {
	r.parameter68Name = &parameter68Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter68Value(parameter68Value string) ApiCreateStreamRequest {
	r.parameter68Value = &parameter68Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter69Name(parameter69Name string) ApiCreateStreamRequest {
	r.parameter69Name = &parameter69Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter69Value(parameter69Value string) ApiCreateStreamRequest {
	r.parameter69Value = &parameter69Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter7Name(parameter7Name string) ApiCreateStreamRequest {
	r.parameter7Name = &parameter7Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter7Value(parameter7Value string) ApiCreateStreamRequest {
	r.parameter7Value = &parameter7Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter70Name(parameter70Name string) ApiCreateStreamRequest {
	r.parameter70Name = &parameter70Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter70Value(parameter70Value string) ApiCreateStreamRequest {
	r.parameter70Value = &parameter70Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter71Name(parameter71Name string) ApiCreateStreamRequest {
	r.parameter71Name = &parameter71Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter71Value(parameter71Value string) ApiCreateStreamRequest {
	r.parameter71Value = &parameter71Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter72Name(parameter72Name string) ApiCreateStreamRequest {
	r.parameter72Name = &parameter72Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter72Value(parameter72Value string) ApiCreateStreamRequest {
	r.parameter72Value = &parameter72Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter73Name(parameter73Name string) ApiCreateStreamRequest {
	r.parameter73Name = &parameter73Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter73Value(parameter73Value string) ApiCreateStreamRequest {
	r.parameter73Value = &parameter73Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter74Name(parameter74Name string) ApiCreateStreamRequest {
	r.parameter74Name = &parameter74Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter74Value(parameter74Value string) ApiCreateStreamRequest {
	r.parameter74Value = &parameter74Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter75Name(parameter75Name string) ApiCreateStreamRequest {
	r.parameter75Name = &parameter75Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter75Value(parameter75Value string) ApiCreateStreamRequest {
	r.parameter75Value = &parameter75Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter76Name(parameter76Name string) ApiCreateStreamRequest {
	r.parameter76Name = &parameter76Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter76Value(parameter76Value string) ApiCreateStreamRequest {
	r.parameter76Value = &parameter76Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter77Name(parameter77Name string) ApiCreateStreamRequest {
	r.parameter77Name = &parameter77Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter77Value(parameter77Value string) ApiCreateStreamRequest {
	r.parameter77Value = &parameter77Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter78Name(parameter78Name string) ApiCreateStreamRequest {
	r.parameter78Name = &parameter78Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter78Value(parameter78Value string) ApiCreateStreamRequest {
	r.parameter78Value = &parameter78Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter79Name(parameter79Name string) ApiCreateStreamRequest {
	r.parameter79Name = &parameter79Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter79Value(parameter79Value string) ApiCreateStreamRequest {
	r.parameter79Value = &parameter79Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter8Name(parameter8Name string) ApiCreateStreamRequest {
	r.parameter8Name = &parameter8Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter8Value(parameter8Value string) ApiCreateStreamRequest {
	r.parameter8Value = &parameter8Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter80Name(parameter80Name string) ApiCreateStreamRequest {
	r.parameter80Name = &parameter80Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter80Value(parameter80Value string) ApiCreateStreamRequest {
	r.parameter80Value = &parameter80Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter81Name(parameter81Name string) ApiCreateStreamRequest {
	r.parameter81Name = &parameter81Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter81Value(parameter81Value string) ApiCreateStreamRequest {
	r.parameter81Value = &parameter81Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter82Name(parameter82Name string) ApiCreateStreamRequest {
	r.parameter82Name = &parameter82Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter82Value(parameter82Value string) ApiCreateStreamRequest {
	r.parameter82Value = &parameter82Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter83Name(parameter83Name string) ApiCreateStreamRequest {
	r.parameter83Name = &parameter83Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter83Value(parameter83Value string) ApiCreateStreamRequest {
	r.parameter83Value = &parameter83Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter84Name(parameter84Name string) ApiCreateStreamRequest {
	r.parameter84Name = &parameter84Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter84Value(parameter84Value string) ApiCreateStreamRequest {
	r.parameter84Value = &parameter84Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter85Name(parameter85Name string) ApiCreateStreamRequest {
	r.parameter85Name = &parameter85Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter85Value(parameter85Value string) ApiCreateStreamRequest {
	r.parameter85Value = &parameter85Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter86Name(parameter86Name string) ApiCreateStreamRequest {
	r.parameter86Name = &parameter86Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter86Value(parameter86Value string) ApiCreateStreamRequest {
	r.parameter86Value = &parameter86Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter87Name(parameter87Name string) ApiCreateStreamRequest {
	r.parameter87Name = &parameter87Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter87Value(parameter87Value string) ApiCreateStreamRequest {
	r.parameter87Value = &parameter87Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter88Name(parameter88Name string) ApiCreateStreamRequest {
	r.parameter88Name = &parameter88Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter88Value(parameter88Value string) ApiCreateStreamRequest {
	r.parameter88Value = &parameter88Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter89Name(parameter89Name string) ApiCreateStreamRequest {
	r.parameter89Name = &parameter89Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter89Value(parameter89Value string) ApiCreateStreamRequest {
	r.parameter89Value = &parameter89Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter9Name(parameter9Name string) ApiCreateStreamRequest {
	r.parameter9Name = &parameter9Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter9Value(parameter9Value string) ApiCreateStreamRequest {
	r.parameter9Value = &parameter9Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter90Name(parameter90Name string) ApiCreateStreamRequest {
	r.parameter90Name = &parameter90Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter90Value(parameter90Value string) ApiCreateStreamRequest {
	r.parameter90Value = &parameter90Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter91Name(parameter91Name string) ApiCreateStreamRequest {
	r.parameter91Name = &parameter91Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter91Value(parameter91Value string) ApiCreateStreamRequest {
	r.parameter91Value = &parameter91Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter92Name(parameter92Name string) ApiCreateStreamRequest {
	r.parameter92Name = &parameter92Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter92Value(parameter92Value string) ApiCreateStreamRequest {
	r.parameter92Value = &parameter92Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter93Name(parameter93Name string) ApiCreateStreamRequest {
	r.parameter93Name = &parameter93Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter93Value(parameter93Value string) ApiCreateStreamRequest {
	r.parameter93Value = &parameter93Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter94Name(parameter94Name string) ApiCreateStreamRequest {
	r.parameter94Name = &parameter94Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter94Value(parameter94Value string) ApiCreateStreamRequest {
	r.parameter94Value = &parameter94Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter95Name(parameter95Name string) ApiCreateStreamRequest {
	r.parameter95Name = &parameter95Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter95Value(parameter95Value string) ApiCreateStreamRequest {
	r.parameter95Value = &parameter95Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter96Name(parameter96Name string) ApiCreateStreamRequest {
	r.parameter96Name = &parameter96Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter96Value(parameter96Value string) ApiCreateStreamRequest {
	r.parameter96Value = &parameter96Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter97Name(parameter97Name string) ApiCreateStreamRequest {
	r.parameter97Name = &parameter97Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter97Value(parameter97Value string) ApiCreateStreamRequest {
	r.parameter97Value = &parameter97Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter98Name(parameter98Name string) ApiCreateStreamRequest {
	r.parameter98Name = &parameter98Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter98Value(parameter98Value string) ApiCreateStreamRequest {
	r.parameter98Value = &parameter98Value
	return r
}

// Parameter name
func (r ApiCreateStreamRequest) Parameter99Name(parameter99Name string) ApiCreateStreamRequest {
	r.parameter99Name = &parameter99Name
	return r
}

// Parameter value
func (r ApiCreateStreamRequest) Parameter99Value(parameter99Value string) ApiCreateStreamRequest {
	r.parameter99Value = &parameter99Value
	return r
}

// Absolute URL of the status callback.
func (r ApiCreateStreamRequest) StatusCallback(statusCallback string) ApiCreateStreamRequest {
	r.statusCallback = &statusCallback
	return r
}

// The http method for the status_callback (one of GET, POST).
func (r ApiCreateStreamRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateStreamRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// One of &#x60;inbound_track&#x60;, &#x60;outbound_track&#x60;, &#x60;both_tracks&#x60;.
func (r ApiCreateStreamRequest) Track(track string) ApiCreateStreamRequest {
	r.track = &track
	return r
}

func (r ApiCreateStreamRequest) Execute() (*ApiV2010AccountCallStream, *http.Response, error) {
	return r.ApiService.CreateStreamExecute(r)
}

/*
CreateStream Method for CreateStream

Create a Stream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created this Stream resource.
 @param callSid The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the Stream resource is associated with.
 @return ApiCreateStreamRequest
*/
func (a *DefaultApiService) CreateStream(ctx context.Context, accountSid string, callSid string) ApiCreateStreamRequest {
	return ApiCreateStreamRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallStream
func (a *DefaultApiService) CreateStreamExecute(r ApiCreateStreamRequest) (*ApiV2010AccountCallStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		localVarFormParams.Add("Name", parameterToString(*r.name, ""))
	}
	if r.parameter1Name != nil {
		localVarFormParams.Add("Parameter1.Name", parameterToString(*r.parameter1Name, ""))
	}
	if r.parameter1Value != nil {
		localVarFormParams.Add("Parameter1.Value", parameterToString(*r.parameter1Value, ""))
	}
	if r.parameter10Name != nil {
		localVarFormParams.Add("Parameter10.Name", parameterToString(*r.parameter10Name, ""))
	}
	if r.parameter10Value != nil {
		localVarFormParams.Add("Parameter10.Value", parameterToString(*r.parameter10Value, ""))
	}
	if r.parameter11Name != nil {
		localVarFormParams.Add("Parameter11.Name", parameterToString(*r.parameter11Name, ""))
	}
	if r.parameter11Value != nil {
		localVarFormParams.Add("Parameter11.Value", parameterToString(*r.parameter11Value, ""))
	}
	if r.parameter12Name != nil {
		localVarFormParams.Add("Parameter12.Name", parameterToString(*r.parameter12Name, ""))
	}
	if r.parameter12Value != nil {
		localVarFormParams.Add("Parameter12.Value", parameterToString(*r.parameter12Value, ""))
	}
	if r.parameter13Name != nil {
		localVarFormParams.Add("Parameter13.Name", parameterToString(*r.parameter13Name, ""))
	}
	if r.parameter13Value != nil {
		localVarFormParams.Add("Parameter13.Value", parameterToString(*r.parameter13Value, ""))
	}
	if r.parameter14Name != nil {
		localVarFormParams.Add("Parameter14.Name", parameterToString(*r.parameter14Name, ""))
	}
	if r.parameter14Value != nil {
		localVarFormParams.Add("Parameter14.Value", parameterToString(*r.parameter14Value, ""))
	}
	if r.parameter15Name != nil {
		localVarFormParams.Add("Parameter15.Name", parameterToString(*r.parameter15Name, ""))
	}
	if r.parameter15Value != nil {
		localVarFormParams.Add("Parameter15.Value", parameterToString(*r.parameter15Value, ""))
	}
	if r.parameter16Name != nil {
		localVarFormParams.Add("Parameter16.Name", parameterToString(*r.parameter16Name, ""))
	}
	if r.parameter16Value != nil {
		localVarFormParams.Add("Parameter16.Value", parameterToString(*r.parameter16Value, ""))
	}
	if r.parameter17Name != nil {
		localVarFormParams.Add("Parameter17.Name", parameterToString(*r.parameter17Name, ""))
	}
	if r.parameter17Value != nil {
		localVarFormParams.Add("Parameter17.Value", parameterToString(*r.parameter17Value, ""))
	}
	if r.parameter18Name != nil {
		localVarFormParams.Add("Parameter18.Name", parameterToString(*r.parameter18Name, ""))
	}
	if r.parameter18Value != nil {
		localVarFormParams.Add("Parameter18.Value", parameterToString(*r.parameter18Value, ""))
	}
	if r.parameter19Name != nil {
		localVarFormParams.Add("Parameter19.Name", parameterToString(*r.parameter19Name, ""))
	}
	if r.parameter19Value != nil {
		localVarFormParams.Add("Parameter19.Value", parameterToString(*r.parameter19Value, ""))
	}
	if r.parameter2Name != nil {
		localVarFormParams.Add("Parameter2.Name", parameterToString(*r.parameter2Name, ""))
	}
	if r.parameter2Value != nil {
		localVarFormParams.Add("Parameter2.Value", parameterToString(*r.parameter2Value, ""))
	}
	if r.parameter20Name != nil {
		localVarFormParams.Add("Parameter20.Name", parameterToString(*r.parameter20Name, ""))
	}
	if r.parameter20Value != nil {
		localVarFormParams.Add("Parameter20.Value", parameterToString(*r.parameter20Value, ""))
	}
	if r.parameter21Name != nil {
		localVarFormParams.Add("Parameter21.Name", parameterToString(*r.parameter21Name, ""))
	}
	if r.parameter21Value != nil {
		localVarFormParams.Add("Parameter21.Value", parameterToString(*r.parameter21Value, ""))
	}
	if r.parameter22Name != nil {
		localVarFormParams.Add("Parameter22.Name", parameterToString(*r.parameter22Name, ""))
	}
	if r.parameter22Value != nil {
		localVarFormParams.Add("Parameter22.Value", parameterToString(*r.parameter22Value, ""))
	}
	if r.parameter23Name != nil {
		localVarFormParams.Add("Parameter23.Name", parameterToString(*r.parameter23Name, ""))
	}
	if r.parameter23Value != nil {
		localVarFormParams.Add("Parameter23.Value", parameterToString(*r.parameter23Value, ""))
	}
	if r.parameter24Name != nil {
		localVarFormParams.Add("Parameter24.Name", parameterToString(*r.parameter24Name, ""))
	}
	if r.parameter24Value != nil {
		localVarFormParams.Add("Parameter24.Value", parameterToString(*r.parameter24Value, ""))
	}
	if r.parameter25Name != nil {
		localVarFormParams.Add("Parameter25.Name", parameterToString(*r.parameter25Name, ""))
	}
	if r.parameter25Value != nil {
		localVarFormParams.Add("Parameter25.Value", parameterToString(*r.parameter25Value, ""))
	}
	if r.parameter26Name != nil {
		localVarFormParams.Add("Parameter26.Name", parameterToString(*r.parameter26Name, ""))
	}
	if r.parameter26Value != nil {
		localVarFormParams.Add("Parameter26.Value", parameterToString(*r.parameter26Value, ""))
	}
	if r.parameter27Name != nil {
		localVarFormParams.Add("Parameter27.Name", parameterToString(*r.parameter27Name, ""))
	}
	if r.parameter27Value != nil {
		localVarFormParams.Add("Parameter27.Value", parameterToString(*r.parameter27Value, ""))
	}
	if r.parameter28Name != nil {
		localVarFormParams.Add("Parameter28.Name", parameterToString(*r.parameter28Name, ""))
	}
	if r.parameter28Value != nil {
		localVarFormParams.Add("Parameter28.Value", parameterToString(*r.parameter28Value, ""))
	}
	if r.parameter29Name != nil {
		localVarFormParams.Add("Parameter29.Name", parameterToString(*r.parameter29Name, ""))
	}
	if r.parameter29Value != nil {
		localVarFormParams.Add("Parameter29.Value", parameterToString(*r.parameter29Value, ""))
	}
	if r.parameter3Name != nil {
		localVarFormParams.Add("Parameter3.Name", parameterToString(*r.parameter3Name, ""))
	}
	if r.parameter3Value != nil {
		localVarFormParams.Add("Parameter3.Value", parameterToString(*r.parameter3Value, ""))
	}
	if r.parameter30Name != nil {
		localVarFormParams.Add("Parameter30.Name", parameterToString(*r.parameter30Name, ""))
	}
	if r.parameter30Value != nil {
		localVarFormParams.Add("Parameter30.Value", parameterToString(*r.parameter30Value, ""))
	}
	if r.parameter31Name != nil {
		localVarFormParams.Add("Parameter31.Name", parameterToString(*r.parameter31Name, ""))
	}
	if r.parameter31Value != nil {
		localVarFormParams.Add("Parameter31.Value", parameterToString(*r.parameter31Value, ""))
	}
	if r.parameter32Name != nil {
		localVarFormParams.Add("Parameter32.Name", parameterToString(*r.parameter32Name, ""))
	}
	if r.parameter32Value != nil {
		localVarFormParams.Add("Parameter32.Value", parameterToString(*r.parameter32Value, ""))
	}
	if r.parameter33Name != nil {
		localVarFormParams.Add("Parameter33.Name", parameterToString(*r.parameter33Name, ""))
	}
	if r.parameter33Value != nil {
		localVarFormParams.Add("Parameter33.Value", parameterToString(*r.parameter33Value, ""))
	}
	if r.parameter34Name != nil {
		localVarFormParams.Add("Parameter34.Name", parameterToString(*r.parameter34Name, ""))
	}
	if r.parameter34Value != nil {
		localVarFormParams.Add("Parameter34.Value", parameterToString(*r.parameter34Value, ""))
	}
	if r.parameter35Name != nil {
		localVarFormParams.Add("Parameter35.Name", parameterToString(*r.parameter35Name, ""))
	}
	if r.parameter35Value != nil {
		localVarFormParams.Add("Parameter35.Value", parameterToString(*r.parameter35Value, ""))
	}
	if r.parameter36Name != nil {
		localVarFormParams.Add("Parameter36.Name", parameterToString(*r.parameter36Name, ""))
	}
	if r.parameter36Value != nil {
		localVarFormParams.Add("Parameter36.Value", parameterToString(*r.parameter36Value, ""))
	}
	if r.parameter37Name != nil {
		localVarFormParams.Add("Parameter37.Name", parameterToString(*r.parameter37Name, ""))
	}
	if r.parameter37Value != nil {
		localVarFormParams.Add("Parameter37.Value", parameterToString(*r.parameter37Value, ""))
	}
	if r.parameter38Name != nil {
		localVarFormParams.Add("Parameter38.Name", parameterToString(*r.parameter38Name, ""))
	}
	if r.parameter38Value != nil {
		localVarFormParams.Add("Parameter38.Value", parameterToString(*r.parameter38Value, ""))
	}
	if r.parameter39Name != nil {
		localVarFormParams.Add("Parameter39.Name", parameterToString(*r.parameter39Name, ""))
	}
	if r.parameter39Value != nil {
		localVarFormParams.Add("Parameter39.Value", parameterToString(*r.parameter39Value, ""))
	}
	if r.parameter4Name != nil {
		localVarFormParams.Add("Parameter4.Name", parameterToString(*r.parameter4Name, ""))
	}
	if r.parameter4Value != nil {
		localVarFormParams.Add("Parameter4.Value", parameterToString(*r.parameter4Value, ""))
	}
	if r.parameter40Name != nil {
		localVarFormParams.Add("Parameter40.Name", parameterToString(*r.parameter40Name, ""))
	}
	if r.parameter40Value != nil {
		localVarFormParams.Add("Parameter40.Value", parameterToString(*r.parameter40Value, ""))
	}
	if r.parameter41Name != nil {
		localVarFormParams.Add("Parameter41.Name", parameterToString(*r.parameter41Name, ""))
	}
	if r.parameter41Value != nil {
		localVarFormParams.Add("Parameter41.Value", parameterToString(*r.parameter41Value, ""))
	}
	if r.parameter42Name != nil {
		localVarFormParams.Add("Parameter42.Name", parameterToString(*r.parameter42Name, ""))
	}
	if r.parameter42Value != nil {
		localVarFormParams.Add("Parameter42.Value", parameterToString(*r.parameter42Value, ""))
	}
	if r.parameter43Name != nil {
		localVarFormParams.Add("Parameter43.Name", parameterToString(*r.parameter43Name, ""))
	}
	if r.parameter43Value != nil {
		localVarFormParams.Add("Parameter43.Value", parameterToString(*r.parameter43Value, ""))
	}
	if r.parameter44Name != nil {
		localVarFormParams.Add("Parameter44.Name", parameterToString(*r.parameter44Name, ""))
	}
	if r.parameter44Value != nil {
		localVarFormParams.Add("Parameter44.Value", parameterToString(*r.parameter44Value, ""))
	}
	if r.parameter45Name != nil {
		localVarFormParams.Add("Parameter45.Name", parameterToString(*r.parameter45Name, ""))
	}
	if r.parameter45Value != nil {
		localVarFormParams.Add("Parameter45.Value", parameterToString(*r.parameter45Value, ""))
	}
	if r.parameter46Name != nil {
		localVarFormParams.Add("Parameter46.Name", parameterToString(*r.parameter46Name, ""))
	}
	if r.parameter46Value != nil {
		localVarFormParams.Add("Parameter46.Value", parameterToString(*r.parameter46Value, ""))
	}
	if r.parameter47Name != nil {
		localVarFormParams.Add("Parameter47.Name", parameterToString(*r.parameter47Name, ""))
	}
	if r.parameter47Value != nil {
		localVarFormParams.Add("Parameter47.Value", parameterToString(*r.parameter47Value, ""))
	}
	if r.parameter48Name != nil {
		localVarFormParams.Add("Parameter48.Name", parameterToString(*r.parameter48Name, ""))
	}
	if r.parameter48Value != nil {
		localVarFormParams.Add("Parameter48.Value", parameterToString(*r.parameter48Value, ""))
	}
	if r.parameter49Name != nil {
		localVarFormParams.Add("Parameter49.Name", parameterToString(*r.parameter49Name, ""))
	}
	if r.parameter49Value != nil {
		localVarFormParams.Add("Parameter49.Value", parameterToString(*r.parameter49Value, ""))
	}
	if r.parameter5Name != nil {
		localVarFormParams.Add("Parameter5.Name", parameterToString(*r.parameter5Name, ""))
	}
	if r.parameter5Value != nil {
		localVarFormParams.Add("Parameter5.Value", parameterToString(*r.parameter5Value, ""))
	}
	if r.parameter50Name != nil {
		localVarFormParams.Add("Parameter50.Name", parameterToString(*r.parameter50Name, ""))
	}
	if r.parameter50Value != nil {
		localVarFormParams.Add("Parameter50.Value", parameterToString(*r.parameter50Value, ""))
	}
	if r.parameter51Name != nil {
		localVarFormParams.Add("Parameter51.Name", parameterToString(*r.parameter51Name, ""))
	}
	if r.parameter51Value != nil {
		localVarFormParams.Add("Parameter51.Value", parameterToString(*r.parameter51Value, ""))
	}
	if r.parameter52Name != nil {
		localVarFormParams.Add("Parameter52.Name", parameterToString(*r.parameter52Name, ""))
	}
	if r.parameter52Value != nil {
		localVarFormParams.Add("Parameter52.Value", parameterToString(*r.parameter52Value, ""))
	}
	if r.parameter53Name != nil {
		localVarFormParams.Add("Parameter53.Name", parameterToString(*r.parameter53Name, ""))
	}
	if r.parameter53Value != nil {
		localVarFormParams.Add("Parameter53.Value", parameterToString(*r.parameter53Value, ""))
	}
	if r.parameter54Name != nil {
		localVarFormParams.Add("Parameter54.Name", parameterToString(*r.parameter54Name, ""))
	}
	if r.parameter54Value != nil {
		localVarFormParams.Add("Parameter54.Value", parameterToString(*r.parameter54Value, ""))
	}
	if r.parameter55Name != nil {
		localVarFormParams.Add("Parameter55.Name", parameterToString(*r.parameter55Name, ""))
	}
	if r.parameter55Value != nil {
		localVarFormParams.Add("Parameter55.Value", parameterToString(*r.parameter55Value, ""))
	}
	if r.parameter56Name != nil {
		localVarFormParams.Add("Parameter56.Name", parameterToString(*r.parameter56Name, ""))
	}
	if r.parameter56Value != nil {
		localVarFormParams.Add("Parameter56.Value", parameterToString(*r.parameter56Value, ""))
	}
	if r.parameter57Name != nil {
		localVarFormParams.Add("Parameter57.Name", parameterToString(*r.parameter57Name, ""))
	}
	if r.parameter57Value != nil {
		localVarFormParams.Add("Parameter57.Value", parameterToString(*r.parameter57Value, ""))
	}
	if r.parameter58Name != nil {
		localVarFormParams.Add("Parameter58.Name", parameterToString(*r.parameter58Name, ""))
	}
	if r.parameter58Value != nil {
		localVarFormParams.Add("Parameter58.Value", parameterToString(*r.parameter58Value, ""))
	}
	if r.parameter59Name != nil {
		localVarFormParams.Add("Parameter59.Name", parameterToString(*r.parameter59Name, ""))
	}
	if r.parameter59Value != nil {
		localVarFormParams.Add("Parameter59.Value", parameterToString(*r.parameter59Value, ""))
	}
	if r.parameter6Name != nil {
		localVarFormParams.Add("Parameter6.Name", parameterToString(*r.parameter6Name, ""))
	}
	if r.parameter6Value != nil {
		localVarFormParams.Add("Parameter6.Value", parameterToString(*r.parameter6Value, ""))
	}
	if r.parameter60Name != nil {
		localVarFormParams.Add("Parameter60.Name", parameterToString(*r.parameter60Name, ""))
	}
	if r.parameter60Value != nil {
		localVarFormParams.Add("Parameter60.Value", parameterToString(*r.parameter60Value, ""))
	}
	if r.parameter61Name != nil {
		localVarFormParams.Add("Parameter61.Name", parameterToString(*r.parameter61Name, ""))
	}
	if r.parameter61Value != nil {
		localVarFormParams.Add("Parameter61.Value", parameterToString(*r.parameter61Value, ""))
	}
	if r.parameter62Name != nil {
		localVarFormParams.Add("Parameter62.Name", parameterToString(*r.parameter62Name, ""))
	}
	if r.parameter62Value != nil {
		localVarFormParams.Add("Parameter62.Value", parameterToString(*r.parameter62Value, ""))
	}
	if r.parameter63Name != nil {
		localVarFormParams.Add("Parameter63.Name", parameterToString(*r.parameter63Name, ""))
	}
	if r.parameter63Value != nil {
		localVarFormParams.Add("Parameter63.Value", parameterToString(*r.parameter63Value, ""))
	}
	if r.parameter64Name != nil {
		localVarFormParams.Add("Parameter64.Name", parameterToString(*r.parameter64Name, ""))
	}
	if r.parameter64Value != nil {
		localVarFormParams.Add("Parameter64.Value", parameterToString(*r.parameter64Value, ""))
	}
	if r.parameter65Name != nil {
		localVarFormParams.Add("Parameter65.Name", parameterToString(*r.parameter65Name, ""))
	}
	if r.parameter65Value != nil {
		localVarFormParams.Add("Parameter65.Value", parameterToString(*r.parameter65Value, ""))
	}
	if r.parameter66Name != nil {
		localVarFormParams.Add("Parameter66.Name", parameterToString(*r.parameter66Name, ""))
	}
	if r.parameter66Value != nil {
		localVarFormParams.Add("Parameter66.Value", parameterToString(*r.parameter66Value, ""))
	}
	if r.parameter67Name != nil {
		localVarFormParams.Add("Parameter67.Name", parameterToString(*r.parameter67Name, ""))
	}
	if r.parameter67Value != nil {
		localVarFormParams.Add("Parameter67.Value", parameterToString(*r.parameter67Value, ""))
	}
	if r.parameter68Name != nil {
		localVarFormParams.Add("Parameter68.Name", parameterToString(*r.parameter68Name, ""))
	}
	if r.parameter68Value != nil {
		localVarFormParams.Add("Parameter68.Value", parameterToString(*r.parameter68Value, ""))
	}
	if r.parameter69Name != nil {
		localVarFormParams.Add("Parameter69.Name", parameterToString(*r.parameter69Name, ""))
	}
	if r.parameter69Value != nil {
		localVarFormParams.Add("Parameter69.Value", parameterToString(*r.parameter69Value, ""))
	}
	if r.parameter7Name != nil {
		localVarFormParams.Add("Parameter7.Name", parameterToString(*r.parameter7Name, ""))
	}
	if r.parameter7Value != nil {
		localVarFormParams.Add("Parameter7.Value", parameterToString(*r.parameter7Value, ""))
	}
	if r.parameter70Name != nil {
		localVarFormParams.Add("Parameter70.Name", parameterToString(*r.parameter70Name, ""))
	}
	if r.parameter70Value != nil {
		localVarFormParams.Add("Parameter70.Value", parameterToString(*r.parameter70Value, ""))
	}
	if r.parameter71Name != nil {
		localVarFormParams.Add("Parameter71.Name", parameterToString(*r.parameter71Name, ""))
	}
	if r.parameter71Value != nil {
		localVarFormParams.Add("Parameter71.Value", parameterToString(*r.parameter71Value, ""))
	}
	if r.parameter72Name != nil {
		localVarFormParams.Add("Parameter72.Name", parameterToString(*r.parameter72Name, ""))
	}
	if r.parameter72Value != nil {
		localVarFormParams.Add("Parameter72.Value", parameterToString(*r.parameter72Value, ""))
	}
	if r.parameter73Name != nil {
		localVarFormParams.Add("Parameter73.Name", parameterToString(*r.parameter73Name, ""))
	}
	if r.parameter73Value != nil {
		localVarFormParams.Add("Parameter73.Value", parameterToString(*r.parameter73Value, ""))
	}
	if r.parameter74Name != nil {
		localVarFormParams.Add("Parameter74.Name", parameterToString(*r.parameter74Name, ""))
	}
	if r.parameter74Value != nil {
		localVarFormParams.Add("Parameter74.Value", parameterToString(*r.parameter74Value, ""))
	}
	if r.parameter75Name != nil {
		localVarFormParams.Add("Parameter75.Name", parameterToString(*r.parameter75Name, ""))
	}
	if r.parameter75Value != nil {
		localVarFormParams.Add("Parameter75.Value", parameterToString(*r.parameter75Value, ""))
	}
	if r.parameter76Name != nil {
		localVarFormParams.Add("Parameter76.Name", parameterToString(*r.parameter76Name, ""))
	}
	if r.parameter76Value != nil {
		localVarFormParams.Add("Parameter76.Value", parameterToString(*r.parameter76Value, ""))
	}
	if r.parameter77Name != nil {
		localVarFormParams.Add("Parameter77.Name", parameterToString(*r.parameter77Name, ""))
	}
	if r.parameter77Value != nil {
		localVarFormParams.Add("Parameter77.Value", parameterToString(*r.parameter77Value, ""))
	}
	if r.parameter78Name != nil {
		localVarFormParams.Add("Parameter78.Name", parameterToString(*r.parameter78Name, ""))
	}
	if r.parameter78Value != nil {
		localVarFormParams.Add("Parameter78.Value", parameterToString(*r.parameter78Value, ""))
	}
	if r.parameter79Name != nil {
		localVarFormParams.Add("Parameter79.Name", parameterToString(*r.parameter79Name, ""))
	}
	if r.parameter79Value != nil {
		localVarFormParams.Add("Parameter79.Value", parameterToString(*r.parameter79Value, ""))
	}
	if r.parameter8Name != nil {
		localVarFormParams.Add("Parameter8.Name", parameterToString(*r.parameter8Name, ""))
	}
	if r.parameter8Value != nil {
		localVarFormParams.Add("Parameter8.Value", parameterToString(*r.parameter8Value, ""))
	}
	if r.parameter80Name != nil {
		localVarFormParams.Add("Parameter80.Name", parameterToString(*r.parameter80Name, ""))
	}
	if r.parameter80Value != nil {
		localVarFormParams.Add("Parameter80.Value", parameterToString(*r.parameter80Value, ""))
	}
	if r.parameter81Name != nil {
		localVarFormParams.Add("Parameter81.Name", parameterToString(*r.parameter81Name, ""))
	}
	if r.parameter81Value != nil {
		localVarFormParams.Add("Parameter81.Value", parameterToString(*r.parameter81Value, ""))
	}
	if r.parameter82Name != nil {
		localVarFormParams.Add("Parameter82.Name", parameterToString(*r.parameter82Name, ""))
	}
	if r.parameter82Value != nil {
		localVarFormParams.Add("Parameter82.Value", parameterToString(*r.parameter82Value, ""))
	}
	if r.parameter83Name != nil {
		localVarFormParams.Add("Parameter83.Name", parameterToString(*r.parameter83Name, ""))
	}
	if r.parameter83Value != nil {
		localVarFormParams.Add("Parameter83.Value", parameterToString(*r.parameter83Value, ""))
	}
	if r.parameter84Name != nil {
		localVarFormParams.Add("Parameter84.Name", parameterToString(*r.parameter84Name, ""))
	}
	if r.parameter84Value != nil {
		localVarFormParams.Add("Parameter84.Value", parameterToString(*r.parameter84Value, ""))
	}
	if r.parameter85Name != nil {
		localVarFormParams.Add("Parameter85.Name", parameterToString(*r.parameter85Name, ""))
	}
	if r.parameter85Value != nil {
		localVarFormParams.Add("Parameter85.Value", parameterToString(*r.parameter85Value, ""))
	}
	if r.parameter86Name != nil {
		localVarFormParams.Add("Parameter86.Name", parameterToString(*r.parameter86Name, ""))
	}
	if r.parameter86Value != nil {
		localVarFormParams.Add("Parameter86.Value", parameterToString(*r.parameter86Value, ""))
	}
	if r.parameter87Name != nil {
		localVarFormParams.Add("Parameter87.Name", parameterToString(*r.parameter87Name, ""))
	}
	if r.parameter87Value != nil {
		localVarFormParams.Add("Parameter87.Value", parameterToString(*r.parameter87Value, ""))
	}
	if r.parameter88Name != nil {
		localVarFormParams.Add("Parameter88.Name", parameterToString(*r.parameter88Name, ""))
	}
	if r.parameter88Value != nil {
		localVarFormParams.Add("Parameter88.Value", parameterToString(*r.parameter88Value, ""))
	}
	if r.parameter89Name != nil {
		localVarFormParams.Add("Parameter89.Name", parameterToString(*r.parameter89Name, ""))
	}
	if r.parameter89Value != nil {
		localVarFormParams.Add("Parameter89.Value", parameterToString(*r.parameter89Value, ""))
	}
	if r.parameter9Name != nil {
		localVarFormParams.Add("Parameter9.Name", parameterToString(*r.parameter9Name, ""))
	}
	if r.parameter9Value != nil {
		localVarFormParams.Add("Parameter9.Value", parameterToString(*r.parameter9Value, ""))
	}
	if r.parameter90Name != nil {
		localVarFormParams.Add("Parameter90.Name", parameterToString(*r.parameter90Name, ""))
	}
	if r.parameter90Value != nil {
		localVarFormParams.Add("Parameter90.Value", parameterToString(*r.parameter90Value, ""))
	}
	if r.parameter91Name != nil {
		localVarFormParams.Add("Parameter91.Name", parameterToString(*r.parameter91Name, ""))
	}
	if r.parameter91Value != nil {
		localVarFormParams.Add("Parameter91.Value", parameterToString(*r.parameter91Value, ""))
	}
	if r.parameter92Name != nil {
		localVarFormParams.Add("Parameter92.Name", parameterToString(*r.parameter92Name, ""))
	}
	if r.parameter92Value != nil {
		localVarFormParams.Add("Parameter92.Value", parameterToString(*r.parameter92Value, ""))
	}
	if r.parameter93Name != nil {
		localVarFormParams.Add("Parameter93.Name", parameterToString(*r.parameter93Name, ""))
	}
	if r.parameter93Value != nil {
		localVarFormParams.Add("Parameter93.Value", parameterToString(*r.parameter93Value, ""))
	}
	if r.parameter94Name != nil {
		localVarFormParams.Add("Parameter94.Name", parameterToString(*r.parameter94Name, ""))
	}
	if r.parameter94Value != nil {
		localVarFormParams.Add("Parameter94.Value", parameterToString(*r.parameter94Value, ""))
	}
	if r.parameter95Name != nil {
		localVarFormParams.Add("Parameter95.Name", parameterToString(*r.parameter95Name, ""))
	}
	if r.parameter95Value != nil {
		localVarFormParams.Add("Parameter95.Value", parameterToString(*r.parameter95Value, ""))
	}
	if r.parameter96Name != nil {
		localVarFormParams.Add("Parameter96.Name", parameterToString(*r.parameter96Name, ""))
	}
	if r.parameter96Value != nil {
		localVarFormParams.Add("Parameter96.Value", parameterToString(*r.parameter96Value, ""))
	}
	if r.parameter97Name != nil {
		localVarFormParams.Add("Parameter97.Name", parameterToString(*r.parameter97Name, ""))
	}
	if r.parameter97Value != nil {
		localVarFormParams.Add("Parameter97.Value", parameterToString(*r.parameter97Value, ""))
	}
	if r.parameter98Name != nil {
		localVarFormParams.Add("Parameter98.Name", parameterToString(*r.parameter98Name, ""))
	}
	if r.parameter98Value != nil {
		localVarFormParams.Add("Parameter98.Value", parameterToString(*r.parameter98Value, ""))
	}
	if r.parameter99Name != nil {
		localVarFormParams.Add("Parameter99.Name", parameterToString(*r.parameter99Name, ""))
	}
	if r.parameter99Value != nil {
		localVarFormParams.Add("Parameter99.Value", parameterToString(*r.parameter99Value, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.track != nil {
		localVarFormParams.Add("Track", parameterToString(*r.track, ""))
	}
	localVarFormParams.Add("Url", parameterToString(*r.url, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTokenRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	ttl *int32
}

// The duration in seconds for which the generated credentials are valid. The default value is 86400 (24 hours).
func (r ApiCreateTokenRequest) Ttl(ttl int32) ApiCreateTokenRequest {
	r.ttl = &ttl
	return r
}

func (r ApiCreateTokenRequest) Execute() (*ApiV2010AccountToken, *http.Response, error) {
	return r.ApiService.CreateTokenExecute(r)
}

/*
CreateToken Method for CreateToken

Create a new token for ICE servers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateTokenRequest
*/
func (a *DefaultApiService) CreateToken(ctx context.Context, accountSid string) ApiCreateTokenRequest {
	return ApiCreateTokenRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountToken
func (a *DefaultApiService) CreateTokenExecute(r ApiCreateTokenRequest) (*ApiV2010AccountToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Tokens.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ttl != nil {
		localVarFormParams.Add("Ttl", parameterToString(*r.ttl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUsageTriggerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callbackUrl *string
	triggerValue *string
	usageCategory *string
	callbackMethod *string
	friendlyName *string
	recurring *string
	triggerBy *string
}

// The URL we should call using &#x60;callback_method&#x60; when the trigger fires.
func (r ApiCreateUsageTriggerRequest) CallbackUrl(callbackUrl string) ApiCreateUsageTriggerRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// The usage value at which the trigger should fire.  For convenience, you can use an offset value such as &#x60;+30&#x60; to specify a trigger_value that is 30 units more than the current usage value. Be sure to urlencode a &#x60;+&#x60; as &#x60;%2B&#x60;.
func (r ApiCreateUsageTriggerRequest) TriggerValue(triggerValue string) ApiCreateUsageTriggerRequest {
	r.triggerValue = &triggerValue
	return r
}

// The usage category that the trigger should watch.  Use one of the supported [usage categories](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) for this value.
func (r ApiCreateUsageTriggerRequest) UsageCategory(usageCategory string) ApiCreateUsageTriggerRequest {
	r.usageCategory = &usageCategory
	return r
}

// The HTTP method we should use to call &#x60;callback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;.
func (r ApiCreateUsageTriggerRequest) CallbackMethod(callbackMethod string) ApiCreateUsageTriggerRequest {
	r.callbackMethod = &callbackMethod
	return r
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiCreateUsageTriggerRequest) FriendlyName(friendlyName string) ApiCreateUsageTriggerRequest {
	r.friendlyName = &friendlyName
	return r
}

// The frequency of a recurring UsageTrigger.  Can be: &#x60;daily&#x60;, &#x60;monthly&#x60;, or &#x60;yearly&#x60; for recurring triggers or empty for non-recurring triggers. A trigger will only fire once during each period. Recurring times are in GMT.
func (r ApiCreateUsageTriggerRequest) Recurring(recurring string) ApiCreateUsageTriggerRequest {
	r.recurring = &recurring
	return r
}

// The field in the [UsageRecord](https://www.twilio.com/docs/usage/api/usage-record) resource that should fire the trigger.  Can be: &#x60;count&#x60;, &#x60;usage&#x60;, or &#x60;price&#x60; as described in the [UsageRecords documentation](https://www.twilio.com/docs/usage/api/usage-record#usage-count-price).  The default is &#x60;usage&#x60;.
func (r ApiCreateUsageTriggerRequest) TriggerBy(triggerBy string) ApiCreateUsageTriggerRequest {
	r.triggerBy = &triggerBy
	return r
}

func (r ApiCreateUsageTriggerRequest) Execute() (*ApiV2010AccountUsageUsageTrigger, *http.Response, error) {
	return r.ApiService.CreateUsageTriggerExecute(r)
}

/*
CreateUsageTrigger Method for CreateUsageTrigger

Create a new UsageTrigger

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
 @return ApiCreateUsageTriggerRequest
*/
func (a *DefaultApiService) CreateUsageTrigger(ctx context.Context, accountSid string) ApiCreateUsageTriggerRequest {
	return ApiCreateUsageTriggerRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountUsageUsageTrigger
func (a *DefaultApiService) CreateUsageTriggerExecute(r ApiCreateUsageTriggerRequest) (*ApiV2010AccountUsageUsageTrigger, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountUsageUsageTrigger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateUsageTrigger")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.callbackUrl == nil {
		return localVarReturnValue, nil, reportError("callbackUrl is required and must be specified")
	}
	if r.triggerValue == nil {
		return localVarReturnValue, nil, reportError("triggerValue is required and must be specified")
	}
	if r.usageCategory == nil {
		return localVarReturnValue, nil, reportError("usageCategory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.callbackMethod != nil {
		localVarFormParams.Add("CallbackMethod", parameterToString(*r.callbackMethod, ""))
	}
	localVarFormParams.Add("CallbackUrl", parameterToString(*r.callbackUrl, ""))
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.recurring != nil {
		localVarFormParams.Add("Recurring", parameterToString(*r.recurring, ""))
	}
	if r.triggerBy != nil {
		localVarFormParams.Add("TriggerBy", parameterToString(*r.triggerBy, ""))
	}
	localVarFormParams.Add("TriggerValue", parameterToString(*r.triggerValue, ""))
	localVarFormParams.Add("UsageCategory", parameterToString(*r.usageCategory, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateValidationRequestRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	phoneNumber *string
	callDelay *int32
	extension *string
	friendlyName *string
	statusCallback *string
	statusCallbackMethod *string
}

// The phone number to verify in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, which consists of a + followed by the country code and subscriber number.
func (r ApiCreateValidationRequestRequest) PhoneNumber(phoneNumber string) ApiCreateValidationRequestRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// The number of seconds to delay before initiating the verification call. Can be an integer between &#x60;0&#x60; and &#x60;60&#x60;, inclusive. The default is &#x60;0&#x60;.
func (r ApiCreateValidationRequestRequest) CallDelay(callDelay int32) ApiCreateValidationRequestRequest {
	r.callDelay = &callDelay
	return r
}

// The digits to dial after connecting the verification call.
func (r ApiCreateValidationRequestRequest) Extension(extension string) ApiCreateValidationRequestRequest {
	r.extension = &extension
	return r
}

// A descriptive string that you create to describe the new caller ID resource. It can be up to 64 characters long. The default value is a formatted version of the phone number.
func (r ApiCreateValidationRequestRequest) FriendlyName(friendlyName string) ApiCreateValidationRequestRequest {
	r.friendlyName = &friendlyName
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information about the verification process to your application.
func (r ApiCreateValidationRequestRequest) StatusCallback(statusCallback string) ApiCreateValidationRequestRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;, and the default is &#x60;POST&#x60;.
func (r ApiCreateValidationRequestRequest) StatusCallbackMethod(statusCallbackMethod string) ApiCreateValidationRequestRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

func (r ApiCreateValidationRequestRequest) Execute() (*ApiV2010AccountValidationRequest, *http.Response, error) {
	return r.ApiService.CreateValidationRequestExecute(r)
}

/*
CreateValidationRequest Method for CreateValidationRequest



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for the new caller ID resource.
 @return ApiCreateValidationRequestRequest
*/
func (a *DefaultApiService) CreateValidationRequest(ctx context.Context, accountSid string) ApiCreateValidationRequestRequest {
	return ApiCreateValidationRequestRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountValidationRequest
func (a *DefaultApiService) CreateValidationRequestExecute(r ApiCreateValidationRequestRequest) (*ApiV2010AccountValidationRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountValidationRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateValidationRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if r.phoneNumber == nil {
		return localVarReturnValue, nil, reportError("phoneNumber is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.callDelay != nil {
		localVarFormParams.Add("CallDelay", parameterToString(*r.callDelay, ""))
	}
	if r.extension != nil {
		localVarFormParams.Add("Extension", parameterToString(*r.extension, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	localVarFormParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteAddressRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAddressExecute(r)
}

/*
DeleteAddress Method for DeleteAddress



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to delete.
 @param sid The Twilio-provided string that uniquely identifies the Address resource to delete.
 @return ApiDeleteAddressRequest
*/
func (a *DefaultApiService) DeleteAddress(ctx context.Context, accountSid string, sid string) ApiDeleteAddressRequest {
	return ApiDeleteAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteAddressExecute(r ApiDeleteAddressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAddress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteApplicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicationExecute(r)
}

/*
DeleteApplication Method for DeleteApplication

Delete the application by the specified application sid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the Application resource to delete.
 @return ApiDeleteApplicationRequest
*/
func (a *DefaultApiService) DeleteApplication(ctx context.Context, accountSid string, sid string) ApiDeleteApplicationRequest {
	return ApiDeleteApplicationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteApplicationExecute(r ApiDeleteApplicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteApplication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCallRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteCallRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCallExecute(r)
}

/*
DeleteCall Method for DeleteCall

Delete a Call record from your account. Once the record is deleted, it will no longer appear in the API and Account Portal logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to delete.
 @param sid The Twilio-provided Call SID that uniquely identifies the Call resource to delete
 @return ApiDeleteCallRequest
*/
func (a *DefaultApiService) DeleteCall(ctx context.Context, accountSid string, sid string) ApiDeleteCallRequest {
	return ApiDeleteCallRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteCallExecute(r ApiDeleteCallRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCall")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCallFeedbackSummaryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteCallFeedbackSummaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCallFeedbackSummaryExecute(r)
}

/*
DeleteCallFeedbackSummary Method for DeleteCallFeedbackSummary

Delete a FeedbackSummary resource from a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param sid A 34 character string that uniquely identifies this resource.
 @return ApiDeleteCallFeedbackSummaryRequest
*/
func (a *DefaultApiService) DeleteCallFeedbackSummary(ctx context.Context, accountSid string, sid string) ApiDeleteCallFeedbackSummaryRequest {
	return ApiDeleteCallFeedbackSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteCallFeedbackSummaryExecute(r ApiDeleteCallFeedbackSummaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCallFeedbackSummary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCallRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
}

func (r ApiDeleteCallRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCallRecordingExecute(r)
}

/*
DeleteCallRecording Method for DeleteCallRecording

Delete a recording from your account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to delete.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the Recording resource to delete.
 @return ApiDeleteCallRecordingRequest
*/
func (a *DefaultApiService) DeleteCallRecording(ctx context.Context, accountSid string, callSid string, sid string) ApiDeleteCallRecordingRequest {
	return ApiDeleteCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteCallRecordingExecute(r ApiDeleteCallRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCallRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return nil, reportError("callSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	sid string
}

func (r ApiDeleteConferenceRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteConferenceRecordingExecute(r)
}

/*
DeleteConferenceRecording Method for DeleteConferenceRecording

Delete a recording from your account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resources to delete.
 @param conferenceSid The Conference SID that identifies the conference associated with the recording to delete.
 @param sid The Twilio-provided string that uniquely identifies the Conference Recording resource to delete.
 @return ApiDeleteConferenceRecordingRequest
*/
func (a *DefaultApiService) DeleteConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string) ApiDeleteConferenceRecordingRequest {
	return ApiDeleteConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteConferenceRecordingExecute(r ApiDeleteConferenceRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteConferenceRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return nil, reportError("conferenceSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteConnectAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteConnectAppRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteConnectAppExecute(r)
}

/*
DeleteConnectApp Method for DeleteConnectApp

Delete an instance of a connect-app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the ConnectApp resource to fetch.
 @return ApiDeleteConnectAppRequest
*/
func (a *DefaultApiService) DeleteConnectApp(ctx context.Context, accountSid string, sid string) ApiDeleteConnectAppRequest {
	return ApiDeleteConnectAppRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteConnectAppExecute(r ApiDeleteConnectAppRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteConnectApp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteIncomingPhoneNumberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteIncomingPhoneNumberRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIncomingPhoneNumberExecute(r)
}

/*
DeleteIncomingPhoneNumber Method for DeleteIncomingPhoneNumber

Delete a phone-numbers belonging to the account used to make the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the IncomingPhoneNumber resource to delete.
 @return ApiDeleteIncomingPhoneNumberRequest
*/
func (a *DefaultApiService) DeleteIncomingPhoneNumber(ctx context.Context, accountSid string, sid string) ApiDeleteIncomingPhoneNumberRequest {
	return ApiDeleteIncomingPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteIncomingPhoneNumberExecute(r ApiDeleteIncomingPhoneNumberRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIncomingPhoneNumber")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteIncomingPhoneNumberAssignedAddOnRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	resourceSid string
	sid string
}

func (r ApiDeleteIncomingPhoneNumberAssignedAddOnRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIncomingPhoneNumberAssignedAddOnExecute(r)
}

/*
DeleteIncomingPhoneNumberAssignedAddOn Method for DeleteIncomingPhoneNumberAssignedAddOn

Remove the assignment of an Add-on installation from the Number specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to delete.
 @param resourceSid The SID of the Phone Number to which the Add-on is assigned.
 @param sid The Twilio-provided string that uniquely identifies the resource to delete.
 @return ApiDeleteIncomingPhoneNumberAssignedAddOnRequest
*/
func (a *DefaultApiService) DeleteIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, sid string) ApiDeleteIncomingPhoneNumberAssignedAddOnRequest {
	return ApiDeleteIncomingPhoneNumberAssignedAddOnRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		resourceSid: resourceSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteIncomingPhoneNumberAssignedAddOnExecute(r ApiDeleteIncomingPhoneNumberAssignedAddOnRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIncomingPhoneNumberAssignedAddOn")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ResourceSid"+"}", url.PathEscape(parameterToString(r.resourceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.resourceSid) < 34 {
		return nil, reportError("resourceSid must have at least 34 elements")
	}
	if strlen(r.resourceSid) > 34 {
		return nil, reportError("resourceSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteKeyExecute(r)
}

/*
DeleteKey Method for DeleteKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the Key resource to delete.
 @return ApiDeleteKeyRequest
*/
func (a *DefaultApiService) DeleteKey(ctx context.Context, accountSid string, sid string) ApiDeleteKeyRequest {
	return ApiDeleteKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteKeyExecute(r ApiDeleteKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMediaRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	messageSid string
	sid string
}

func (r ApiDeleteMediaRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMediaExecute(r)
}

/*
DeleteMedia Method for DeleteMedia

Delete media from your account. Once delete, you will no longer be billed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Media resource(s) to delete.
 @param messageSid The SID of the Message resource that this Media resource belongs to.
 @param sid The Twilio-provided string that uniquely identifies the Media resource to delete
 @return ApiDeleteMediaRequest
*/
func (a *DefaultApiService) DeleteMedia(ctx context.Context, accountSid string, messageSid string, sid string) ApiDeleteMediaRequest {
	return ApiDeleteMediaRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		messageSid: messageSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteMediaExecute(r ApiDeleteMediaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteMedia")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MessageSid"+"}", url.PathEscape(parameterToString(r.messageSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.messageSid) < 34 {
		return nil, reportError("messageSid must have at least 34 elements")
	}
	if strlen(r.messageSid) > 34 {
		return nil, reportError("messageSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMessageExecute(r)
}

/*
DeleteMessage Method for DeleteMessage

Deletes a message record from your account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the Message resource to delete.
 @return ApiDeleteMessageRequest
*/
func (a *DefaultApiService) DeleteMessage(ctx context.Context, accountSid string, sid string) ApiDeleteMessageRequest {
	return ApiDeleteMessageRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteMessageExecute(r ApiDeleteMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteOutgoingCallerIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteOutgoingCallerIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOutgoingCallerIdExecute(r)
}

/*
DeleteOutgoingCallerId Method for DeleteOutgoingCallerId

Delete the caller-id specified from the account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the OutgoingCallerId resource to delete.
 @return ApiDeleteOutgoingCallerIdRequest
*/
func (a *DefaultApiService) DeleteOutgoingCallerId(ctx context.Context, accountSid string, sid string) ApiDeleteOutgoingCallerIdRequest {
	return ApiDeleteOutgoingCallerIdRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteOutgoingCallerIdExecute(r ApiDeleteOutgoingCallerIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteOutgoingCallerId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteParticipantRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	callSid string
}

func (r ApiDeleteParticipantRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteParticipantExecute(r)
}

/*
DeleteParticipant Method for DeleteParticipant

Kick a participant from a given conference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to delete.
 @param conferenceSid The SID of the conference with the participants to delete.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to delete. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
 @return ApiDeleteParticipantRequest
*/
func (a *DefaultApiService) DeleteParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string) ApiDeleteParticipantRequest {
	return ApiDeleteParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		callSid: callSid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteParticipantExecute(r ApiDeleteParticipantRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteParticipant")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return nil, reportError("conferenceSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteQueueRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteQueueExecute(r)
}

/*
DeleteQueue Method for DeleteQueue

Remove an empty queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resource to delete.
 @param sid The Twilio-provided string that uniquely identifies the Queue resource to delete
 @return ApiDeleteQueueRequest
*/
func (a *DefaultApiService) DeleteQueue(ctx context.Context, accountSid string, sid string) ApiDeleteQueueRequest {
	return ApiDeleteQueueRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteQueueExecute(r ApiDeleteQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingExecute(r)
}

/*
DeleteRecording Method for DeleteRecording

Delete a recording from your account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the Recording resource to delete.
 @return ApiDeleteRecordingRequest
*/
func (a *DefaultApiService) DeleteRecording(ctx context.Context, accountSid string, sid string) ApiDeleteRecordingRequest {
	return ApiDeleteRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteRecordingExecute(r ApiDeleteRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRecordingAddOnResultRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	referenceSid string
	sid string
}

func (r ApiDeleteRecordingAddOnResultRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingAddOnResultExecute(r)
}

/*
DeleteRecordingAddOnResult Method for DeleteRecordingAddOnResult

Delete a result and purge all associated Payloads

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult resources to delete.
 @param referenceSid The SID of the recording to which the result to delete belongs.
 @param sid The Twilio-provided string that uniquely identifies the Recording AddOnResult resource to delete.
 @return ApiDeleteRecordingAddOnResultRequest
*/
func (a *DefaultApiService) DeleteRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, sid string) ApiDeleteRecordingAddOnResultRequest {
	return ApiDeleteRecordingAddOnResultRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		referenceSid: referenceSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteRecordingAddOnResultExecute(r ApiDeleteRecordingAddOnResultRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordingAddOnResult")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ReferenceSid"+"}", url.PathEscape(parameterToString(r.referenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.referenceSid) < 34 {
		return nil, reportError("referenceSid must have at least 34 elements")
	}
	if strlen(r.referenceSid) > 34 {
		return nil, reportError("referenceSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRecordingAddOnResultPayloadRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	referenceSid string
	addOnResultSid string
	sid string
}

func (r ApiDeleteRecordingAddOnResultPayloadRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingAddOnResultPayloadExecute(r)
}

/*
DeleteRecordingAddOnResultPayload Method for DeleteRecordingAddOnResultPayload

Delete a payload from the result along with all associated Data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult Payload resources to delete.
 @param referenceSid The SID of the recording to which the AddOnResult resource that contains the payloads to delete belongs.
 @param addOnResultSid The SID of the AddOnResult to which the payloads to delete belongs.
 @param sid The Twilio-provided string that uniquely identifies the Recording AddOnResult Payload resource to delete.
 @return ApiDeleteRecordingAddOnResultPayloadRequest
*/
func (a *DefaultApiService) DeleteRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, sid string) ApiDeleteRecordingAddOnResultPayloadRequest {
	return ApiDeleteRecordingAddOnResultPayloadRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		referenceSid: referenceSid,
		addOnResultSid: addOnResultSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteRecordingAddOnResultPayloadExecute(r ApiDeleteRecordingAddOnResultPayloadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordingAddOnResultPayload")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ReferenceSid"+"}", url.PathEscape(parameterToString(r.referenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AddOnResultSid"+"}", url.PathEscape(parameterToString(r.addOnResultSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.referenceSid) < 34 {
		return nil, reportError("referenceSid must have at least 34 elements")
	}
	if strlen(r.referenceSid) > 34 {
		return nil, reportError("referenceSid must have less than 34 elements")
	}
	if strlen(r.addOnResultSid) < 34 {
		return nil, reportError("addOnResultSid must have at least 34 elements")
	}
	if strlen(r.addOnResultSid) > 34 {
		return nil, reportError("addOnResultSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRecordingTranscriptionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	recordingSid string
	sid string
}

func (r ApiDeleteRecordingTranscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingTranscriptionExecute(r)
}

/*
DeleteRecordingTranscription Method for DeleteRecordingTranscription



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to delete.
 @param recordingSid The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) that created the transcription to delete.
 @param sid The Twilio-provided string that uniquely identifies the Transcription resource to delete.
 @return ApiDeleteRecordingTranscriptionRequest
*/
func (a *DefaultApiService) DeleteRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, sid string) ApiDeleteRecordingTranscriptionRequest {
	return ApiDeleteRecordingTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingSid: recordingSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteRecordingTranscriptionExecute(r ApiDeleteRecordingTranscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRecordingTranscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"RecordingSid"+"}", url.PathEscape(parameterToString(r.recordingSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.recordingSid) < 34 {
		return nil, reportError("recordingSid must have at least 34 elements")
	}
	if strlen(r.recordingSid) > 34 {
		return nil, reportError("recordingSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSigningKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteSigningKeyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSigningKeyExecute(r)
}

/*
DeleteSigningKey Method for DeleteSigningKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid 
 @param sid 
 @return ApiDeleteSigningKeyRequest
*/
func (a *DefaultApiService) DeleteSigningKey(ctx context.Context, accountSid string, sid string) ApiDeleteSigningKeyRequest {
	return ApiDeleteSigningKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSigningKeyExecute(r ApiDeleteSigningKeyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSigningKey")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipAuthCallsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiDeleteSipAuthCallsCredentialListMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipAuthCallsCredentialListMappingExecute(r)
}

/*
DeleteSipAuthCallsCredentialListMapping Method for DeleteSipAuthCallsCredentialListMapping

Delete a credential list mapping from the requested domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to delete.
 @param domainSid The SID of the SIP domain that contains the resource to delete.
 @param sid The Twilio-provided string that uniquely identifies the CredentialListMapping resource to delete.
 @return ApiDeleteSipAuthCallsCredentialListMappingRequest
*/
func (a *DefaultApiService) DeleteSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiDeleteSipAuthCallsCredentialListMappingRequest {
	return ApiDeleteSipAuthCallsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipAuthCallsCredentialListMappingExecute(r ApiDeleteSipAuthCallsCredentialListMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipAuthCallsCredentialListMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipAuthCallsIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiDeleteSipAuthCallsIpAccessControlListMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipAuthCallsIpAccessControlListMappingExecute(r)
}

/*
DeleteSipAuthCallsIpAccessControlListMapping Method for DeleteSipAuthCallsIpAccessControlListMapping

Delete an IP Access Control List mapping from the requested domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlListMapping resources to delete.
 @param domainSid The SID of the SIP domain that contains the resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the IpAccessControlListMapping resource to delete.
 @return ApiDeleteSipAuthCallsIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) DeleteSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiDeleteSipAuthCallsIpAccessControlListMappingRequest {
	return ApiDeleteSipAuthCallsIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipAuthCallsIpAccessControlListMappingExecute(r ApiDeleteSipAuthCallsIpAccessControlListMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipAuthCallsIpAccessControlListMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipAuthRegistrationsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiDeleteSipAuthRegistrationsCredentialListMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipAuthRegistrationsCredentialListMappingExecute(r)
}

/*
DeleteSipAuthRegistrationsCredentialListMapping Method for DeleteSipAuthRegistrationsCredentialListMapping

Delete a credential list mapping from the requested domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to delete.
 @param domainSid The SID of the SIP domain that contains the resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the CredentialListMapping resource to delete.
 @return ApiDeleteSipAuthRegistrationsCredentialListMappingRequest
*/
func (a *DefaultApiService) DeleteSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiDeleteSipAuthRegistrationsCredentialListMappingRequest {
	return ApiDeleteSipAuthRegistrationsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipAuthRegistrationsCredentialListMappingExecute(r ApiDeleteSipAuthRegistrationsCredentialListMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipAuthRegistrationsCredentialListMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipCredentialRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	credentialListSid string
	sid string
}

func (r ApiDeleteSipCredentialRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipCredentialExecute(r)
}

/*
DeleteSipCredential Method for DeleteSipCredential

Delete a credential resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param credentialListSid The unique id that identifies the credential list that contains the desired credentials.
 @param sid The unique id that identifies the resource to delete.
 @return ApiDeleteSipCredentialRequest
*/
func (a *DefaultApiService) DeleteSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string) ApiDeleteSipCredentialRequest {
	return ApiDeleteSipCredentialRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		credentialListSid: credentialListSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipCredentialExecute(r ApiDeleteSipCredentialRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipCredential")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CredentialListSid"+"}", url.PathEscape(parameterToString(r.credentialListSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.credentialListSid) < 34 {
		return nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(r.credentialListSid) > 34 {
		return nil, reportError("credentialListSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipCredentialListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteSipCredentialListRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipCredentialListExecute(r)
}

/*
DeleteSipCredentialList Method for DeleteSipCredentialList

Delete a Credential List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param sid The credential list Sid that uniquely identifies this resource
 @return ApiDeleteSipCredentialListRequest
*/
func (a *DefaultApiService) DeleteSipCredentialList(ctx context.Context, accountSid string, sid string) ApiDeleteSipCredentialListRequest {
	return ApiDeleteSipCredentialListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipCredentialListExecute(r ApiDeleteSipCredentialListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipCredentialList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiDeleteSipCredentialListMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipCredentialListMappingExecute(r)
}

/*
DeleteSipCredentialListMapping Method for DeleteSipCredentialListMapping

Delete a CredentialListMapping resource from an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP Domain that includes the resource to delete.
 @param sid A 34 character string that uniquely identifies the resource to delete.
 @return ApiDeleteSipCredentialListMappingRequest
*/
func (a *DefaultApiService) DeleteSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiDeleteSipCredentialListMappingRequest {
	return ApiDeleteSipCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipCredentialListMappingExecute(r ApiDeleteSipCredentialListMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipCredentialListMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipDomainRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteSipDomainRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipDomainExecute(r)
}

/*
DeleteSipDomain Method for DeleteSipDomain

Delete an instance of a Domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the SipDomain resource to delete.
 @return ApiDeleteSipDomainRequest
*/
func (a *DefaultApiService) DeleteSipDomain(ctx context.Context, accountSid string, sid string) ApiDeleteSipDomainRequest {
	return ApiDeleteSipDomainRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipDomainExecute(r ApiDeleteSipDomainRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipDomain")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipIpAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteSipIpAccessControlListRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipIpAccessControlListExecute(r)
}

/*
DeleteSipIpAccessControlList Method for DeleteSipIpAccessControlList

Delete an IpAccessControlList from the requested account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param sid A 34 character string that uniquely identifies the resource to delete.
 @return ApiDeleteSipIpAccessControlListRequest
*/
func (a *DefaultApiService) DeleteSipIpAccessControlList(ctx context.Context, accountSid string, sid string) ApiDeleteSipIpAccessControlListRequest {
	return ApiDeleteSipIpAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipIpAccessControlListExecute(r ApiDeleteSipIpAccessControlListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipIpAccessControlList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiDeleteSipIpAccessControlListMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipIpAccessControlListMappingExecute(r)
}

/*
DeleteSipIpAccessControlListMapping Method for DeleteSipIpAccessControlListMapping

Delete an IpAccessControlListMapping resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP domain.
 @param sid A 34 character string that uniquely identifies the resource to delete.
 @return ApiDeleteSipIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) DeleteSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiDeleteSipIpAccessControlListMappingRequest {
	return ApiDeleteSipIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipIpAccessControlListMappingExecute(r ApiDeleteSipIpAccessControlListMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipIpAccessControlListMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSipIpAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	ipAccessControlListSid string
	sid string
}

func (r ApiDeleteSipIpAddressRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSipIpAddressExecute(r)
}

/*
DeleteSipIpAddress Method for DeleteSipIpAddress

Delete an IpAddress resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param ipAccessControlListSid The IpAccessControlList Sid that identifies the IpAddress resources to delete.
 @param sid A 34 character string that uniquely identifies the resource to delete.
 @return ApiDeleteSipIpAddressRequest
*/
func (a *DefaultApiService) DeleteSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string) ApiDeleteSipIpAddressRequest {
	return ApiDeleteSipIpAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		ipAccessControlListSid: ipAccessControlListSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSipIpAddressExecute(r ApiDeleteSipIpAddressRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSipIpAddress")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"IpAccessControlListSid"+"}", url.PathEscape(parameterToString(r.ipAccessControlListSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.ipAccessControlListSid) < 34 {
		return nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(r.ipAccessControlListSid) > 34 {
		return nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTranscriptionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteTranscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTranscriptionExecute(r)
}

/*
DeleteTranscription Method for DeleteTranscription

Delete a transcription from the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the Transcription resource to delete.
 @return ApiDeleteTranscriptionRequest
*/
func (a *DefaultApiService) DeleteTranscription(ctx context.Context, accountSid string, sid string) ApiDeleteTranscriptionRequest {
	return ApiDeleteTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTranscriptionExecute(r ApiDeleteTranscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTranscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUsageTriggerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiDeleteUsageTriggerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUsageTriggerExecute(r)
}

/*
DeleteUsageTrigger Method for DeleteUsageTrigger



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resources to delete.
 @param sid The Twilio-provided string that uniquely identifies the UsageTrigger resource to delete.
 @return ApiDeleteUsageTriggerRequest
*/
func (a *DefaultApiService) DeleteUsageTrigger(ctx context.Context, accountSid string, sid string) ApiDeleteUsageTriggerRequest {
	return ApiDeleteUsageTriggerRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteUsageTriggerExecute(r ApiDeleteUsageTriggerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteUsageTrigger")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFetchAccountRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sid string
}

func (r ApiFetchAccountRequest) Execute() (*ApiV2010Account, *http.Response, error) {
	return r.ApiService.FetchAccountExecute(r)
}

/*
FetchAccount Method for FetchAccount

Fetch the account specified by the provided Account Sid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sid The Account Sid that uniquely identifies the account to fetch
 @return ApiFetchAccountRequest
*/
func (a *DefaultApiService) FetchAccount(ctx context.Context, sid string) ApiFetchAccountRequest {
	return ApiFetchAccountRequest{
		ApiService: a,
		ctx: ctx,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010Account
func (a *DefaultApiService) FetchAccountExecute(r ApiFetchAccountRequest) (*ApiV2010Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchAddressRequest) Execute() (*ApiV2010AccountAddress, *http.Response, error) {
	return r.ApiService.FetchAddressExecute(r)
}

/*
FetchAddress Method for FetchAddress



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Address resource to fetch.
 @return ApiFetchAddressRequest
*/
func (a *DefaultApiService) FetchAddress(ctx context.Context, accountSid string, sid string) ApiFetchAddressRequest {
	return ApiFetchAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountAddress
func (a *DefaultApiService) FetchAddressExecute(r ApiFetchAddressRequest) (*ApiV2010AccountAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchApplicationRequest) Execute() (*ApiV2010AccountApplication, *http.Response, error) {
	return r.ApiService.FetchApplicationExecute(r)
}

/*
FetchApplication Method for FetchApplication

Fetch the application specified by the provided sid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Application resource to fetch.
 @return ApiFetchApplicationRequest
*/
func (a *DefaultApiService) FetchApplication(ctx context.Context, accountSid string, sid string) ApiFetchApplicationRequest {
	return ApiFetchApplicationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountApplication
func (a *DefaultApiService) FetchApplicationExecute(r ApiFetchApplicationRequest) (*ApiV2010AccountApplication, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAuthorizedConnectAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	connectAppSid string
}

func (r ApiFetchAuthorizedConnectAppRequest) Execute() (*ApiV2010AccountAuthorizedConnectApp, *http.Response, error) {
	return r.ApiService.FetchAuthorizedConnectAppExecute(r)
}

/*
FetchAuthorizedConnectApp Method for FetchAuthorizedConnectApp

Fetch an instance of an authorized-connect-app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the AuthorizedConnectApp resource to fetch.
 @param connectAppSid The SID of the Connect App to fetch.
 @return ApiFetchAuthorizedConnectAppRequest
*/
func (a *DefaultApiService) FetchAuthorizedConnectApp(ctx context.Context, accountSid string, connectAppSid string) ApiFetchAuthorizedConnectAppRequest {
	return ApiFetchAuthorizedConnectAppRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		connectAppSid: connectAppSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountAuthorizedConnectApp
func (a *DefaultApiService) FetchAuthorizedConnectAppExecute(r ApiFetchAuthorizedConnectAppRequest) (*ApiV2010AccountAuthorizedConnectApp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountAuthorizedConnectApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchAuthorizedConnectApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConnectAppSid"+"}", url.PathEscape(parameterToString(r.connectAppSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.connectAppSid) < 34 {
		return localVarReturnValue, nil, reportError("connectAppSid must have at least 34 elements")
	}
	if strlen(r.connectAppSid) > 34 {
		return localVarReturnValue, nil, reportError("connectAppSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchAvailablePhoneNumberCountryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
}

func (r ApiFetchAvailablePhoneNumberCountryRequest) Execute() (*ApiV2010AccountAvailablePhoneNumberCountry, *http.Response, error) {
	return r.ApiService.FetchAvailablePhoneNumberCountryExecute(r)
}

/*
FetchAvailablePhoneNumberCountry Method for FetchAvailablePhoneNumberCountry



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the available phone number Country resource.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country to fetch available phone number information about.
 @return ApiFetchAvailablePhoneNumberCountryRequest
*/
func (a *DefaultApiService) FetchAvailablePhoneNumberCountry(ctx context.Context, accountSid string, countryCode string) ApiFetchAvailablePhoneNumberCountryRequest {
	return ApiFetchAvailablePhoneNumberCountryRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ApiV2010AccountAvailablePhoneNumberCountry
func (a *DefaultApiService) FetchAvailablePhoneNumberCountryExecute(r ApiFetchAvailablePhoneNumberCountryRequest) (*ApiV2010AccountAvailablePhoneNumberCountry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountAvailablePhoneNumberCountry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchAvailablePhoneNumberCountry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchBalanceRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
}

func (r ApiFetchBalanceRequest) Execute() (*ApiV2010AccountBalance, *http.Response, error) {
	return r.ApiService.FetchBalanceExecute(r)
}

/*
FetchBalance Method for FetchBalance

Fetch the balance for an Account based on Account Sid. Balance changes may not be reflected immediately. Child accounts do not contain balance information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique SID identifier of the Account.
 @return ApiFetchBalanceRequest
*/
func (a *DefaultApiService) FetchBalance(ctx context.Context, accountSid string) ApiFetchBalanceRequest {
	return ApiFetchBalanceRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountBalance
func (a *DefaultApiService) FetchBalanceExecute(r ApiFetchBalanceRequest) (*ApiV2010AccountBalance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountBalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Balance.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCallRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchCallRequest) Execute() (*ApiV2010AccountCall, *http.Response, error) {
	return r.ApiService.FetchCallExecute(r)
}

/*
FetchCall Method for FetchCall

Fetch the call specified by the provided Call SID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to fetch.
 @param sid The SID of the Call resource to fetch.
 @return ApiFetchCallRequest
*/
func (a *DefaultApiService) FetchCall(ctx context.Context, accountSid string, sid string) ApiFetchCallRequest {
	return ApiFetchCallRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCall
func (a *DefaultApiService) FetchCallExecute(r ApiFetchCallRequest) (*ApiV2010AccountCall, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCallFeedbackRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
}

func (r ApiFetchCallFeedbackRequest) Execute() (*ApiV2010AccountCallCallFeedback, *http.Response, error) {
	return r.ApiService.FetchCallFeedbackExecute(r)
}

/*
FetchCallFeedback Method for FetchCallFeedback

Fetch a Feedback resource from a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param callSid The call sid that uniquely identifies the call
 @return ApiFetchCallFeedbackRequest
*/
func (a *DefaultApiService) FetchCallFeedback(ctx context.Context, accountSid string, callSid string) ApiFetchCallFeedbackRequest {
	return ApiFetchCallFeedbackRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallFeedback
func (a *DefaultApiService) FetchCallFeedbackExecute(r ApiFetchCallFeedbackRequest) (*ApiV2010AccountCallCallFeedback, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallFeedback
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchCallFeedback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCallFeedbackSummaryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchCallFeedbackSummaryRequest) Execute() (*ApiV2010AccountCallCallFeedbackSummary, *http.Response, error) {
	return r.ApiService.FetchCallFeedbackSummaryExecute(r)
}

/*
FetchCallFeedbackSummary Method for FetchCallFeedbackSummary

Fetch a FeedbackSummary resource from a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param sid A 34 character string that uniquely identifies this resource.
 @return ApiFetchCallFeedbackSummaryRequest
*/
func (a *DefaultApiService) FetchCallFeedbackSummary(ctx context.Context, accountSid string, sid string) ApiFetchCallFeedbackSummaryRequest {
	return ApiFetchCallFeedbackSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallFeedbackSummary
func (a *DefaultApiService) FetchCallFeedbackSummaryExecute(r ApiFetchCallFeedbackSummaryRequest) (*ApiV2010AccountCallCallFeedbackSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallFeedbackSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchCallFeedbackSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCallNotificationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
}

func (r ApiFetchCallNotificationRequest) Execute() (*ApiV2010AccountCallCallNotificationInstance, *http.Response, error) {
	return r.ApiService.FetchCallNotificationExecute(r)
}

/*
FetchCallNotification Method for FetchCallNotification



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call Notification resource to fetch.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the Call Notification resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Call Notification resource to fetch.
 @return ApiFetchCallNotificationRequest
*/
func (a *DefaultApiService) FetchCallNotification(ctx context.Context, accountSid string, callSid string, sid string) ApiFetchCallNotificationRequest {
	return ApiFetchCallNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallNotificationInstance
func (a *DefaultApiService) FetchCallNotificationExecute(r ApiFetchCallNotificationRequest) (*ApiV2010AccountCallCallNotificationInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallNotificationInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchCallNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCallRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
}

func (r ApiFetchCallRecordingRequest) Execute() (*ApiV2010AccountCallCallRecording, *http.Response, error) {
	return r.ApiService.FetchCallRecordingExecute(r)
}

/*
FetchCallRecording Method for FetchCallRecording

Fetch an instance of a recording for a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resource to fetch.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Recording resource to fetch.
 @return ApiFetchCallRecordingRequest
*/
func (a *DefaultApiService) FetchCallRecording(ctx context.Context, accountSid string, callSid string, sid string) ApiFetchCallRecordingRequest {
	return ApiFetchCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallRecording
func (a *DefaultApiService) FetchCallRecordingExecute(r ApiFetchCallRecordingRequest) (*ApiV2010AccountCallCallRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchConferenceRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchConferenceRequest) Execute() (*ApiV2010AccountConference, *http.Response, error) {
	return r.ApiService.FetchConferenceExecute(r)
}

/*
FetchConference Method for FetchConference

Fetch an instance of a conference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference resource(s) to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Conference resource to fetch
 @return ApiFetchConferenceRequest
*/
func (a *DefaultApiService) FetchConference(ctx context.Context, accountSid string, sid string) ApiFetchConferenceRequest {
	return ApiFetchConferenceRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConference
func (a *DefaultApiService) FetchConferenceExecute(r ApiFetchConferenceRequest) (*ApiV2010AccountConference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	sid string
}

func (r ApiFetchConferenceRecordingRequest) Execute() (*ApiV2010AccountConferenceConferenceRecording, *http.Response, error) {
	return r.ApiService.FetchConferenceRecordingExecute(r)
}

/*
FetchConferenceRecording Method for FetchConferenceRecording

Fetch an instance of a recording for a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resource to fetch.
 @param conferenceSid The Conference SID that identifies the conference associated with the recording to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Conference Recording resource to fetch.
 @return ApiFetchConferenceRecordingRequest
*/
func (a *DefaultApiService) FetchConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string) ApiFetchConferenceRecordingRequest {
	return ApiFetchConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConferenceConferenceRecording
func (a *DefaultApiService) FetchConferenceRecordingExecute(r ApiFetchConferenceRecordingRequest) (*ApiV2010AccountConferenceConferenceRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConferenceConferenceRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchConnectAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchConnectAppRequest) Execute() (*ApiV2010AccountConnectApp, *http.Response, error) {
	return r.ApiService.FetchConnectAppExecute(r)
}

/*
FetchConnectApp Method for FetchConnectApp

Fetch an instance of a connect-app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the ConnectApp resource to fetch.
 @return ApiFetchConnectAppRequest
*/
func (a *DefaultApiService) FetchConnectApp(ctx context.Context, accountSid string, sid string) ApiFetchConnectAppRequest {
	return ApiFetchConnectAppRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConnectApp
func (a *DefaultApiService) FetchConnectAppExecute(r ApiFetchConnectAppRequest) (*ApiV2010AccountConnectApp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConnectApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchConnectApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchIncomingPhoneNumberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchIncomingPhoneNumberRequest) Execute() (*ApiV2010AccountIncomingPhoneNumber, *http.Response, error) {
	return r.ApiService.FetchIncomingPhoneNumberExecute(r)
}

/*
FetchIncomingPhoneNumber Method for FetchIncomingPhoneNumber

Fetch an incoming-phone-number belonging to the account used to make the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the IncomingPhoneNumber resource to fetch.
 @return ApiFetchIncomingPhoneNumberRequest
*/
func (a *DefaultApiService) FetchIncomingPhoneNumber(ctx context.Context, accountSid string, sid string) ApiFetchIncomingPhoneNumberRequest {
	return ApiFetchIncomingPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumber
func (a *DefaultApiService) FetchIncomingPhoneNumberExecute(r ApiFetchIncomingPhoneNumberRequest) (*ApiV2010AccountIncomingPhoneNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchIncomingPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchIncomingPhoneNumberAssignedAddOnRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	resourceSid string
	sid string
}

func (r ApiFetchIncomingPhoneNumberAssignedAddOnRequest) Execute() (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn, *http.Response, error) {
	return r.ApiService.FetchIncomingPhoneNumberAssignedAddOnExecute(r)
}

/*
FetchIncomingPhoneNumberAssignedAddOn Method for FetchIncomingPhoneNumberAssignedAddOn

Fetch an instance of an Add-on installation currently assigned to this Number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resource to fetch.
 @param resourceSid The SID of the Phone Number to which the Add-on is assigned.
 @param sid The Twilio-provided string that uniquely identifies the resource to fetch.
 @return ApiFetchIncomingPhoneNumberAssignedAddOnRequest
*/
func (a *DefaultApiService) FetchIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, sid string) ApiFetchIncomingPhoneNumberAssignedAddOnRequest {
	return ApiFetchIncomingPhoneNumberAssignedAddOnRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		resourceSid: resourceSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
func (a *DefaultApiService) FetchIncomingPhoneNumberAssignedAddOnExecute(r ApiFetchIncomingPhoneNumberAssignedAddOnRequest) (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchIncomingPhoneNumberAssignedAddOn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ResourceSid"+"}", url.PathEscape(parameterToString(r.resourceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.resourceSid) < 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have at least 34 elements")
	}
	if strlen(r.resourceSid) > 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchIncomingPhoneNumberAssignedAddOnExtensionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	resourceSid string
	assignedAddOnSid string
	sid string
}

func (r ApiFetchIncomingPhoneNumberAssignedAddOnExtensionRequest) Execute() (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension, *http.Response, error) {
	return r.ApiService.FetchIncomingPhoneNumberAssignedAddOnExtensionExecute(r)
}

/*
FetchIncomingPhoneNumberAssignedAddOnExtension Method for FetchIncomingPhoneNumberAssignedAddOnExtension

Fetch an instance of an Extension for the Assigned Add-on.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resource to fetch.
 @param resourceSid The SID of the Phone Number to which the Add-on is assigned.
 @param assignedAddOnSid The SID that uniquely identifies the assigned Add-on installation.
 @param sid The Twilio-provided string that uniquely identifies the resource to fetch.
 @return ApiFetchIncomingPhoneNumberAssignedAddOnExtensionRequest
*/
func (a *DefaultApiService) FetchIncomingPhoneNumberAssignedAddOnExtension(ctx context.Context, accountSid string, resourceSid string, assignedAddOnSid string, sid string) ApiFetchIncomingPhoneNumberAssignedAddOnExtensionRequest {
	return ApiFetchIncomingPhoneNumberAssignedAddOnExtensionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		resourceSid: resourceSid,
		assignedAddOnSid: assignedAddOnSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension
func (a *DefaultApiService) FetchIncomingPhoneNumberAssignedAddOnExtensionExecute(r ApiFetchIncomingPhoneNumberAssignedAddOnExtensionRequest) (*ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchIncomingPhoneNumberAssignedAddOnExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ResourceSid"+"}", url.PathEscape(parameterToString(r.resourceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AssignedAddOnSid"+"}", url.PathEscape(parameterToString(r.assignedAddOnSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.resourceSid) < 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have at least 34 elements")
	}
	if strlen(r.resourceSid) > 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have less than 34 elements")
	}
	if strlen(r.assignedAddOnSid) < 34 {
		return localVarReturnValue, nil, reportError("assignedAddOnSid must have at least 34 elements")
	}
	if strlen(r.assignedAddOnSid) > 34 {
		return localVarReturnValue, nil, reportError("assignedAddOnSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchKeyRequest) Execute() (*ApiV2010AccountKey, *http.Response, error) {
	return r.ApiService.FetchKeyExecute(r)
}

/*
FetchKey Method for FetchKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Key resource to fetch.
 @return ApiFetchKeyRequest
*/
func (a *DefaultApiService) FetchKey(ctx context.Context, accountSid string, sid string) ApiFetchKeyRequest {
	return ApiFetchKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountKey
func (a *DefaultApiService) FetchKeyExecute(r ApiFetchKeyRequest) (*ApiV2010AccountKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchMediaRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	messageSid string
	sid string
}

func (r ApiFetchMediaRequest) Execute() (*ApiV2010AccountMessageMedia, *http.Response, error) {
	return r.ApiService.FetchMediaExecute(r)
}

/*
FetchMedia Method for FetchMedia

Fetch a single media instance belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Media resource(s) to fetch.
 @param messageSid The SID of the Message resource that this Media resource belongs to.
 @param sid The Twilio-provided string that uniquely identifies the Media resource to fetch
 @return ApiFetchMediaRequest
*/
func (a *DefaultApiService) FetchMedia(ctx context.Context, accountSid string, messageSid string, sid string) ApiFetchMediaRequest {
	return ApiFetchMediaRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		messageSid: messageSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountMessageMedia
func (a *DefaultApiService) FetchMediaExecute(r ApiFetchMediaRequest) (*ApiV2010AccountMessageMedia, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountMessageMedia
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MessageSid"+"}", url.PathEscape(parameterToString(r.messageSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.messageSid) < 34 {
		return localVarReturnValue, nil, reportError("messageSid must have at least 34 elements")
	}
	if strlen(r.messageSid) > 34 {
		return localVarReturnValue, nil, reportError("messageSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchMemberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	queueSid string
	callSid string
}

func (r ApiFetchMemberRequest) Execute() (*ApiV2010AccountQueueMember, *http.Response, error) {
	return r.ApiService.FetchMemberExecute(r)
}

/*
FetchMember Method for FetchMember

Fetch a specific member from the queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Member resource(s) to fetch.
 @param queueSid The SID of the Queue in which to find the members to fetch.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource(s) to fetch.
 @return ApiFetchMemberRequest
*/
func (a *DefaultApiService) FetchMember(ctx context.Context, accountSid string, queueSid string, callSid string) ApiFetchMemberRequest {
	return ApiFetchMemberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		queueSid: queueSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountQueueMember
func (a *DefaultApiService) FetchMemberExecute(r ApiFetchMemberRequest) (*ApiV2010AccountQueueMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountQueueMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"QueueSid"+"}", url.PathEscape(parameterToString(r.queueSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.queueSid) < 34 {
		return localVarReturnValue, nil, reportError("queueSid must have at least 34 elements")
	}
	if strlen(r.queueSid) > 34 {
		return localVarReturnValue, nil, reportError("queueSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchMessageRequest) Execute() (*ApiV2010AccountMessage, *http.Response, error) {
	return r.ApiService.FetchMessageExecute(r)
}

/*
FetchMessage Method for FetchMessage

Fetch a message belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Message resource to fetch.
 @return ApiFetchMessageRequest
*/
func (a *DefaultApiService) FetchMessage(ctx context.Context, accountSid string, sid string) ApiFetchMessageRequest {
	return ApiFetchMessageRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountMessage
func (a *DefaultApiService) FetchMessageExecute(r ApiFetchMessageRequest) (*ApiV2010AccountMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchNotificationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchNotificationRequest) Execute() (*ApiV2010AccountNotificationInstance, *http.Response, error) {
	return r.ApiService.FetchNotificationExecute(r)
}

/*
FetchNotification Method for FetchNotification

Fetch a notification belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Notification resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Notification resource to fetch.
 @return ApiFetchNotificationRequest
*/
func (a *DefaultApiService) FetchNotification(ctx context.Context, accountSid string, sid string) ApiFetchNotificationRequest {
	return ApiFetchNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountNotificationInstance
func (a *DefaultApiService) FetchNotificationExecute(r ApiFetchNotificationRequest) (*ApiV2010AccountNotificationInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountNotificationInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchOutgoingCallerIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchOutgoingCallerIdRequest) Execute() (*ApiV2010AccountOutgoingCallerId, *http.Response, error) {
	return r.ApiService.FetchOutgoingCallerIdExecute(r)
}

/*
FetchOutgoingCallerId Method for FetchOutgoingCallerId

Fetch an outgoing-caller-id belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the OutgoingCallerId resource to fetch.
 @return ApiFetchOutgoingCallerIdRequest
*/
func (a *DefaultApiService) FetchOutgoingCallerId(ctx context.Context, accountSid string, sid string) ApiFetchOutgoingCallerIdRequest {
	return ApiFetchOutgoingCallerIdRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountOutgoingCallerId
func (a *DefaultApiService) FetchOutgoingCallerIdExecute(r ApiFetchOutgoingCallerIdRequest) (*ApiV2010AccountOutgoingCallerId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountOutgoingCallerId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchOutgoingCallerId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchParticipantRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	callSid string
}

func (r ApiFetchParticipantRequest) Execute() (*ApiV2010AccountConferenceParticipant, *http.Response, error) {
	return r.ApiService.FetchParticipantExecute(r)
}

/*
FetchParticipant Method for FetchParticipant

Fetch an instance of a participant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resource to fetch.
 @param conferenceSid The SID of the conference with the participant to fetch.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to fetch. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
 @return ApiFetchParticipantRequest
*/
func (a *DefaultApiService) FetchParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string) ApiFetchParticipantRequest {
	return ApiFetchParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConferenceParticipant
func (a *DefaultApiService) FetchParticipantExecute(r ApiFetchParticipantRequest) (*ApiV2010AccountConferenceParticipant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConferenceParticipant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchQueueRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchQueueRequest) Execute() (*ApiV2010AccountQueue, *http.Response, error) {
	return r.ApiService.FetchQueueExecute(r)
}

/*
FetchQueue Method for FetchQueue

Fetch an instance of a queue identified by the QueueSid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Queue resource to fetch
 @return ApiFetchQueueRequest
*/
func (a *DefaultApiService) FetchQueue(ctx context.Context, accountSid string, sid string) ApiFetchQueueRequest {
	return ApiFetchQueueRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountQueue
func (a *DefaultApiService) FetchQueueExecute(r ApiFetchQueueRequest) (*ApiV2010AccountQueue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountQueue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	includeSoftDeleted *bool
}

// A boolean parameter indicating whether to retrieve soft deleted recordings or not. Recordings metadata are kept after deletion for a retention period of 40 days.
func (r ApiFetchRecordingRequest) IncludeSoftDeleted(includeSoftDeleted bool) ApiFetchRecordingRequest {
	r.includeSoftDeleted = &includeSoftDeleted
	return r
}

func (r ApiFetchRecordingRequest) Execute() (*ApiV2010AccountRecording, *http.Response, error) {
	return r.ApiService.FetchRecordingExecute(r)
}

/*
FetchRecording Method for FetchRecording

Fetch an instance of a recording

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Recording resource to fetch.
 @return ApiFetchRecordingRequest
*/
func (a *DefaultApiService) FetchRecording(ctx context.Context, accountSid string, sid string) ApiFetchRecordingRequest {
	return ApiFetchRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountRecording
func (a *DefaultApiService) FetchRecordingExecute(r ApiFetchRecordingRequest) (*ApiV2010AccountRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	if r.includeSoftDeleted != nil {
		localVarQueryParams.Add("IncludeSoftDeleted", parameterToString(*r.includeSoftDeleted, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchRecordingAddOnResultRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	referenceSid string
	sid string
}

func (r ApiFetchRecordingAddOnResultRequest) Execute() (*ApiV2010AccountRecordingRecordingAddOnResult, *http.Response, error) {
	return r.ApiService.FetchRecordingAddOnResultExecute(r)
}

/*
FetchRecordingAddOnResult Method for FetchRecordingAddOnResult

Fetch an instance of an AddOnResult

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult resource to fetch.
 @param referenceSid The SID of the recording to which the result to fetch belongs.
 @param sid The Twilio-provided string that uniquely identifies the Recording AddOnResult resource to fetch.
 @return ApiFetchRecordingAddOnResultRequest
*/
func (a *DefaultApiService) FetchRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, sid string) ApiFetchRecordingAddOnResultRequest {
	return ApiFetchRecordingAddOnResultRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		referenceSid: referenceSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountRecordingRecordingAddOnResult
func (a *DefaultApiService) FetchRecordingAddOnResultExecute(r ApiFetchRecordingAddOnResultRequest) (*ApiV2010AccountRecordingRecordingAddOnResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountRecordingRecordingAddOnResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchRecordingAddOnResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ReferenceSid"+"}", url.PathEscape(parameterToString(r.referenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.referenceSid) < 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have at least 34 elements")
	}
	if strlen(r.referenceSid) > 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchRecordingAddOnResultPayloadRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	referenceSid string
	addOnResultSid string
	sid string
}

func (r ApiFetchRecordingAddOnResultPayloadRequest) Execute() (*ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload, *http.Response, error) {
	return r.ApiService.FetchRecordingAddOnResultPayloadExecute(r)
}

/*
FetchRecordingAddOnResultPayload Method for FetchRecordingAddOnResultPayload

Fetch an instance of a result payload

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult Payload resource to fetch.
 @param referenceSid The SID of the recording to which the AddOnResult resource that contains the payload to fetch belongs.
 @param addOnResultSid The SID of the AddOnResult to which the payload to fetch belongs.
 @param sid The Twilio-provided string that uniquely identifies the Recording AddOnResult Payload resource to fetch.
 @return ApiFetchRecordingAddOnResultPayloadRequest
*/
func (a *DefaultApiService) FetchRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, sid string) ApiFetchRecordingAddOnResultPayloadRequest {
	return ApiFetchRecordingAddOnResultPayloadRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		referenceSid: referenceSid,
		addOnResultSid: addOnResultSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload
func (a *DefaultApiService) FetchRecordingAddOnResultPayloadExecute(r ApiFetchRecordingAddOnResultPayloadRequest) (*ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchRecordingAddOnResultPayload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ReferenceSid"+"}", url.PathEscape(parameterToString(r.referenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AddOnResultSid"+"}", url.PathEscape(parameterToString(r.addOnResultSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.referenceSid) < 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have at least 34 elements")
	}
	if strlen(r.referenceSid) > 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have less than 34 elements")
	}
	if strlen(r.addOnResultSid) < 34 {
		return localVarReturnValue, nil, reportError("addOnResultSid must have at least 34 elements")
	}
	if strlen(r.addOnResultSid) > 34 {
		return localVarReturnValue, nil, reportError("addOnResultSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchRecordingTranscriptionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	recordingSid string
	sid string
}

func (r ApiFetchRecordingTranscriptionRequest) Execute() (*ApiV2010AccountRecordingRecordingTranscription, *http.Response, error) {
	return r.ApiService.FetchRecordingTranscriptionExecute(r)
}

/*
FetchRecordingTranscription Method for FetchRecordingTranscription



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resource to fetch.
 @param recordingSid The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) that created the transcription to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Transcription resource to fetch.
 @return ApiFetchRecordingTranscriptionRequest
*/
func (a *DefaultApiService) FetchRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, sid string) ApiFetchRecordingTranscriptionRequest {
	return ApiFetchRecordingTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingSid: recordingSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountRecordingRecordingTranscription
func (a *DefaultApiService) FetchRecordingTranscriptionExecute(r ApiFetchRecordingTranscriptionRequest) (*ApiV2010AccountRecordingRecordingTranscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountRecordingRecordingTranscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchRecordingTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"RecordingSid"+"}", url.PathEscape(parameterToString(r.recordingSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.recordingSid) < 34 {
		return localVarReturnValue, nil, reportError("recordingSid must have at least 34 elements")
	}
	if strlen(r.recordingSid) > 34 {
		return localVarReturnValue, nil, reportError("recordingSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchShortCodeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchShortCodeRequest) Execute() (*ApiV2010AccountShortCode, *http.Response, error) {
	return r.ApiService.FetchShortCodeExecute(r)
}

/*
FetchShortCode Method for FetchShortCode

Fetch an instance of a short code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ShortCode resource(s) to fetch.
 @param sid The Twilio-provided string that uniquely identifies the ShortCode resource to fetch
 @return ApiFetchShortCodeRequest
*/
func (a *DefaultApiService) FetchShortCode(ctx context.Context, accountSid string, sid string) ApiFetchShortCodeRequest {
	return ApiFetchShortCodeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountShortCode
func (a *DefaultApiService) FetchShortCodeExecute(r ApiFetchShortCodeRequest) (*ApiV2010AccountShortCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountShortCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchShortCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSigningKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchSigningKeyRequest) Execute() (*ApiV2010AccountSigningKey, *http.Response, error) {
	return r.ApiService.FetchSigningKeyExecute(r)
}

/*
FetchSigningKey Method for FetchSigningKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid 
 @param sid 
 @return ApiFetchSigningKeyRequest
*/
func (a *DefaultApiService) FetchSigningKey(ctx context.Context, accountSid string, sid string) ApiFetchSigningKeyRequest {
	return ApiFetchSigningKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSigningKey
func (a *DefaultApiService) FetchSigningKeyExecute(r ApiFetchSigningKeyRequest) (*ApiV2010AccountSigningKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSigningKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSigningKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipAuthCallsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiFetchSipAuthCallsCredentialListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping, *http.Response, error) {
	return r.ApiService.FetchSipAuthCallsCredentialListMappingExecute(r)
}

/*
FetchSipAuthCallsCredentialListMapping Method for FetchSipAuthCallsCredentialListMapping

Fetch a specific instance of a credential list mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resource to fetch.
 @param domainSid The SID of the SIP domain that contains the resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the CredentialListMapping resource to fetch.
 @return ApiFetchSipAuthCallsCredentialListMappingRequest
*/
func (a *DefaultApiService) FetchSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiFetchSipAuthCallsCredentialListMappingRequest {
	return ApiFetchSipAuthCallsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
func (a *DefaultApiService) FetchSipAuthCallsCredentialListMappingExecute(r ApiFetchSipAuthCallsCredentialListMappingRequest) (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipAuthCallsCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipAuthCallsIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiFetchSipAuthCallsIpAccessControlListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping, *http.Response, error) {
	return r.ApiService.FetchSipAuthCallsIpAccessControlListMappingExecute(r)
}

/*
FetchSipAuthCallsIpAccessControlListMapping Method for FetchSipAuthCallsIpAccessControlListMapping

Fetch a specific instance of an IP Access Control List mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlListMapping resource to fetch.
 @param domainSid The SID of the SIP domain that contains the resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the IpAccessControlListMapping resource to fetch.
 @return ApiFetchSipAuthCallsIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) FetchSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiFetchSipAuthCallsIpAccessControlListMappingRequest {
	return ApiFetchSipAuthCallsIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
func (a *DefaultApiService) FetchSipAuthCallsIpAccessControlListMappingExecute(r ApiFetchSipAuthCallsIpAccessControlListMappingRequest) (*ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipAuthCallsIpAccessControlListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipAuthRegistrationsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiFetchSipAuthRegistrationsCredentialListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping, *http.Response, error) {
	return r.ApiService.FetchSipAuthRegistrationsCredentialListMappingExecute(r)
}

/*
FetchSipAuthRegistrationsCredentialListMapping Method for FetchSipAuthRegistrationsCredentialListMapping

Fetch a specific instance of a credential list mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resource to fetch.
 @param domainSid The SID of the SIP domain that contains the resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the CredentialListMapping resource to fetch.
 @return ApiFetchSipAuthRegistrationsCredentialListMappingRequest
*/
func (a *DefaultApiService) FetchSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiFetchSipAuthRegistrationsCredentialListMappingRequest {
	return ApiFetchSipAuthRegistrationsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
func (a *DefaultApiService) FetchSipAuthRegistrationsCredentialListMappingExecute(r ApiFetchSipAuthRegistrationsCredentialListMappingRequest) (*ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipAuthRegistrationsCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipCredentialRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	credentialListSid string
	sid string
}

func (r ApiFetchSipCredentialRequest) Execute() (*ApiV2010AccountSipSipCredentialListSipCredential, *http.Response, error) {
	return r.ApiService.FetchSipCredentialExecute(r)
}

/*
FetchSipCredential Method for FetchSipCredential

Fetch a single credential.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param credentialListSid The unique id that identifies the credential list that contains the desired credential.
 @param sid The unique id that identifies the resource to fetch.
 @return ApiFetchSipCredentialRequest
*/
func (a *DefaultApiService) FetchSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string) ApiFetchSipCredentialRequest {
	return ApiFetchSipCredentialRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		credentialListSid: credentialListSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipCredentialListSipCredential
func (a *DefaultApiService) FetchSipCredentialExecute(r ApiFetchSipCredentialRequest) (*ApiV2010AccountSipSipCredentialListSipCredential, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipCredentialListSipCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CredentialListSid"+"}", url.PathEscape(parameterToString(r.credentialListSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipCredentialListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchSipCredentialListRequest) Execute() (*ApiV2010AccountSipSipCredentialList, *http.Response, error) {
	return r.ApiService.FetchSipCredentialListExecute(r)
}

/*
FetchSipCredentialList Method for FetchSipCredentialList

Get a Credential List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param sid The credential list Sid that uniquely identifies this resource
 @return ApiFetchSipCredentialListRequest
*/
func (a *DefaultApiService) FetchSipCredentialList(ctx context.Context, accountSid string, sid string) ApiFetchSipCredentialListRequest {
	return ApiFetchSipCredentialListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipCredentialList
func (a *DefaultApiService) FetchSipCredentialListExecute(r ApiFetchSipCredentialListRequest) (*ApiV2010AccountSipSipCredentialList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipCredentialList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipCredentialList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiFetchSipCredentialListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipCredentialListMapping, *http.Response, error) {
	return r.ApiService.FetchSipCredentialListMappingExecute(r)
}

/*
FetchSipCredentialListMapping Method for FetchSipCredentialListMapping

Fetch a single CredentialListMapping resource from an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP Domain that includes the resource to fetch.
 @param sid A 34 character string that uniquely identifies the resource to fetch.
 @return ApiFetchSipCredentialListMappingRequest
*/
func (a *DefaultApiService) FetchSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiFetchSipCredentialListMappingRequest {
	return ApiFetchSipCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipCredentialListMapping
func (a *DefaultApiService) FetchSipCredentialListMappingExecute(r ApiFetchSipCredentialListMappingRequest) (*ApiV2010AccountSipSipDomainSipCredentialListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipCredentialListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipDomainRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchSipDomainRequest) Execute() (*ApiV2010AccountSipSipDomain, *http.Response, error) {
	return r.ApiService.FetchSipDomainExecute(r)
}

/*
FetchSipDomain Method for FetchSipDomain

Fetch an instance of a Domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the SipDomain resource to fetch.
 @return ApiFetchSipDomainRequest
*/
func (a *DefaultApiService) FetchSipDomain(ctx context.Context, accountSid string, sid string) ApiFetchSipDomainRequest {
	return ApiFetchSipDomainRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomain
func (a *DefaultApiService) FetchSipDomainExecute(r ApiFetchSipDomainRequest) (*ApiV2010AccountSipSipDomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipIpAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchSipIpAccessControlListRequest) Execute() (*ApiV2010AccountSipSipIpAccessControlList, *http.Response, error) {
	return r.ApiService.FetchSipIpAccessControlListExecute(r)
}

/*
FetchSipIpAccessControlList Method for FetchSipIpAccessControlList

Fetch a specific instance of an IpAccessControlList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param sid A 34 character string that uniquely identifies the resource to fetch.
 @return ApiFetchSipIpAccessControlListRequest
*/
func (a *DefaultApiService) FetchSipIpAccessControlList(ctx context.Context, accountSid string, sid string) ApiFetchSipIpAccessControlListRequest {
	return ApiFetchSipIpAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipIpAccessControlList
func (a *DefaultApiService) FetchSipIpAccessControlListExecute(r ApiFetchSipIpAccessControlListRequest) (*ApiV2010AccountSipSipIpAccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipIpAccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipIpAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	sid string
}

func (r ApiFetchSipIpAccessControlListMappingRequest) Execute() (*ApiV2010AccountSipSipDomainSipIpAccessControlListMapping, *http.Response, error) {
	return r.ApiService.FetchSipIpAccessControlListMappingExecute(r)
}

/*
FetchSipIpAccessControlListMapping Method for FetchSipIpAccessControlListMapping

Fetch an IpAccessControlListMapping resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP domain.
 @param sid A 34 character string that uniquely identifies the resource to fetch.
 @return ApiFetchSipIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) FetchSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string) ApiFetchSipIpAccessControlListMappingRequest {
	return ApiFetchSipIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
func (a *DefaultApiService) FetchSipIpAccessControlListMappingExecute(r ApiFetchSipIpAccessControlListMappingRequest) (*ApiV2010AccountSipSipDomainSipIpAccessControlListMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipIpAccessControlListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchSipIpAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	ipAccessControlListSid string
	sid string
}

func (r ApiFetchSipIpAddressRequest) Execute() (*ApiV2010AccountSipSipIpAccessControlListSipIpAddress, *http.Response, error) {
	return r.ApiService.FetchSipIpAddressExecute(r)
}

/*
FetchSipIpAddress Method for FetchSipIpAddress

Read one IpAddress resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param ipAccessControlListSid The IpAccessControlList Sid that identifies the IpAddress resources to fetch.
 @param sid A 34 character string that uniquely identifies the IpAddress resource to fetch.
 @return ApiFetchSipIpAddressRequest
*/
func (a *DefaultApiService) FetchSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string) ApiFetchSipIpAddressRequest {
	return ApiFetchSipIpAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		ipAccessControlListSid: ipAccessControlListSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipIpAccessControlListSipIpAddress
func (a *DefaultApiService) FetchSipIpAddressExecute(r ApiFetchSipIpAddressRequest) (*ApiV2010AccountSipSipIpAccessControlListSipIpAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipIpAccessControlListSipIpAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchSipIpAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"IpAccessControlListSid"+"}", url.PathEscape(parameterToString(r.ipAccessControlListSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.ipAccessControlListSid) < 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(r.ipAccessControlListSid) > 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchTranscriptionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchTranscriptionRequest) Execute() (*ApiV2010AccountTranscription, *http.Response, error) {
	return r.ApiService.FetchTranscriptionExecute(r)
}

/*
FetchTranscription Method for FetchTranscription

Fetch an instance of a Transcription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the Transcription resource to fetch.
 @return ApiFetchTranscriptionRequest
*/
func (a *DefaultApiService) FetchTranscription(ctx context.Context, accountSid string, sid string) ApiFetchTranscriptionRequest {
	return ApiFetchTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountTranscription
func (a *DefaultApiService) FetchTranscriptionExecute(r ApiFetchTranscriptionRequest) (*ApiV2010AccountTranscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountTranscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchUsageTriggerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
}

func (r ApiFetchUsageTriggerRequest) Execute() (*ApiV2010AccountUsageUsageTrigger, *http.Response, error) {
	return r.ApiService.FetchUsageTriggerExecute(r)
}

/*
FetchUsageTrigger Method for FetchUsageTrigger

Fetch and instance of a usage-trigger

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resource to fetch.
 @param sid The Twilio-provided string that uniquely identifies the UsageTrigger resource to fetch.
 @return ApiFetchUsageTriggerRequest
*/
func (a *DefaultApiService) FetchUsageTrigger(ctx context.Context, accountSid string, sid string) ApiFetchUsageTriggerRequest {
	return ApiFetchUsageTriggerRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountUsageUsageTrigger
func (a *DefaultApiService) FetchUsageTriggerExecute(r ApiFetchUsageTriggerRequest) (*ApiV2010AccountUsageUsageTrigger, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountUsageUsageTrigger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.FetchUsageTrigger")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	friendlyName *string
	status *string
	pageSize *int32
}

// Only return the Account resources with friendly names that exactly match this name.
func (r ApiListAccountRequest) FriendlyName(friendlyName string) ApiListAccountRequest {
	r.friendlyName = &friendlyName
	return r
}

// Only return Account resources with the given status. Can be &#x60;closed&#x60;, &#x60;suspended&#x60; or &#x60;active&#x60;.
func (r ApiListAccountRequest) Status(status string) ApiListAccountRequest {
	r.status = &status
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAccountRequest) PageSize(pageSize int32) ApiListAccountRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAccountRequest) Execute() (*ListAccountResponse, *http.Response, error) {
	return r.ApiService.ListAccountExecute(r)
}

/*
ListAccount Method for ListAccount

Retrieves a collection of Accounts belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAccountRequest
*/
func (a *DefaultApiService) ListAccount(ctx context.Context) ApiListAccountRequest {
	return ApiListAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAccountResponse
func (a *DefaultApiService) ListAccountExecute(r ApiListAccountRequest) (*ListAccountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAccountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("Status", parameterToString(*r.status, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	customerName *string
	friendlyName *string
	isoCountry *string
	pageSize *int32
}

// The &#x60;customer_name&#x60; of the Address resources to read.
func (r ApiListAddressRequest) CustomerName(customerName string) ApiListAddressRequest {
	r.customerName = &customerName
	return r
}

// The string that identifies the Address resources to read.
func (r ApiListAddressRequest) FriendlyName(friendlyName string) ApiListAddressRequest {
	r.friendlyName = &friendlyName
	return r
}

// The ISO country code of the Address resources to read.
func (r ApiListAddressRequest) IsoCountry(isoCountry string) ApiListAddressRequest {
	r.isoCountry = &isoCountry
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAddressRequest) PageSize(pageSize int32) ApiListAddressRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAddressRequest) Execute() (*ListAddressResponse, *http.Response, error) {
	return r.ApiService.ListAddressExecute(r)
}

/*
ListAddress Method for ListAddress



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to read.
 @return ApiListAddressRequest
*/
func (a *DefaultApiService) ListAddress(ctx context.Context, accountSid string) ApiListAddressRequest {
	return ApiListAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListAddressResponse
func (a *DefaultApiService) ListAddressExecute(r ApiListAddressRequest) (*ListAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Addresses.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.customerName != nil {
		localVarQueryParams.Add("CustomerName", parameterToString(*r.customerName, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.isoCountry != nil {
		localVarQueryParams.Add("IsoCountry", parameterToString(*r.isoCountry, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
	pageSize *int32
}

// The string that identifies the Application resources to read.
func (r ApiListApplicationRequest) FriendlyName(friendlyName string) ApiListApplicationRequest {
	r.friendlyName = &friendlyName
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListApplicationRequest) PageSize(pageSize int32) ApiListApplicationRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListApplicationRequest) Execute() (*ListApplicationResponse, *http.Response, error) {
	return r.ApiService.ListApplicationExecute(r)
}

/*
ListApplication Method for ListApplication

Retrieve a list of applications representing an application within the requesting account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resources to read.
 @return ApiListApplicationRequest
*/
func (a *DefaultApiService) ListApplication(ctx context.Context, accountSid string) ApiListApplicationRequest {
	return ApiListApplicationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListApplicationResponse
func (a *DefaultApiService) ListApplicationExecute(r ApiListApplicationRequest) (*ListApplicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApplicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Applications.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuthorizedConnectAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAuthorizedConnectAppRequest) PageSize(pageSize int32) ApiListAuthorizedConnectAppRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAuthorizedConnectAppRequest) Execute() (*ListAuthorizedConnectAppResponse, *http.Response, error) {
	return r.ApiService.ListAuthorizedConnectAppExecute(r)
}

/*
ListAuthorizedConnectApp Method for ListAuthorizedConnectApp

Retrieve a list of authorized-connect-apps belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the AuthorizedConnectApp resources to read.
 @return ApiListAuthorizedConnectAppRequest
*/
func (a *DefaultApiService) ListAuthorizedConnectApp(ctx context.Context, accountSid string) ApiListAuthorizedConnectAppRequest {
	return ApiListAuthorizedConnectAppRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListAuthorizedConnectAppResponse
func (a *DefaultApiService) ListAuthorizedConnectAppExecute(r ApiListAuthorizedConnectAppRequest) (*ListAuthorizedConnectAppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAuthorizedConnectAppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAuthorizedConnectApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberCountryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberCountryRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberCountryRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberCountryRequest) Execute() (*ListAvailablePhoneNumberCountryResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberCountryExecute(r)
}

/*
ListAvailablePhoneNumberCountry Method for ListAvailablePhoneNumberCountry



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the available phone number Country resources.
 @return ApiListAvailablePhoneNumberCountryRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberCountry(ctx context.Context, accountSid string) ApiListAvailablePhoneNumberCountryRequest {
	return ApiListAvailablePhoneNumberCountryRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberCountryResponse
func (a *DefaultApiService) ListAvailablePhoneNumberCountryExecute(r ApiListAvailablePhoneNumberCountryRequest) (*ListAvailablePhoneNumberCountryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberCountryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberCountry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberLocalRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberLocalRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumberlocal-resource?code-sample&#x3D;code-find-phone-numbers-by-number-pattern) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumberlocal-resource?code-sample&#x3D;code-find-phone-numbers-by-character-pattern). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberLocalRequest) Contains(contains string) ApiListAvailablePhoneNumberLocalRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberLocalRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberLocalRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberLocalRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberLocalRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberLocalRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberLocalRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) Beta(beta bool) ApiListAvailablePhoneNumberLocalRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberLocalRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberLocalRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) Distance(distance int32) ApiListAvailablePhoneNumberLocalRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberLocalRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberLocalRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberLocalRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberLocalRequest) InLata(inLata string) ApiListAvailablePhoneNumberLocalRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberLocalRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberLocalRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberLocalRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberLocalRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberLocalRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberLocalRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberLocalRequest) Execute() (*ListAvailablePhoneNumberLocalResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberLocalExecute(r)
}

/*
ListAvailablePhoneNumberLocal Method for ListAvailablePhoneNumberLocal



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberLocalRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberLocal(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberLocalRequest {
	return ApiListAvailablePhoneNumberLocalRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberLocalResponse
func (a *DefaultApiService) ListAvailablePhoneNumberLocalExecute(r ApiListAvailablePhoneNumberLocalRequest) (*ListAvailablePhoneNumberLocalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberLocalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberLocal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberMachineToMachineRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) Contains(contains string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) Beta(beta bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) Distance(distance int32) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) InLata(inLata string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberMachineToMachineRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberMachineToMachineRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberMachineToMachineRequest) Execute() (*ListAvailablePhoneNumberMachineToMachineResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberMachineToMachineExecute(r)
}

/*
ListAvailablePhoneNumberMachineToMachine Method for ListAvailablePhoneNumberMachineToMachine



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberMachineToMachineRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberMachineToMachine(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberMachineToMachineRequest {
	return ApiListAvailablePhoneNumberMachineToMachineRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberMachineToMachineResponse
func (a *DefaultApiService) ListAvailablePhoneNumberMachineToMachineExecute(r ApiListAvailablePhoneNumberMachineToMachineRequest) (*ListAvailablePhoneNumberMachineToMachineResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberMachineToMachineResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberMachineToMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberMobileRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberMobileRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberMobileRequest) Contains(contains string) ApiListAvailablePhoneNumberMobileRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberMobileRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberMobileRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberMobileRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberMobileRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberMobileRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberMobileRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) Beta(beta bool) ApiListAvailablePhoneNumberMobileRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberMobileRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberMobileRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) Distance(distance int32) ApiListAvailablePhoneNumberMobileRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberMobileRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberMobileRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberMobileRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberMobileRequest) InLata(inLata string) ApiListAvailablePhoneNumberMobileRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberMobileRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberMobileRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberMobileRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberMobileRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberMobileRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberMobileRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberMobileRequest) Execute() (*ListAvailablePhoneNumberMobileResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberMobileExecute(r)
}

/*
ListAvailablePhoneNumberMobile Method for ListAvailablePhoneNumberMobile



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberMobileRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberMobile(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberMobileRequest {
	return ApiListAvailablePhoneNumberMobileRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberMobileResponse
func (a *DefaultApiService) ListAvailablePhoneNumberMobileExecute(r ApiListAvailablePhoneNumberMobileRequest) (*ListAvailablePhoneNumberMobileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberMobileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberMobile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberNationalRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberNationalRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberNationalRequest) Contains(contains string) ApiListAvailablePhoneNumberNationalRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberNationalRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberNationalRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberNationalRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberNationalRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberNationalRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberNationalRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) Beta(beta bool) ApiListAvailablePhoneNumberNationalRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberNationalRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberNationalRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) Distance(distance int32) ApiListAvailablePhoneNumberNationalRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberNationalRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberNationalRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberNationalRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberNationalRequest) InLata(inLata string) ApiListAvailablePhoneNumberNationalRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberNationalRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberNationalRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberNationalRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberNationalRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberNationalRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberNationalRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberNationalRequest) Execute() (*ListAvailablePhoneNumberNationalResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberNationalExecute(r)
}

/*
ListAvailablePhoneNumberNational Method for ListAvailablePhoneNumberNational



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberNationalRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberNational(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberNationalRequest {
	return ApiListAvailablePhoneNumberNationalRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberNationalResponse
func (a *DefaultApiService) ListAvailablePhoneNumberNationalExecute(r ApiListAvailablePhoneNumberNationalRequest) (*ListAvailablePhoneNumberNationalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberNationalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberNational")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberSharedCostRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberSharedCostRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberSharedCostRequest) Contains(contains string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) Beta(beta bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) Distance(distance int32) ApiListAvailablePhoneNumberSharedCostRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberSharedCostRequest) InLata(inLata string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberSharedCostRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberSharedCostRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberSharedCostRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberSharedCostRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberSharedCostRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberSharedCostRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberSharedCostRequest) Execute() (*ListAvailablePhoneNumberSharedCostResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberSharedCostExecute(r)
}

/*
ListAvailablePhoneNumberSharedCost Method for ListAvailablePhoneNumberSharedCost



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberSharedCostRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberSharedCost(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberSharedCostRequest {
	return ApiListAvailablePhoneNumberSharedCostRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberSharedCostResponse
func (a *DefaultApiService) ListAvailablePhoneNumberSharedCostExecute(r ApiListAvailablePhoneNumberSharedCostRequest) (*ListAvailablePhoneNumberSharedCostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberSharedCostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberSharedCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberTollFreeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberTollFreeRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberTollFreeRequest) Contains(contains string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) Beta(beta bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) Distance(distance int32) ApiListAvailablePhoneNumberTollFreeRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberTollFreeRequest) InLata(inLata string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberTollFreeRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberTollFreeRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberTollFreeRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberTollFreeRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberTollFreeRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberTollFreeRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberTollFreeRequest) Execute() (*ListAvailablePhoneNumberTollFreeResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberTollFreeExecute(r)
}

/*
ListAvailablePhoneNumberTollFree Method for ListAvailablePhoneNumberTollFree



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberTollFreeRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberTollFree(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberTollFreeRequest {
	return ApiListAvailablePhoneNumberTollFreeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberTollFreeResponse
func (a *DefaultApiService) ListAvailablePhoneNumberTollFreeExecute(r ApiListAvailablePhoneNumberTollFreeRequest) (*ListAvailablePhoneNumberTollFreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberTollFreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberTollFree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAvailablePhoneNumberVoipRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	countryCode string
	areaCode *int32
	contains *string
	smsEnabled *bool
	mmsEnabled *bool
	voiceEnabled *bool
	excludeAllAddressRequired *bool
	excludeLocalAddressRequired *bool
	excludeForeignAddressRequired *bool
	beta *bool
	nearNumber *string
	nearLatLong *string
	distance *int32
	inPostalCode *string
	inRegion *string
	inRateCenter *string
	inLata *string
	inLocality *string
	faxEnabled *bool
	pageSize *int32
}

// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) AreaCode(areaCode int32) ApiListAvailablePhoneNumberVoipRequest {
	r.areaCode = &areaCode
	return r
}

// The pattern on which to match phone numbers. Valid characters are &#x60;*&#x60;, &#x60;0-9&#x60;, &#x60;a-z&#x60;, and &#x60;A-Z&#x60;. The &#x60;*&#x60; character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
func (r ApiListAvailablePhoneNumberVoipRequest) Contains(contains string) ApiListAvailablePhoneNumberVoipRequest {
	r.contains = &contains
	return r
}

// Whether the phone numbers can receive text messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) SmsEnabled(smsEnabled bool) ApiListAvailablePhoneNumberVoipRequest {
	r.smsEnabled = &smsEnabled
	return r
}

// Whether the phone numbers can receive MMS messages. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) MmsEnabled(mmsEnabled bool) ApiListAvailablePhoneNumberVoipRequest {
	r.mmsEnabled = &mmsEnabled
	return r
}

// Whether the phone numbers can receive calls. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) VoiceEnabled(voiceEnabled bool) ApiListAvailablePhoneNumberVoipRequest {
	r.voiceEnabled = &voiceEnabled
	return r
}

// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) ExcludeAllAddressRequired(excludeAllAddressRequired bool) ApiListAvailablePhoneNumberVoipRequest {
	r.excludeAllAddressRequired = &excludeAllAddressRequired
	return r
}

// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) ExcludeLocalAddressRequired(excludeLocalAddressRequired bool) ApiListAvailablePhoneNumberVoipRequest {
	r.excludeLocalAddressRequired = &excludeLocalAddressRequired
	return r
}

// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) ExcludeForeignAddressRequired(excludeForeignAddressRequired bool) ApiListAvailablePhoneNumberVoipRequest {
	r.excludeForeignAddressRequired = &excludeForeignAddressRequired
	return r
}

// Whether to read phone numbers that are new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) Beta(beta bool) ApiListAvailablePhoneNumberVoipRequest {
	r.beta = &beta
	return r
}

// Given a phone number, find a geographically close number within &#x60;distance&#x60; miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) NearNumber(nearNumber string) ApiListAvailablePhoneNumberVoipRequest {
	r.nearNumber = &nearNumber
	return r
}

// Given a latitude/longitude pair &#x60;lat,long&#x60; find geographically close numbers within &#x60;distance&#x60; miles. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) NearLatLong(nearLatLong string) ApiListAvailablePhoneNumberVoipRequest {
	r.nearLatLong = &nearLatLong
	return r
}

// The search radius, in miles, for a &#x60;near_&#x60; query.  Can be up to &#x60;500&#x60; and the default is &#x60;25&#x60;. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) Distance(distance int32) ApiListAvailablePhoneNumberVoipRequest {
	r.distance = &distance
	return r
}

// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) InPostalCode(inPostalCode string) ApiListAvailablePhoneNumberVoipRequest {
	r.inPostalCode = &inPostalCode
	return r
}

// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) InRegion(inRegion string) ApiListAvailablePhoneNumberVoipRequest {
	r.inRegion = &inRegion
	return r
}

// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires &#x60;in_lata&#x60; to be set as well. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) InRateCenter(inRateCenter string) ApiListAvailablePhoneNumberVoipRequest {
	r.inRateCenter = &inRateCenter
	return r
}

// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
func (r ApiListAvailablePhoneNumberVoipRequest) InLata(inLata string) ApiListAvailablePhoneNumberVoipRequest {
	r.inLata = &inLata
	return r
}

// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
func (r ApiListAvailablePhoneNumberVoipRequest) InLocality(inLocality string) ApiListAvailablePhoneNumberVoipRequest {
	r.inLocality = &inLocality
	return r
}

// Whether the phone numbers can receive faxes. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListAvailablePhoneNumberVoipRequest) FaxEnabled(faxEnabled bool) ApiListAvailablePhoneNumberVoipRequest {
	r.faxEnabled = &faxEnabled
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListAvailablePhoneNumberVoipRequest) PageSize(pageSize int32) ApiListAvailablePhoneNumberVoipRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAvailablePhoneNumberVoipRequest) Execute() (*ListAvailablePhoneNumberVoipResponse, *http.Response, error) {
	return r.ApiService.ListAvailablePhoneNumberVoipExecute(r)
}

/*
ListAvailablePhoneNumberVoip Method for ListAvailablePhoneNumberVoip



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
 @param countryCode The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
 @return ApiListAvailablePhoneNumberVoipRequest
*/
func (a *DefaultApiService) ListAvailablePhoneNumberVoip(ctx context.Context, accountSid string, countryCode string) ApiListAvailablePhoneNumberVoipRequest {
	return ApiListAvailablePhoneNumberVoipRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		countryCode: countryCode,
	}
}

// Execute executes the request
//  @return ListAvailablePhoneNumberVoipResponse
func (a *DefaultApiService) ListAvailablePhoneNumberVoipExecute(r ApiListAvailablePhoneNumberVoipRequest) (*ListAvailablePhoneNumberVoipResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAvailablePhoneNumberVoipResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAvailablePhoneNumberVoip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CountryCode"+"}", url.PathEscape(parameterToString(r.countryCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.areaCode != nil {
		localVarQueryParams.Add("AreaCode", parameterToString(*r.areaCode, ""))
	}
	if r.contains != nil {
		localVarQueryParams.Add("Contains", parameterToString(*r.contains, ""))
	}
	if r.smsEnabled != nil {
		localVarQueryParams.Add("SmsEnabled", parameterToString(*r.smsEnabled, ""))
	}
	if r.mmsEnabled != nil {
		localVarQueryParams.Add("MmsEnabled", parameterToString(*r.mmsEnabled, ""))
	}
	if r.voiceEnabled != nil {
		localVarQueryParams.Add("VoiceEnabled", parameterToString(*r.voiceEnabled, ""))
	}
	if r.excludeAllAddressRequired != nil {
		localVarQueryParams.Add("ExcludeAllAddressRequired", parameterToString(*r.excludeAllAddressRequired, ""))
	}
	if r.excludeLocalAddressRequired != nil {
		localVarQueryParams.Add("ExcludeLocalAddressRequired", parameterToString(*r.excludeLocalAddressRequired, ""))
	}
	if r.excludeForeignAddressRequired != nil {
		localVarQueryParams.Add("ExcludeForeignAddressRequired", parameterToString(*r.excludeForeignAddressRequired, ""))
	}
	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.nearNumber != nil {
		localVarQueryParams.Add("NearNumber", parameterToString(*r.nearNumber, ""))
	}
	if r.nearLatLong != nil {
		localVarQueryParams.Add("NearLatLong", parameterToString(*r.nearLatLong, ""))
	}
	if r.distance != nil {
		localVarQueryParams.Add("Distance", parameterToString(*r.distance, ""))
	}
	if r.inPostalCode != nil {
		localVarQueryParams.Add("InPostalCode", parameterToString(*r.inPostalCode, ""))
	}
	if r.inRegion != nil {
		localVarQueryParams.Add("InRegion", parameterToString(*r.inRegion, ""))
	}
	if r.inRateCenter != nil {
		localVarQueryParams.Add("InRateCenter", parameterToString(*r.inRateCenter, ""))
	}
	if r.inLata != nil {
		localVarQueryParams.Add("InLata", parameterToString(*r.inLata, ""))
	}
	if r.inLocality != nil {
		localVarQueryParams.Add("InLocality", parameterToString(*r.inLocality, ""))
	}
	if r.faxEnabled != nil {
		localVarQueryParams.Add("FaxEnabled", parameterToString(*r.faxEnabled, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCallRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	to *string
	from *string
	parentCallSid *string
	status *string
	startTime *time.Time
	startTime2 *time.Time
	startTime3 *time.Time
	endTime *time.Time
	endTime2 *time.Time
	endTime3 *time.Time
	pageSize *int32
}

// Only show calls made to this phone number, SIP address, Client identifier or SIM SID.
func (r ApiListCallRequest) To(to string) ApiListCallRequest {
	r.to = &to
	return r
}

// Only include calls from this phone number, SIP address, Client identifier or SIM SID.
func (r ApiListCallRequest) From(from string) ApiListCallRequest {
	r.from = &from
	return r
}

// Only include calls spawned by calls with this SID.
func (r ApiListCallRequest) ParentCallSid(parentCallSid string) ApiListCallRequest {
	r.parentCallSid = &parentCallSid
	return r
}

// The status of the calls to include. Can be: &#x60;queued&#x60;, &#x60;ringing&#x60;, &#x60;in-progress&#x60;, &#x60;canceled&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;busy&#x60;, or &#x60;no-answer&#x60;.
func (r ApiListCallRequest) Status(status string) ApiListCallRequest {
	r.status = &status
	return r
}

// Only include calls that started on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read only calls that started on this date. You can also specify an inequality, such as &#x60;StartTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read calls that started on or before midnight of this date, and &#x60;StartTime&gt;&#x3D;YYYY-MM-DD&#x60; to read calls that started on or after midnight of this date.
func (r ApiListCallRequest) StartTime(startTime time.Time) ApiListCallRequest {
	r.startTime = &startTime
	return r
}

// Only include calls that started on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read only calls that started on this date. You can also specify an inequality, such as &#x60;StartTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read calls that started on or before midnight of this date, and &#x60;StartTime&gt;&#x3D;YYYY-MM-DD&#x60; to read calls that started on or after midnight of this date.
func (r ApiListCallRequest) StartTime2(startTime2 time.Time) ApiListCallRequest {
	r.startTime2 = &startTime2
	return r
}

// Only include calls that started on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read only calls that started on this date. You can also specify an inequality, such as &#x60;StartTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read calls that started on or before midnight of this date, and &#x60;StartTime&gt;&#x3D;YYYY-MM-DD&#x60; to read calls that started on or after midnight of this date.
func (r ApiListCallRequest) StartTime3(startTime3 time.Time) ApiListCallRequest {
	r.startTime3 = &startTime3
	return r
}

// Only include calls that ended on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read only calls that ended on this date. You can also specify an inequality, such as &#x60;EndTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read calls that ended on or before midnight of this date, and &#x60;EndTime&gt;&#x3D;YYYY-MM-DD&#x60; to read calls that ended on or after midnight of this date.
func (r ApiListCallRequest) EndTime(endTime time.Time) ApiListCallRequest {
	r.endTime = &endTime
	return r
}

// Only include calls that ended on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read only calls that ended on this date. You can also specify an inequality, such as &#x60;EndTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read calls that ended on or before midnight of this date, and &#x60;EndTime&gt;&#x3D;YYYY-MM-DD&#x60; to read calls that ended on or after midnight of this date.
func (r ApiListCallRequest) EndTime2(endTime2 time.Time) ApiListCallRequest {
	r.endTime2 = &endTime2
	return r
}

// Only include calls that ended on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read only calls that ended on this date. You can also specify an inequality, such as &#x60;EndTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read calls that ended on or before midnight of this date, and &#x60;EndTime&gt;&#x3D;YYYY-MM-DD&#x60; to read calls that ended on or after midnight of this date.
func (r ApiListCallRequest) EndTime3(endTime3 time.Time) ApiListCallRequest {
	r.endTime3 = &endTime3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListCallRequest) PageSize(pageSize int32) ApiListCallRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListCallRequest) Execute() (*ListCallResponse, *http.Response, error) {
	return r.ApiService.ListCallExecute(r)
}

/*
ListCall Method for ListCall

Retrieves a collection of calls made to and from your account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to read.
 @return ApiListCallRequest
*/
func (a *DefaultApiService) ListCall(ctx context.Context, accountSid string) ApiListCallRequest {
	return ApiListCallRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListCallResponse
func (a *DefaultApiService) ListCallExecute(r ApiListCallRequest) (*ListCallResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCallResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.to != nil {
		localVarQueryParams.Add("To", parameterToString(*r.to, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("From", parameterToString(*r.from, ""))
	}
	if r.parentCallSid != nil {
		localVarQueryParams.Add("ParentCallSid", parameterToString(*r.parentCallSid, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("Status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("StartTime", parameterToString(*r.startTime, ""))
	}
	if r.startTime2 != nil {
		localVarQueryParams.Add("StartTime&lt;", parameterToString(*r.startTime2, ""))
	}
	if r.startTime3 != nil {
		localVarQueryParams.Add("StartTime&gt;", parameterToString(*r.startTime3, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("EndTime", parameterToString(*r.endTime, ""))
	}
	if r.endTime2 != nil {
		localVarQueryParams.Add("EndTime&lt;", parameterToString(*r.endTime2, ""))
	}
	if r.endTime3 != nil {
		localVarQueryParams.Add("EndTime&gt;", parameterToString(*r.endTime3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCallEventRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListCallEventRequest) PageSize(pageSize int32) ApiListCallEventRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListCallEventRequest) Execute() (*ListCallEventResponse, *http.Response, error) {
	return r.ApiService.ListCallEventExecute(r)
}

/*
ListCallEvent Method for ListCallEvent

Retrieve a list of all events for a call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique SID identifier of the Account.
 @param callSid The unique SID identifier of the Call.
 @return ApiListCallEventRequest
*/
func (a *DefaultApiService) ListCallEvent(ctx context.Context, accountSid string, callSid string) ApiListCallEventRequest {
	return ApiListCallEventRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ListCallEventResponse
func (a *DefaultApiService) ListCallEventExecute(r ApiListCallEventRequest) (*ListCallEventResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCallEventResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCallEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCallNotificationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	log *int32
	messageDate *string
	messageDate2 *string
	messageDate3 *string
	pageSize *int32
}

// Only read notifications of the specified log level. Can be:  &#x60;0&#x60; to read only ERROR notifications or &#x60;1&#x60; to read only WARNING notifications. By default, all notifications are read.
func (r ApiListCallNotificationRequest) Log(log int32) ApiListCallNotificationRequest {
	r.log = &log
	return r
}

// Only show notifications for the specified date, formatted as &#x60;YYYY-MM-DD&#x60;. You can also specify an inequality, such as &#x60;&lt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or before midnight on a date, or &#x60;&gt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or after midnight on a date.
func (r ApiListCallNotificationRequest) MessageDate(messageDate string) ApiListCallNotificationRequest {
	r.messageDate = &messageDate
	return r
}

// Only show notifications for the specified date, formatted as &#x60;YYYY-MM-DD&#x60;. You can also specify an inequality, such as &#x60;&lt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or before midnight on a date, or &#x60;&gt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or after midnight on a date.
func (r ApiListCallNotificationRequest) MessageDate2(messageDate2 string) ApiListCallNotificationRequest {
	r.messageDate2 = &messageDate2
	return r
}

// Only show notifications for the specified date, formatted as &#x60;YYYY-MM-DD&#x60;. You can also specify an inequality, such as &#x60;&lt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or before midnight on a date, or &#x60;&gt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or after midnight on a date.
func (r ApiListCallNotificationRequest) MessageDate3(messageDate3 string) ApiListCallNotificationRequest {
	r.messageDate3 = &messageDate3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListCallNotificationRequest) PageSize(pageSize int32) ApiListCallNotificationRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListCallNotificationRequest) Execute() (*ListCallNotificationResponse, *http.Response, error) {
	return r.ApiService.ListCallNotificationExecute(r)
}

/*
ListCallNotification Method for ListCallNotification



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call Notification resources to read.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the Call Notification resources to read.
 @return ApiListCallNotificationRequest
*/
func (a *DefaultApiService) ListCallNotification(ctx context.Context, accountSid string, callSid string) ApiListCallNotificationRequest {
	return ApiListCallNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ListCallNotificationResponse
func (a *DefaultApiService) ListCallNotificationExecute(r ApiListCallNotificationRequest) (*ListCallNotificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCallNotificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCallNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}

	if r.log != nil {
		localVarQueryParams.Add("Log", parameterToString(*r.log, ""))
	}
	if r.messageDate != nil {
		localVarQueryParams.Add("MessageDate", parameterToString(*r.messageDate, ""))
	}
	if r.messageDate2 != nil {
		localVarQueryParams.Add("MessageDate&lt;", parameterToString(*r.messageDate2, ""))
	}
	if r.messageDate3 != nil {
		localVarQueryParams.Add("MessageDate&gt;", parameterToString(*r.messageDate3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCallRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	dateCreated *string
	dateCreated2 *string
	dateCreated3 *string
	pageSize *int32
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
func (r ApiListCallRecordingRequest) DateCreated(dateCreated string) ApiListCallRecordingRequest {
	r.dateCreated = &dateCreated
	return r
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
func (r ApiListCallRecordingRequest) DateCreated2(dateCreated2 string) ApiListCallRecordingRequest {
	r.dateCreated2 = &dateCreated2
	return r
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
func (r ApiListCallRecordingRequest) DateCreated3(dateCreated3 string) ApiListCallRecordingRequest {
	r.dateCreated3 = &dateCreated3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListCallRecordingRequest) PageSize(pageSize int32) ApiListCallRecordingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListCallRecordingRequest) Execute() (*ListCallRecordingResponse, *http.Response, error) {
	return r.ApiService.ListCallRecordingExecute(r)
}

/*
ListCallRecording Method for ListCallRecording

Retrieve a list of recordings belonging to the call used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to read.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resources to read.
 @return ApiListCallRecordingRequest
*/
func (a *DefaultApiService) ListCallRecording(ctx context.Context, accountSid string, callSid string) ApiListCallRecordingRequest {
	return ApiListCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ListCallRecordingResponse
func (a *DefaultApiService) ListCallRecordingExecute(r ApiListCallRecordingRequest) (*ListCallRecordingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCallRecordingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}

	if r.dateCreated != nil {
		localVarQueryParams.Add("DateCreated", parameterToString(*r.dateCreated, ""))
	}
	if r.dateCreated2 != nil {
		localVarQueryParams.Add("DateCreated&lt;", parameterToString(*r.dateCreated2, ""))
	}
	if r.dateCreated3 != nil {
		localVarQueryParams.Add("DateCreated&gt;", parameterToString(*r.dateCreated3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConferenceRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	dateCreated *string
	dateCreated2 *string
	dateCreated3 *string
	dateUpdated *string
	dateUpdated2 *string
	dateUpdated3 *string
	friendlyName *string
	status *string
	pageSize *int32
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. To read conferences that started on or before midnight on a date, use &#x60;&lt;&#x3D;YYYY-MM-DD&#x60;, and to specify  conferences that started on or after midnight on a date, use &#x60;&gt;&#x3D;YYYY-MM-DD&#x60;.
func (r ApiListConferenceRequest) DateCreated(dateCreated string) ApiListConferenceRequest {
	r.dateCreated = &dateCreated
	return r
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. To read conferences that started on or before midnight on a date, use &#x60;&lt;&#x3D;YYYY-MM-DD&#x60;, and to specify  conferences that started on or after midnight on a date, use &#x60;&gt;&#x3D;YYYY-MM-DD&#x60;.
func (r ApiListConferenceRequest) DateCreated2(dateCreated2 string) ApiListConferenceRequest {
	r.dateCreated2 = &dateCreated2
	return r
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. To read conferences that started on or before midnight on a date, use &#x60;&lt;&#x3D;YYYY-MM-DD&#x60;, and to specify  conferences that started on or after midnight on a date, use &#x60;&gt;&#x3D;YYYY-MM-DD&#x60;.
func (r ApiListConferenceRequest) DateCreated3(dateCreated3 string) ApiListConferenceRequest {
	r.dateCreated3 = &dateCreated3
	return r
}

// The &#x60;date_updated&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. To read conferences that were last updated on or before midnight on a date, use &#x60;&lt;&#x3D;YYYY-MM-DD&#x60;, and to specify conferences that were last updated on or after midnight on a given date, use  &#x60;&gt;&#x3D;YYYY-MM-DD&#x60;.
func (r ApiListConferenceRequest) DateUpdated(dateUpdated string) ApiListConferenceRequest {
	r.dateUpdated = &dateUpdated
	return r
}

// The &#x60;date_updated&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. To read conferences that were last updated on or before midnight on a date, use &#x60;&lt;&#x3D;YYYY-MM-DD&#x60;, and to specify conferences that were last updated on or after midnight on a given date, use  &#x60;&gt;&#x3D;YYYY-MM-DD&#x60;.
func (r ApiListConferenceRequest) DateUpdated2(dateUpdated2 string) ApiListConferenceRequest {
	r.dateUpdated2 = &dateUpdated2
	return r
}

// The &#x60;date_updated&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. To read conferences that were last updated on or before midnight on a date, use &#x60;&lt;&#x3D;YYYY-MM-DD&#x60;, and to specify conferences that were last updated on or after midnight on a given date, use  &#x60;&gt;&#x3D;YYYY-MM-DD&#x60;.
func (r ApiListConferenceRequest) DateUpdated3(dateUpdated3 string) ApiListConferenceRequest {
	r.dateUpdated3 = &dateUpdated3
	return r
}

// The string that identifies the Conference resources to read.
func (r ApiListConferenceRequest) FriendlyName(friendlyName string) ApiListConferenceRequest {
	r.friendlyName = &friendlyName
	return r
}

// The status of the resources to read. Can be: &#x60;init&#x60;, &#x60;in-progress&#x60;, or &#x60;completed&#x60;.
func (r ApiListConferenceRequest) Status(status string) ApiListConferenceRequest {
	r.status = &status
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListConferenceRequest) PageSize(pageSize int32) ApiListConferenceRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListConferenceRequest) Execute() (*ListConferenceResponse, *http.Response, error) {
	return r.ApiService.ListConferenceExecute(r)
}

/*
ListConference Method for ListConference

Retrieve a list of conferences belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference resource(s) to read.
 @return ApiListConferenceRequest
*/
func (a *DefaultApiService) ListConference(ctx context.Context, accountSid string) ApiListConferenceRequest {
	return ApiListConferenceRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListConferenceResponse
func (a *DefaultApiService) ListConferenceExecute(r ApiListConferenceRequest) (*ListConferenceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConferenceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.dateCreated != nil {
		localVarQueryParams.Add("DateCreated", parameterToString(*r.dateCreated, ""))
	}
	if r.dateCreated2 != nil {
		localVarQueryParams.Add("DateCreated&lt;", parameterToString(*r.dateCreated2, ""))
	}
	if r.dateCreated3 != nil {
		localVarQueryParams.Add("DateCreated&gt;", parameterToString(*r.dateCreated3, ""))
	}
	if r.dateUpdated != nil {
		localVarQueryParams.Add("DateUpdated", parameterToString(*r.dateUpdated, ""))
	}
	if r.dateUpdated2 != nil {
		localVarQueryParams.Add("DateUpdated&lt;", parameterToString(*r.dateUpdated2, ""))
	}
	if r.dateUpdated3 != nil {
		localVarQueryParams.Add("DateUpdated&gt;", parameterToString(*r.dateUpdated3, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("Status", parameterToString(*r.status, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	dateCreated *string
	dateCreated2 *string
	dateCreated3 *string
	pageSize *int32
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
func (r ApiListConferenceRecordingRequest) DateCreated(dateCreated string) ApiListConferenceRecordingRequest {
	r.dateCreated = &dateCreated
	return r
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
func (r ApiListConferenceRecordingRequest) DateCreated2(dateCreated2 string) ApiListConferenceRecordingRequest {
	r.dateCreated2 = &dateCreated2
	return r
}

// The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
func (r ApiListConferenceRecordingRequest) DateCreated3(dateCreated3 string) ApiListConferenceRecordingRequest {
	r.dateCreated3 = &dateCreated3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListConferenceRecordingRequest) PageSize(pageSize int32) ApiListConferenceRecordingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListConferenceRecordingRequest) Execute() (*ListConferenceRecordingResponse, *http.Response, error) {
	return r.ApiService.ListConferenceRecordingExecute(r)
}

/*
ListConferenceRecording Method for ListConferenceRecording

Retrieve a list of recordings belonging to the call used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resources to read.
 @param conferenceSid The Conference SID that identifies the conference associated with the recording to read.
 @return ApiListConferenceRecordingRequest
*/
func (a *DefaultApiService) ListConferenceRecording(ctx context.Context, accountSid string, conferenceSid string) ApiListConferenceRecordingRequest {
	return ApiListConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ListConferenceRecordingResponse
func (a *DefaultApiService) ListConferenceRecordingExecute(r ApiListConferenceRecordingRequest) (*ListConferenceRecordingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConferenceRecordingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have less than 34 elements")
	}

	if r.dateCreated != nil {
		localVarQueryParams.Add("DateCreated", parameterToString(*r.dateCreated, ""))
	}
	if r.dateCreated2 != nil {
		localVarQueryParams.Add("DateCreated&lt;", parameterToString(*r.dateCreated2, ""))
	}
	if r.dateCreated3 != nil {
		localVarQueryParams.Add("DateCreated&gt;", parameterToString(*r.dateCreated3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConnectAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListConnectAppRequest) PageSize(pageSize int32) ApiListConnectAppRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListConnectAppRequest) Execute() (*ListConnectAppResponse, *http.Response, error) {
	return r.ApiService.ListConnectAppExecute(r)
}

/*
ListConnectApp Method for ListConnectApp

Retrieve a list of connect-apps belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resources to read.
 @return ApiListConnectAppRequest
*/
func (a *DefaultApiService) ListConnectApp(ctx context.Context, accountSid string) ApiListConnectAppRequest {
	return ApiListConnectAppRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListConnectAppResponse
func (a *DefaultApiService) ListConnectAppExecute(r ApiListConnectAppRequest) (*ListConnectAppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConnectAppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListConnectApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/ConnectApps.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDependentPhoneNumberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	addressSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListDependentPhoneNumberRequest) PageSize(pageSize int32) ApiListDependentPhoneNumberRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListDependentPhoneNumberRequest) Execute() (*ListDependentPhoneNumberResponse, *http.Response, error) {
	return r.ApiService.ListDependentPhoneNumberExecute(r)
}

/*
ListDependentPhoneNumber Method for ListDependentPhoneNumber



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the DependentPhoneNumber resources to read.
 @param addressSid The SID of the Address resource associated with the phone number.
 @return ApiListDependentPhoneNumberRequest
*/
func (a *DefaultApiService) ListDependentPhoneNumber(ctx context.Context, accountSid string, addressSid string) ApiListDependentPhoneNumberRequest {
	return ApiListDependentPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		addressSid: addressSid,
	}
}

// Execute executes the request
//  @return ListDependentPhoneNumberResponse
func (a *DefaultApiService) ListDependentPhoneNumberExecute(r ApiListDependentPhoneNumberRequest) (*ListDependentPhoneNumberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDependentPhoneNumberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListDependentPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AddressSid"+"}", url.PathEscape(parameterToString(r.addressSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.addressSid) < 34 {
		return localVarReturnValue, nil, reportError("addressSid must have at least 34 elements")
	}
	if strlen(r.addressSid) > 34 {
		return localVarReturnValue, nil, reportError("addressSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIncomingPhoneNumberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	beta *bool
	friendlyName *string
	phoneNumber *string
	origin *string
	pageSize *int32
}

// Whether to include phone numbers new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListIncomingPhoneNumberRequest) Beta(beta bool) ApiListIncomingPhoneNumberRequest {
	r.beta = &beta
	return r
}

// A string that identifies the IncomingPhoneNumber resources to read.
func (r ApiListIncomingPhoneNumberRequest) FriendlyName(friendlyName string) ApiListIncomingPhoneNumberRequest {
	r.friendlyName = &friendlyName
	return r
}

// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use &#39;*&#39; as a wildcard for any digit.
func (r ApiListIncomingPhoneNumberRequest) PhoneNumber(phoneNumber string) ApiListIncomingPhoneNumberRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// Whether to include phone numbers based on their origin. Can be: &#x60;twilio&#x60; or &#x60;hosted&#x60;. By default, phone numbers of all origin are included.
func (r ApiListIncomingPhoneNumberRequest) Origin(origin string) ApiListIncomingPhoneNumberRequest {
	r.origin = &origin
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListIncomingPhoneNumberRequest) PageSize(pageSize int32) ApiListIncomingPhoneNumberRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListIncomingPhoneNumberRequest) Execute() (*ListIncomingPhoneNumberResponse, *http.Response, error) {
	return r.ApiService.ListIncomingPhoneNumberExecute(r)
}

/*
ListIncomingPhoneNumber Method for ListIncomingPhoneNumber

Retrieve a list of incoming-phone-numbers belonging to the account used to make the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resources to read.
 @return ApiListIncomingPhoneNumberRequest
*/
func (a *DefaultApiService) ListIncomingPhoneNumber(ctx context.Context, accountSid string) ApiListIncomingPhoneNumberRequest {
	return ApiListIncomingPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListIncomingPhoneNumberResponse
func (a *DefaultApiService) ListIncomingPhoneNumberExecute(r ApiListIncomingPhoneNumberRequest) (*ListIncomingPhoneNumberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncomingPhoneNumberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIncomingPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.phoneNumber != nil {
		localVarQueryParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	}
	if r.origin != nil {
		localVarQueryParams.Add("Origin", parameterToString(*r.origin, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIncomingPhoneNumberAssignedAddOnRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	resourceSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListIncomingPhoneNumberAssignedAddOnRequest) PageSize(pageSize int32) ApiListIncomingPhoneNumberAssignedAddOnRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListIncomingPhoneNumberAssignedAddOnRequest) Execute() (*ListIncomingPhoneNumberAssignedAddOnResponse, *http.Response, error) {
	return r.ApiService.ListIncomingPhoneNumberAssignedAddOnExecute(r)
}

/*
ListIncomingPhoneNumberAssignedAddOn Method for ListIncomingPhoneNumberAssignedAddOn

Retrieve a list of Add-on installations currently assigned to this Number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
 @param resourceSid The SID of the Phone Number to which the Add-on is assigned.
 @return ApiListIncomingPhoneNumberAssignedAddOnRequest
*/
func (a *DefaultApiService) ListIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string) ApiListIncomingPhoneNumberAssignedAddOnRequest {
	return ApiListIncomingPhoneNumberAssignedAddOnRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		resourceSid: resourceSid,
	}
}

// Execute executes the request
//  @return ListIncomingPhoneNumberAssignedAddOnResponse
func (a *DefaultApiService) ListIncomingPhoneNumberAssignedAddOnExecute(r ApiListIncomingPhoneNumberAssignedAddOnRequest) (*ListIncomingPhoneNumberAssignedAddOnResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncomingPhoneNumberAssignedAddOnResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIncomingPhoneNumberAssignedAddOn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ResourceSid"+"}", url.PathEscape(parameterToString(r.resourceSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.resourceSid) < 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have at least 34 elements")
	}
	if strlen(r.resourceSid) > 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	resourceSid string
	assignedAddOnSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest) PageSize(pageSize int32) ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest) Execute() (*ListIncomingPhoneNumberAssignedAddOnExtensionResponse, *http.Response, error) {
	return r.ApiService.ListIncomingPhoneNumberAssignedAddOnExtensionExecute(r)
}

/*
ListIncomingPhoneNumberAssignedAddOnExtension Method for ListIncomingPhoneNumberAssignedAddOnExtension

Retrieve a list of Extensions for the Assigned Add-on.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
 @param resourceSid The SID of the Phone Number to which the Add-on is assigned.
 @param assignedAddOnSid The SID that uniquely identifies the assigned Add-on installation.
 @return ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest
*/
func (a *DefaultApiService) ListIncomingPhoneNumberAssignedAddOnExtension(ctx context.Context, accountSid string, resourceSid string, assignedAddOnSid string) ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest {
	return ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		resourceSid: resourceSid,
		assignedAddOnSid: assignedAddOnSid,
	}
}

// Execute executes the request
//  @return ListIncomingPhoneNumberAssignedAddOnExtensionResponse
func (a *DefaultApiService) ListIncomingPhoneNumberAssignedAddOnExtensionExecute(r ApiListIncomingPhoneNumberAssignedAddOnExtensionRequest) (*ListIncomingPhoneNumberAssignedAddOnExtensionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncomingPhoneNumberAssignedAddOnExtensionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIncomingPhoneNumberAssignedAddOnExtension")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ResourceSid"+"}", url.PathEscape(parameterToString(r.resourceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AssignedAddOnSid"+"}", url.PathEscape(parameterToString(r.assignedAddOnSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.resourceSid) < 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have at least 34 elements")
	}
	if strlen(r.resourceSid) > 34 {
		return localVarReturnValue, nil, reportError("resourceSid must have less than 34 elements")
	}
	if strlen(r.assignedAddOnSid) < 34 {
		return localVarReturnValue, nil, reportError("assignedAddOnSid must have at least 34 elements")
	}
	if strlen(r.assignedAddOnSid) > 34 {
		return localVarReturnValue, nil, reportError("assignedAddOnSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIncomingPhoneNumberLocalRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	beta *bool
	friendlyName *string
	phoneNumber *string
	origin *string
	pageSize *int32
}

// Whether to include phone numbers new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListIncomingPhoneNumberLocalRequest) Beta(beta bool) ApiListIncomingPhoneNumberLocalRequest {
	r.beta = &beta
	return r
}

// A string that identifies the resources to read.
func (r ApiListIncomingPhoneNumberLocalRequest) FriendlyName(friendlyName string) ApiListIncomingPhoneNumberLocalRequest {
	r.friendlyName = &friendlyName
	return r
}

// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use &#39;*&#39; as a wildcard for any digit.
func (r ApiListIncomingPhoneNumberLocalRequest) PhoneNumber(phoneNumber string) ApiListIncomingPhoneNumberLocalRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// Whether to include phone numbers based on their origin. Can be: &#x60;twilio&#x60; or &#x60;hosted&#x60;. By default, phone numbers of all origin are included.
func (r ApiListIncomingPhoneNumberLocalRequest) Origin(origin string) ApiListIncomingPhoneNumberLocalRequest {
	r.origin = &origin
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListIncomingPhoneNumberLocalRequest) PageSize(pageSize int32) ApiListIncomingPhoneNumberLocalRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListIncomingPhoneNumberLocalRequest) Execute() (*ListIncomingPhoneNumberLocalResponse, *http.Response, error) {
	return r.ApiService.ListIncomingPhoneNumberLocalExecute(r)
}

/*
ListIncomingPhoneNumberLocal Method for ListIncomingPhoneNumberLocal



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
 @return ApiListIncomingPhoneNumberLocalRequest
*/
func (a *DefaultApiService) ListIncomingPhoneNumberLocal(ctx context.Context, accountSid string) ApiListIncomingPhoneNumberLocalRequest {
	return ApiListIncomingPhoneNumberLocalRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListIncomingPhoneNumberLocalResponse
func (a *DefaultApiService) ListIncomingPhoneNumberLocalExecute(r ApiListIncomingPhoneNumberLocalRequest) (*ListIncomingPhoneNumberLocalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncomingPhoneNumberLocalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIncomingPhoneNumberLocal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.phoneNumber != nil {
		localVarQueryParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	}
	if r.origin != nil {
		localVarQueryParams.Add("Origin", parameterToString(*r.origin, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIncomingPhoneNumberMobileRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	beta *bool
	friendlyName *string
	phoneNumber *string
	origin *string
	pageSize *int32
}

// Whether to include phone numbers new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListIncomingPhoneNumberMobileRequest) Beta(beta bool) ApiListIncomingPhoneNumberMobileRequest {
	r.beta = &beta
	return r
}

// A string that identifies the resources to read.
func (r ApiListIncomingPhoneNumberMobileRequest) FriendlyName(friendlyName string) ApiListIncomingPhoneNumberMobileRequest {
	r.friendlyName = &friendlyName
	return r
}

// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use &#39;*&#39; as a wildcard for any digit.
func (r ApiListIncomingPhoneNumberMobileRequest) PhoneNumber(phoneNumber string) ApiListIncomingPhoneNumberMobileRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// Whether to include phone numbers based on their origin. Can be: &#x60;twilio&#x60; or &#x60;hosted&#x60;. By default, phone numbers of all origin are included.
func (r ApiListIncomingPhoneNumberMobileRequest) Origin(origin string) ApiListIncomingPhoneNumberMobileRequest {
	r.origin = &origin
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListIncomingPhoneNumberMobileRequest) PageSize(pageSize int32) ApiListIncomingPhoneNumberMobileRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListIncomingPhoneNumberMobileRequest) Execute() (*ListIncomingPhoneNumberMobileResponse, *http.Response, error) {
	return r.ApiService.ListIncomingPhoneNumberMobileExecute(r)
}

/*
ListIncomingPhoneNumberMobile Method for ListIncomingPhoneNumberMobile



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
 @return ApiListIncomingPhoneNumberMobileRequest
*/
func (a *DefaultApiService) ListIncomingPhoneNumberMobile(ctx context.Context, accountSid string) ApiListIncomingPhoneNumberMobileRequest {
	return ApiListIncomingPhoneNumberMobileRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListIncomingPhoneNumberMobileResponse
func (a *DefaultApiService) ListIncomingPhoneNumberMobileExecute(r ApiListIncomingPhoneNumberMobileRequest) (*ListIncomingPhoneNumberMobileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncomingPhoneNumberMobileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIncomingPhoneNumberMobile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.phoneNumber != nil {
		localVarQueryParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	}
	if r.origin != nil {
		localVarQueryParams.Add("Origin", parameterToString(*r.origin, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIncomingPhoneNumberTollFreeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	beta *bool
	friendlyName *string
	phoneNumber *string
	origin *string
	pageSize *int32
}

// Whether to include phone numbers new to the Twilio platform. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;.
func (r ApiListIncomingPhoneNumberTollFreeRequest) Beta(beta bool) ApiListIncomingPhoneNumberTollFreeRequest {
	r.beta = &beta
	return r
}

// A string that identifies the resources to read.
func (r ApiListIncomingPhoneNumberTollFreeRequest) FriendlyName(friendlyName string) ApiListIncomingPhoneNumberTollFreeRequest {
	r.friendlyName = &friendlyName
	return r
}

// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use &#39;*&#39; as a wildcard for any digit.
func (r ApiListIncomingPhoneNumberTollFreeRequest) PhoneNumber(phoneNumber string) ApiListIncomingPhoneNumberTollFreeRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// Whether to include phone numbers based on their origin. Can be: &#x60;twilio&#x60; or &#x60;hosted&#x60;. By default, phone numbers of all origin are included.
func (r ApiListIncomingPhoneNumberTollFreeRequest) Origin(origin string) ApiListIncomingPhoneNumberTollFreeRequest {
	r.origin = &origin
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListIncomingPhoneNumberTollFreeRequest) PageSize(pageSize int32) ApiListIncomingPhoneNumberTollFreeRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListIncomingPhoneNumberTollFreeRequest) Execute() (*ListIncomingPhoneNumberTollFreeResponse, *http.Response, error) {
	return r.ApiService.ListIncomingPhoneNumberTollFreeExecute(r)
}

/*
ListIncomingPhoneNumberTollFree Method for ListIncomingPhoneNumberTollFree



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
 @return ApiListIncomingPhoneNumberTollFreeRequest
*/
func (a *DefaultApiService) ListIncomingPhoneNumberTollFree(ctx context.Context, accountSid string) ApiListIncomingPhoneNumberTollFreeRequest {
	return ApiListIncomingPhoneNumberTollFreeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListIncomingPhoneNumberTollFreeResponse
func (a *DefaultApiService) ListIncomingPhoneNumberTollFreeExecute(r ApiListIncomingPhoneNumberTollFreeRequest) (*ListIncomingPhoneNumberTollFreeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIncomingPhoneNumberTollFreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIncomingPhoneNumberTollFree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.beta != nil {
		localVarQueryParams.Add("Beta", parameterToString(*r.beta, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.phoneNumber != nil {
		localVarQueryParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	}
	if r.origin != nil {
		localVarQueryParams.Add("Origin", parameterToString(*r.origin, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListKeyRequest) PageSize(pageSize int32) ApiListKeyRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListKeyRequest) Execute() (*ListKeyResponse, *http.Response, error) {
	return r.ApiService.ListKeyExecute(r)
}

/*
ListKey Method for ListKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resources to read.
 @return ApiListKeyRequest
*/
func (a *DefaultApiService) ListKey(ctx context.Context, accountSid string) ApiListKeyRequest {
	return ApiListKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListKeyResponse
func (a *DefaultApiService) ListKeyExecute(r ApiListKeyRequest) (*ListKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListKeyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Keys.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMediaRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	messageSid string
	dateCreated *time.Time
	dateCreated2 *time.Time
	dateCreated3 *time.Time
	pageSize *int32
}

// Only include media that was created on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read media that was created on this date. You can also specify an inequality, such as &#x60;StartTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read media that was created on or before midnight of this date, and &#x60;StartTime&gt;&#x3D;YYYY-MM-DD&#x60; to read media that was created on or after midnight of this date.
func (r ApiListMediaRequest) DateCreated(dateCreated time.Time) ApiListMediaRequest {
	r.dateCreated = &dateCreated
	return r
}

// Only include media that was created on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read media that was created on this date. You can also specify an inequality, such as &#x60;StartTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read media that was created on or before midnight of this date, and &#x60;StartTime&gt;&#x3D;YYYY-MM-DD&#x60; to read media that was created on or after midnight of this date.
func (r ApiListMediaRequest) DateCreated2(dateCreated2 time.Time) ApiListMediaRequest {
	r.dateCreated2 = &dateCreated2
	return r
}

// Only include media that was created on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read media that was created on this date. You can also specify an inequality, such as &#x60;StartTime&lt;&#x3D;YYYY-MM-DD&#x60;, to read media that was created on or before midnight of this date, and &#x60;StartTime&gt;&#x3D;YYYY-MM-DD&#x60; to read media that was created on or after midnight of this date.
func (r ApiListMediaRequest) DateCreated3(dateCreated3 time.Time) ApiListMediaRequest {
	r.dateCreated3 = &dateCreated3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListMediaRequest) PageSize(pageSize int32) ApiListMediaRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListMediaRequest) Execute() (*ListMediaResponse, *http.Response, error) {
	return r.ApiService.ListMediaExecute(r)
}

/*
ListMedia Method for ListMedia

Retrieve a list of Media resources belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Media resource(s) to read.
 @param messageSid The SID of the Message resource that this Media resource belongs to.
 @return ApiListMediaRequest
*/
func (a *DefaultApiService) ListMedia(ctx context.Context, accountSid string, messageSid string) ApiListMediaRequest {
	return ApiListMediaRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		messageSid: messageSid,
	}
}

// Execute executes the request
//  @return ListMediaResponse
func (a *DefaultApiService) ListMediaExecute(r ApiListMediaRequest) (*ListMediaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMediaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"MessageSid"+"}", url.PathEscape(parameterToString(r.messageSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.messageSid) < 34 {
		return localVarReturnValue, nil, reportError("messageSid must have at least 34 elements")
	}
	if strlen(r.messageSid) > 34 {
		return localVarReturnValue, nil, reportError("messageSid must have less than 34 elements")
	}

	if r.dateCreated != nil {
		localVarQueryParams.Add("DateCreated", parameterToString(*r.dateCreated, ""))
	}
	if r.dateCreated2 != nil {
		localVarQueryParams.Add("DateCreated&lt;", parameterToString(*r.dateCreated2, ""))
	}
	if r.dateCreated3 != nil {
		localVarQueryParams.Add("DateCreated&gt;", parameterToString(*r.dateCreated3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMemberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	queueSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListMemberRequest) PageSize(pageSize int32) ApiListMemberRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListMemberRequest) Execute() (*ListMemberResponse, *http.Response, error) {
	return r.ApiService.ListMemberExecute(r)
}

/*
ListMember Method for ListMember

Retrieve the members of the queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Member resource(s) to read.
 @param queueSid The SID of the Queue in which to find the members
 @return ApiListMemberRequest
*/
func (a *DefaultApiService) ListMember(ctx context.Context, accountSid string, queueSid string) ApiListMemberRequest {
	return ApiListMemberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		queueSid: queueSid,
	}
}

// Execute executes the request
//  @return ListMemberResponse
func (a *DefaultApiService) ListMemberExecute(r ApiListMemberRequest) (*ListMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"QueueSid"+"}", url.PathEscape(parameterToString(r.queueSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.queueSid) < 34 {
		return localVarReturnValue, nil, reportError("queueSid must have at least 34 elements")
	}
	if strlen(r.queueSid) > 34 {
		return localVarReturnValue, nil, reportError("queueSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	to *string
	from *string
	dateSent *time.Time
	dateSent2 *time.Time
	dateSent3 *time.Time
	pageSize *int32
}

// Read messages sent to only this phone number.
func (r ApiListMessageRequest) To(to string) ApiListMessageRequest {
	r.to = &to
	return r
}

// Read messages sent from only this phone number or alphanumeric sender ID.
func (r ApiListMessageRequest) From(from string) ApiListMessageRequest {
	r.from = &from
	return r
}

// The date of the messages to show. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT to read only messages sent on this date. For example: &#x60;2009-07-06&#x60;. You can also specify an inequality, such as &#x60;DateSent&lt;&#x3D;YYYY-MM-DD&#x60;, to read messages sent on or before midnight on a date, and &#x60;DateSent&gt;&#x3D;YYYY-MM-DD&#x60; to read messages sent on or after midnight on a date.
func (r ApiListMessageRequest) DateSent(dateSent time.Time) ApiListMessageRequest {
	r.dateSent = &dateSent
	return r
}

// The date of the messages to show. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT to read only messages sent on this date. For example: &#x60;2009-07-06&#x60;. You can also specify an inequality, such as &#x60;DateSent&lt;&#x3D;YYYY-MM-DD&#x60;, to read messages sent on or before midnight on a date, and &#x60;DateSent&gt;&#x3D;YYYY-MM-DD&#x60; to read messages sent on or after midnight on a date.
func (r ApiListMessageRequest) DateSent2(dateSent2 time.Time) ApiListMessageRequest {
	r.dateSent2 = &dateSent2
	return r
}

// The date of the messages to show. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT to read only messages sent on this date. For example: &#x60;2009-07-06&#x60;. You can also specify an inequality, such as &#x60;DateSent&lt;&#x3D;YYYY-MM-DD&#x60;, to read messages sent on or before midnight on a date, and &#x60;DateSent&gt;&#x3D;YYYY-MM-DD&#x60; to read messages sent on or after midnight on a date.
func (r ApiListMessageRequest) DateSent3(dateSent3 time.Time) ApiListMessageRequest {
	r.dateSent3 = &dateSent3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListMessageRequest) PageSize(pageSize int32) ApiListMessageRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListMessageRequest) Execute() (*ListMessageResponse, *http.Response, error) {
	return r.ApiService.ListMessageExecute(r)
}

/*
ListMessage Method for ListMessage

Retrieve a list of messages belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resources to read.
 @return ApiListMessageRequest
*/
func (a *DefaultApiService) ListMessage(ctx context.Context, accountSid string) ApiListMessageRequest {
	return ApiListMessageRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListMessageResponse
func (a *DefaultApiService) ListMessageExecute(r ApiListMessageRequest) (*ListMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.to != nil {
		localVarQueryParams.Add("To", parameterToString(*r.to, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("From", parameterToString(*r.from, ""))
	}
	if r.dateSent != nil {
		localVarQueryParams.Add("DateSent", parameterToString(*r.dateSent, ""))
	}
	if r.dateSent2 != nil {
		localVarQueryParams.Add("DateSent&lt;", parameterToString(*r.dateSent2, ""))
	}
	if r.dateSent3 != nil {
		localVarQueryParams.Add("DateSent&gt;", parameterToString(*r.dateSent3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNotificationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	log *int32
	messageDate *string
	messageDate2 *string
	messageDate3 *string
	pageSize *int32
}

// Only read notifications of the specified log level. Can be:  &#x60;0&#x60; to read only ERROR notifications or &#x60;1&#x60; to read only WARNING notifications. By default, all notifications are read.
func (r ApiListNotificationRequest) Log(log int32) ApiListNotificationRequest {
	r.log = &log
	return r
}

// Only show notifications for the specified date, formatted as &#x60;YYYY-MM-DD&#x60;. You can also specify an inequality, such as &#x60;&lt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or before midnight on a date, or &#x60;&gt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or after midnight on a date.
func (r ApiListNotificationRequest) MessageDate(messageDate string) ApiListNotificationRequest {
	r.messageDate = &messageDate
	return r
}

// Only show notifications for the specified date, formatted as &#x60;YYYY-MM-DD&#x60;. You can also specify an inequality, such as &#x60;&lt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or before midnight on a date, or &#x60;&gt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or after midnight on a date.
func (r ApiListNotificationRequest) MessageDate2(messageDate2 string) ApiListNotificationRequest {
	r.messageDate2 = &messageDate2
	return r
}

// Only show notifications for the specified date, formatted as &#x60;YYYY-MM-DD&#x60;. You can also specify an inequality, such as &#x60;&lt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or before midnight on a date, or &#x60;&gt;&#x3D;YYYY-MM-DD&#x60; for messages logged at or after midnight on a date.
func (r ApiListNotificationRequest) MessageDate3(messageDate3 string) ApiListNotificationRequest {
	r.messageDate3 = &messageDate3
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListNotificationRequest) PageSize(pageSize int32) ApiListNotificationRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListNotificationRequest) Execute() (*ListNotificationResponse, *http.Response, error) {
	return r.ApiService.ListNotificationExecute(r)
}

/*
ListNotification Method for ListNotification

Retrieve a list of notifications belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Notification resources to read.
 @return ApiListNotificationRequest
*/
func (a *DefaultApiService) ListNotification(ctx context.Context, accountSid string) ApiListNotificationRequest {
	return ApiListNotificationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListNotificationResponse
func (a *DefaultApiService) ListNotificationExecute(r ApiListNotificationRequest) (*ListNotificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListNotificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Notifications.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.log != nil {
		localVarQueryParams.Add("Log", parameterToString(*r.log, ""))
	}
	if r.messageDate != nil {
		localVarQueryParams.Add("MessageDate", parameterToString(*r.messageDate, ""))
	}
	if r.messageDate2 != nil {
		localVarQueryParams.Add("MessageDate&lt;", parameterToString(*r.messageDate2, ""))
	}
	if r.messageDate3 != nil {
		localVarQueryParams.Add("MessageDate&gt;", parameterToString(*r.messageDate3, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOutgoingCallerIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	phoneNumber *string
	friendlyName *string
	pageSize *int32
}

// The phone number of the OutgoingCallerId resources to read.
func (r ApiListOutgoingCallerIdRequest) PhoneNumber(phoneNumber string) ApiListOutgoingCallerIdRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// The string that identifies the OutgoingCallerId resources to read.
func (r ApiListOutgoingCallerIdRequest) FriendlyName(friendlyName string) ApiListOutgoingCallerIdRequest {
	r.friendlyName = &friendlyName
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListOutgoingCallerIdRequest) PageSize(pageSize int32) ApiListOutgoingCallerIdRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListOutgoingCallerIdRequest) Execute() (*ListOutgoingCallerIdResponse, *http.Response, error) {
	return r.ApiService.ListOutgoingCallerIdExecute(r)
}

/*
ListOutgoingCallerId Method for ListOutgoingCallerId

Retrieve a list of outgoing-caller-ids belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resources to read.
 @return ApiListOutgoingCallerIdRequest
*/
func (a *DefaultApiService) ListOutgoingCallerId(ctx context.Context, accountSid string) ApiListOutgoingCallerIdRequest {
	return ApiListOutgoingCallerIdRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListOutgoingCallerIdResponse
func (a *DefaultApiService) ListOutgoingCallerIdExecute(r ApiListOutgoingCallerIdRequest) (*ListOutgoingCallerIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOutgoingCallerIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListOutgoingCallerId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.phoneNumber != nil {
		localVarQueryParams.Add("PhoneNumber", parameterToString(*r.phoneNumber, ""))
	}
	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListParticipantRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	muted *bool
	hold *bool
	coaching *bool
	pageSize *int32
}

// Whether to return only participants that are muted. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListParticipantRequest) Muted(muted bool) ApiListParticipantRequest {
	r.muted = &muted
	return r
}

// Whether to return only participants that are on hold. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListParticipantRequest) Hold(hold bool) ApiListParticipantRequest {
	r.hold = &hold
	return r
}

// Whether to return only participants who are coaching another call. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiListParticipantRequest) Coaching(coaching bool) ApiListParticipantRequest {
	r.coaching = &coaching
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListParticipantRequest) PageSize(pageSize int32) ApiListParticipantRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListParticipantRequest) Execute() (*ListParticipantResponse, *http.Response, error) {
	return r.ApiService.ListParticipantExecute(r)
}

/*
ListParticipant Method for ListParticipant

Retrieve a list of participants belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to read.
 @param conferenceSid The SID of the conference with the participants to read.
 @return ApiListParticipantRequest
*/
func (a *DefaultApiService) ListParticipant(ctx context.Context, accountSid string, conferenceSid string) ApiListParticipantRequest {
	return ApiListParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
	}
}

// Execute executes the request
//  @return ListParticipantResponse
func (a *DefaultApiService) ListParticipantExecute(r ApiListParticipantRequest) (*ListParticipantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListParticipantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have less than 34 elements")
	}

	if r.muted != nil {
		localVarQueryParams.Add("Muted", parameterToString(*r.muted, ""))
	}
	if r.hold != nil {
		localVarQueryParams.Add("Hold", parameterToString(*r.hold, ""))
	}
	if r.coaching != nil {
		localVarQueryParams.Add("Coaching", parameterToString(*r.coaching, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListQueueRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListQueueRequest) PageSize(pageSize int32) ApiListQueueRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListQueueRequest) Execute() (*ListQueueResponse, *http.Response, error) {
	return r.ApiService.ListQueueExecute(r)
}

/*
ListQueue Method for ListQueue

Retrieve a list of queues belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resources to read.
 @return ApiListQueueRequest
*/
func (a *DefaultApiService) ListQueue(ctx context.Context, accountSid string) ApiListQueueRequest {
	return ApiListQueueRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListQueueResponse
func (a *DefaultApiService) ListQueueExecute(r ApiListQueueRequest) (*ListQueueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListQueueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	dateCreated *time.Time
	dateCreated2 *time.Time
	dateCreated3 *time.Time
	callSid *string
	conferenceSid *string
	includeSoftDeleted *bool
	pageSize *int32
}

// Only include recordings that were created on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read recordings that were created on this date. You can also specify an inequality, such as &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60;, to read recordings that were created on or before midnight of this date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; to read recordings that were created on or after midnight of this date.
func (r ApiListRecordingRequest) DateCreated(dateCreated time.Time) ApiListRecordingRequest {
	r.dateCreated = &dateCreated
	return r
}

// Only include recordings that were created on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read recordings that were created on this date. You can also specify an inequality, such as &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60;, to read recordings that were created on or before midnight of this date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; to read recordings that were created on or after midnight of this date.
func (r ApiListRecordingRequest) DateCreated2(dateCreated2 time.Time) ApiListRecordingRequest {
	r.dateCreated2 = &dateCreated2
	return r
}

// Only include recordings that were created on this date. Specify a date as &#x60;YYYY-MM-DD&#x60; in GMT, for example: &#x60;2009-07-06&#x60;, to read recordings that were created on this date. You can also specify an inequality, such as &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60;, to read recordings that were created on or before midnight of this date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; to read recordings that were created on or after midnight of this date.
func (r ApiListRecordingRequest) DateCreated3(dateCreated3 time.Time) ApiListRecordingRequest {
	r.dateCreated3 = &dateCreated3
	return r
}

// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resources to read.
func (r ApiListRecordingRequest) CallSid(callSid string) ApiListRecordingRequest {
	r.callSid = &callSid
	return r
}

// The Conference SID that identifies the conference associated with the recording to read.
func (r ApiListRecordingRequest) ConferenceSid(conferenceSid string) ApiListRecordingRequest {
	r.conferenceSid = &conferenceSid
	return r
}

// A boolean parameter indicating whether to retrieve soft deleted recordings or not. Recordings metadata are kept after deletion for a retention period of 40 days.
func (r ApiListRecordingRequest) IncludeSoftDeleted(includeSoftDeleted bool) ApiListRecordingRequest {
	r.includeSoftDeleted = &includeSoftDeleted
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListRecordingRequest) PageSize(pageSize int32) ApiListRecordingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListRecordingRequest) Execute() (*ListRecordingResponse, *http.Response, error) {
	return r.ApiService.ListRecordingExecute(r)
}

/*
ListRecording Method for ListRecording

Retrieve a list of recordings belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to read.
 @return ApiListRecordingRequest
*/
func (a *DefaultApiService) ListRecording(ctx context.Context, accountSid string) ApiListRecordingRequest {
	return ApiListRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListRecordingResponse
func (a *DefaultApiService) ListRecordingExecute(r ApiListRecordingRequest) (*ListRecordingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRecordingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.dateCreated != nil {
		localVarQueryParams.Add("DateCreated", parameterToString(*r.dateCreated, ""))
	}
	if r.dateCreated2 != nil {
		localVarQueryParams.Add("DateCreated&lt;", parameterToString(*r.dateCreated2, ""))
	}
	if r.dateCreated3 != nil {
		localVarQueryParams.Add("DateCreated&gt;", parameterToString(*r.dateCreated3, ""))
	}
	if r.callSid != nil {
		localVarQueryParams.Add("CallSid", parameterToString(*r.callSid, ""))
	}
	if r.conferenceSid != nil {
		localVarQueryParams.Add("ConferenceSid", parameterToString(*r.conferenceSid, ""))
	}
	if r.includeSoftDeleted != nil {
		localVarQueryParams.Add("IncludeSoftDeleted", parameterToString(*r.includeSoftDeleted, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRecordingAddOnResultRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	referenceSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListRecordingAddOnResultRequest) PageSize(pageSize int32) ApiListRecordingAddOnResultRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListRecordingAddOnResultRequest) Execute() (*ListRecordingAddOnResultResponse, *http.Response, error) {
	return r.ApiService.ListRecordingAddOnResultExecute(r)
}

/*
ListRecordingAddOnResult Method for ListRecordingAddOnResult

Retrieve a list of results belonging to the recording

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult resources to read.
 @param referenceSid The SID of the recording to which the result to read belongs.
 @return ApiListRecordingAddOnResultRequest
*/
func (a *DefaultApiService) ListRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string) ApiListRecordingAddOnResultRequest {
	return ApiListRecordingAddOnResultRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		referenceSid: referenceSid,
	}
}

// Execute executes the request
//  @return ListRecordingAddOnResultResponse
func (a *DefaultApiService) ListRecordingAddOnResultExecute(r ApiListRecordingAddOnResultRequest) (*ListRecordingAddOnResultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRecordingAddOnResultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecordingAddOnResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ReferenceSid"+"}", url.PathEscape(parameterToString(r.referenceSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.referenceSid) < 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have at least 34 elements")
	}
	if strlen(r.referenceSid) > 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRecordingAddOnResultPayloadRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	referenceSid string
	addOnResultSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListRecordingAddOnResultPayloadRequest) PageSize(pageSize int32) ApiListRecordingAddOnResultPayloadRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListRecordingAddOnResultPayloadRequest) Execute() (*ListRecordingAddOnResultPayloadResponse, *http.Response, error) {
	return r.ApiService.ListRecordingAddOnResultPayloadExecute(r)
}

/*
ListRecordingAddOnResultPayload Method for ListRecordingAddOnResultPayload

Retrieve a list of payloads belonging to the AddOnResult

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult Payload resources to read.
 @param referenceSid The SID of the recording to which the AddOnResult resource that contains the payloads to read belongs.
 @param addOnResultSid The SID of the AddOnResult to which the payloads to read belongs.
 @return ApiListRecordingAddOnResultPayloadRequest
*/
func (a *DefaultApiService) ListRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string) ApiListRecordingAddOnResultPayloadRequest {
	return ApiListRecordingAddOnResultPayloadRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		referenceSid: referenceSid,
		addOnResultSid: addOnResultSid,
	}
}

// Execute executes the request
//  @return ListRecordingAddOnResultPayloadResponse
func (a *DefaultApiService) ListRecordingAddOnResultPayloadExecute(r ApiListRecordingAddOnResultPayloadRequest) (*ListRecordingAddOnResultPayloadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRecordingAddOnResultPayloadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecordingAddOnResultPayload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ReferenceSid"+"}", url.PathEscape(parameterToString(r.referenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"AddOnResultSid"+"}", url.PathEscape(parameterToString(r.addOnResultSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.referenceSid) < 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have at least 34 elements")
	}
	if strlen(r.referenceSid) > 34 {
		return localVarReturnValue, nil, reportError("referenceSid must have less than 34 elements")
	}
	if strlen(r.addOnResultSid) < 34 {
		return localVarReturnValue, nil, reportError("addOnResultSid must have at least 34 elements")
	}
	if strlen(r.addOnResultSid) > 34 {
		return localVarReturnValue, nil, reportError("addOnResultSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRecordingTranscriptionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	recordingSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListRecordingTranscriptionRequest) PageSize(pageSize int32) ApiListRecordingTranscriptionRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListRecordingTranscriptionRequest) Execute() (*ListRecordingTranscriptionResponse, *http.Response, error) {
	return r.ApiService.ListRecordingTranscriptionExecute(r)
}

/*
ListRecordingTranscription Method for ListRecordingTranscription



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to read.
 @param recordingSid The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) that created the transcriptions to read.
 @return ApiListRecordingTranscriptionRequest
*/
func (a *DefaultApiService) ListRecordingTranscription(ctx context.Context, accountSid string, recordingSid string) ApiListRecordingTranscriptionRequest {
	return ApiListRecordingTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		recordingSid: recordingSid,
	}
}

// Execute executes the request
//  @return ListRecordingTranscriptionResponse
func (a *DefaultApiService) ListRecordingTranscriptionExecute(r ApiListRecordingTranscriptionRequest) (*ListRecordingTranscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListRecordingTranscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRecordingTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"RecordingSid"+"}", url.PathEscape(parameterToString(r.recordingSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.recordingSid) < 34 {
		return localVarReturnValue, nil, reportError("recordingSid must have at least 34 elements")
	}
	if strlen(r.recordingSid) > 34 {
		return localVarReturnValue, nil, reportError("recordingSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListShortCodeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	friendlyName *string
	shortCode *string
	pageSize *int32
}

// The string that identifies the ShortCode resources to read.
func (r ApiListShortCodeRequest) FriendlyName(friendlyName string) ApiListShortCodeRequest {
	r.friendlyName = &friendlyName
	return r
}

// Only show the ShortCode resources that match this pattern. You can specify partial numbers and use &#39;*&#39; as a wildcard for any digit.
func (r ApiListShortCodeRequest) ShortCode(shortCode string) ApiListShortCodeRequest {
	r.shortCode = &shortCode
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListShortCodeRequest) PageSize(pageSize int32) ApiListShortCodeRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListShortCodeRequest) Execute() (*ListShortCodeResponse, *http.Response, error) {
	return r.ApiService.ListShortCodeExecute(r)
}

/*
ListShortCode Method for ListShortCode

Retrieve a list of short-codes belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ShortCode resource(s) to read.
 @return ApiListShortCodeRequest
*/
func (a *DefaultApiService) ListShortCode(ctx context.Context, accountSid string) ApiListShortCodeRequest {
	return ApiListShortCodeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListShortCodeResponse
func (a *DefaultApiService) ListShortCodeExecute(r ApiListShortCodeRequest) (*ListShortCodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListShortCodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListShortCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.friendlyName != nil {
		localVarQueryParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.shortCode != nil {
		localVarQueryParams.Add("ShortCode", parameterToString(*r.shortCode, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSigningKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSigningKeyRequest) PageSize(pageSize int32) ApiListSigningKeyRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSigningKeyRequest) Execute() (*ListSigningKeyResponse, *http.Response, error) {
	return r.ApiService.ListSigningKeyExecute(r)
}

/*
ListSigningKey Method for ListSigningKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid 
 @return ApiListSigningKeyRequest
*/
func (a *DefaultApiService) ListSigningKey(ctx context.Context, accountSid string) ApiListSigningKeyRequest {
	return ApiListSigningKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListSigningKeyResponse
func (a *DefaultApiService) ListSigningKeyExecute(r ApiListSigningKeyRequest) (*ListSigningKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSigningKeyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSigningKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SigningKeys.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipAuthCallsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipAuthCallsCredentialListMappingRequest) PageSize(pageSize int32) ApiListSipAuthCallsCredentialListMappingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipAuthCallsCredentialListMappingRequest) Execute() (*ListSipAuthCallsCredentialListMappingResponse, *http.Response, error) {
	return r.ApiService.ListSipAuthCallsCredentialListMappingExecute(r)
}

/*
ListSipAuthCallsCredentialListMapping Method for ListSipAuthCallsCredentialListMapping

Retrieve a list of credential list mappings belonging to the domain used in the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to read.
 @param domainSid The SID of the SIP domain that contains the resources to read.
 @return ApiListSipAuthCallsCredentialListMappingRequest
*/
func (a *DefaultApiService) ListSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string) ApiListSipAuthCallsCredentialListMappingRequest {
	return ApiListSipAuthCallsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ListSipAuthCallsCredentialListMappingResponse
func (a *DefaultApiService) ListSipAuthCallsCredentialListMappingExecute(r ApiListSipAuthCallsCredentialListMappingRequest) (*ListSipAuthCallsCredentialListMappingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipAuthCallsCredentialListMappingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipAuthCallsCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipAuthCallsIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipAuthCallsIpAccessControlListMappingRequest) PageSize(pageSize int32) ApiListSipAuthCallsIpAccessControlListMappingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipAuthCallsIpAccessControlListMappingRequest) Execute() (*ListSipAuthCallsIpAccessControlListMappingResponse, *http.Response, error) {
	return r.ApiService.ListSipAuthCallsIpAccessControlListMappingExecute(r)
}

/*
ListSipAuthCallsIpAccessControlListMapping Method for ListSipAuthCallsIpAccessControlListMapping

Retrieve a list of IP Access Control List mappings belonging to the domain used in the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlListMapping resources to read.
 @param domainSid The SID of the SIP domain that contains the resources to read.
 @return ApiListSipAuthCallsIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) ListSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string) ApiListSipAuthCallsIpAccessControlListMappingRequest {
	return ApiListSipAuthCallsIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ListSipAuthCallsIpAccessControlListMappingResponse
func (a *DefaultApiService) ListSipAuthCallsIpAccessControlListMappingExecute(r ApiListSipAuthCallsIpAccessControlListMappingRequest) (*ListSipAuthCallsIpAccessControlListMappingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipAuthCallsIpAccessControlListMappingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipAuthCallsIpAccessControlListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipAuthRegistrationsCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipAuthRegistrationsCredentialListMappingRequest) PageSize(pageSize int32) ApiListSipAuthRegistrationsCredentialListMappingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipAuthRegistrationsCredentialListMappingRequest) Execute() (*ListSipAuthRegistrationsCredentialListMappingResponse, *http.Response, error) {
	return r.ApiService.ListSipAuthRegistrationsCredentialListMappingExecute(r)
}

/*
ListSipAuthRegistrationsCredentialListMapping Method for ListSipAuthRegistrationsCredentialListMapping

Retrieve a list of credential list mappings belonging to the domain used in the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to read.
 @param domainSid The SID of the SIP domain that contains the resources to read.
 @return ApiListSipAuthRegistrationsCredentialListMappingRequest
*/
func (a *DefaultApiService) ListSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string) ApiListSipAuthRegistrationsCredentialListMappingRequest {
	return ApiListSipAuthRegistrationsCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ListSipAuthRegistrationsCredentialListMappingResponse
func (a *DefaultApiService) ListSipAuthRegistrationsCredentialListMappingExecute(r ApiListSipAuthRegistrationsCredentialListMappingRequest) (*ListSipAuthRegistrationsCredentialListMappingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipAuthRegistrationsCredentialListMappingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipAuthRegistrationsCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipCredentialRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	credentialListSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipCredentialRequest) PageSize(pageSize int32) ApiListSipCredentialRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipCredentialRequest) Execute() (*ListSipCredentialResponse, *http.Response, error) {
	return r.ApiService.ListSipCredentialExecute(r)
}

/*
ListSipCredential Method for ListSipCredential

Retrieve a list of credentials.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param credentialListSid The unique id that identifies the credential list that contains the desired credentials.
 @return ApiListSipCredentialRequest
*/
func (a *DefaultApiService) ListSipCredential(ctx context.Context, accountSid string, credentialListSid string) ApiListSipCredentialRequest {
	return ApiListSipCredentialRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		credentialListSid: credentialListSid,
	}
}

// Execute executes the request
//  @return ListSipCredentialResponse
func (a *DefaultApiService) ListSipCredentialExecute(r ApiListSipCredentialRequest) (*ListSipCredentialResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipCredentialResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CredentialListSid"+"}", url.PathEscape(parameterToString(r.credentialListSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipCredentialListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipCredentialListRequest) PageSize(pageSize int32) ApiListSipCredentialListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipCredentialListRequest) Execute() (*ListSipCredentialListResponse, *http.Response, error) {
	return r.ApiService.ListSipCredentialListExecute(r)
}

/*
ListSipCredentialList Method for ListSipCredentialList

Get All Credential Lists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @return ApiListSipCredentialListRequest
*/
func (a *DefaultApiService) ListSipCredentialList(ctx context.Context, accountSid string) ApiListSipCredentialListRequest {
	return ApiListSipCredentialListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListSipCredentialListResponse
func (a *DefaultApiService) ListSipCredentialListExecute(r ApiListSipCredentialListRequest) (*ListSipCredentialListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipCredentialListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipCredentialList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipCredentialListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipCredentialListMappingRequest) PageSize(pageSize int32) ApiListSipCredentialListMappingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipCredentialListMappingRequest) Execute() (*ListSipCredentialListMappingResponse, *http.Response, error) {
	return r.ApiService.ListSipCredentialListMappingExecute(r)
}

/*
ListSipCredentialListMapping Method for ListSipCredentialListMapping

Read multiple CredentialListMapping resources from an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP Domain that includes the resource to read.
 @return ApiListSipCredentialListMappingRequest
*/
func (a *DefaultApiService) ListSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string) ApiListSipCredentialListMappingRequest {
	return ApiListSipCredentialListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ListSipCredentialListMappingResponse
func (a *DefaultApiService) ListSipCredentialListMappingExecute(r ApiListSipCredentialListMappingRequest) (*ListSipCredentialListMappingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipCredentialListMappingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipCredentialListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipDomainRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipDomainRequest) PageSize(pageSize int32) ApiListSipDomainRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipDomainRequest) Execute() (*ListSipDomainResponse, *http.Response, error) {
	return r.ApiService.ListSipDomainExecute(r)
}

/*
ListSipDomain Method for ListSipDomain

Retrieve a list of domains belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resources to read.
 @return ApiListSipDomainRequest
*/
func (a *DefaultApiService) ListSipDomain(ctx context.Context, accountSid string) ApiListSipDomainRequest {
	return ApiListSipDomainRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListSipDomainResponse
func (a *DefaultApiService) ListSipDomainExecute(r ApiListSipDomainRequest) (*ListSipDomainResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipDomainResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipIpAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipIpAccessControlListRequest) PageSize(pageSize int32) ApiListSipIpAccessControlListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipIpAccessControlListRequest) Execute() (*ListSipIpAccessControlListResponse, *http.Response, error) {
	return r.ApiService.ListSipIpAccessControlListExecute(r)
}

/*
ListSipIpAccessControlList Method for ListSipIpAccessControlList

Retrieve a list of IpAccessControlLists that belong to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @return ApiListSipIpAccessControlListRequest
*/
func (a *DefaultApiService) ListSipIpAccessControlList(ctx context.Context, accountSid string) ApiListSipIpAccessControlListRequest {
	return ApiListSipIpAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListSipIpAccessControlListResponse
func (a *DefaultApiService) ListSipIpAccessControlListExecute(r ApiListSipIpAccessControlListRequest) (*ListSipIpAccessControlListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipIpAccessControlListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipIpAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipIpAccessControlListMappingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	domainSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipIpAccessControlListMappingRequest) PageSize(pageSize int32) ApiListSipIpAccessControlListMappingRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipIpAccessControlListMappingRequest) Execute() (*ListSipIpAccessControlListMappingResponse, *http.Response, error) {
	return r.ApiService.ListSipIpAccessControlListMappingExecute(r)
}

/*
ListSipIpAccessControlListMapping Method for ListSipIpAccessControlListMapping

Retrieve a list of IpAccessControlListMapping resources.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param domainSid A 34 character string that uniquely identifies the SIP domain.
 @return ApiListSipIpAccessControlListMappingRequest
*/
func (a *DefaultApiService) ListSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string) ApiListSipIpAccessControlListMappingRequest {
	return ApiListSipIpAccessControlListMappingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		domainSid: domainSid,
	}
}

// Execute executes the request
//  @return ListSipIpAccessControlListMappingResponse
func (a *DefaultApiService) ListSipIpAccessControlListMappingExecute(r ApiListSipIpAccessControlListMappingRequest) (*ListSipIpAccessControlListMappingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipIpAccessControlListMappingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipIpAccessControlListMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"DomainSid"+"}", url.PathEscape(parameterToString(r.domainSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.domainSid) < 34 {
		return localVarReturnValue, nil, reportError("domainSid must have at least 34 elements")
	}
	if strlen(r.domainSid) > 34 {
		return localVarReturnValue, nil, reportError("domainSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSipIpAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	ipAccessControlListSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListSipIpAddressRequest) PageSize(pageSize int32) ApiListSipIpAddressRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSipIpAddressRequest) Execute() (*ListSipIpAddressResponse, *http.Response, error) {
	return r.ApiService.ListSipIpAddressExecute(r)
}

/*
ListSipIpAddress Method for ListSipIpAddress

Read multiple IpAddress resources.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param ipAccessControlListSid The IpAccessControlList Sid that identifies the IpAddress resources to read.
 @return ApiListSipIpAddressRequest
*/
func (a *DefaultApiService) ListSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string) ApiListSipIpAddressRequest {
	return ApiListSipIpAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		ipAccessControlListSid: ipAccessControlListSid,
	}
}

// Execute executes the request
//  @return ListSipIpAddressResponse
func (a *DefaultApiService) ListSipIpAddressExecute(r ApiListSipIpAddressRequest) (*ListSipIpAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSipIpAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSipIpAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"IpAccessControlListSid"+"}", url.PathEscape(parameterToString(r.ipAccessControlListSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.ipAccessControlListSid) < 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(r.ipAccessControlListSid) > 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTranscriptionRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	pageSize *int32
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListTranscriptionRequest) PageSize(pageSize int32) ApiListTranscriptionRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListTranscriptionRequest) Execute() (*ListTranscriptionResponse, *http.Response, error) {
	return r.ApiService.ListTranscriptionExecute(r)
}

/*
ListTranscription Method for ListTranscription

Retrieve a list of transcriptions belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to read.
 @return ApiListTranscriptionRequest
*/
func (a *DefaultApiService) ListTranscription(ctx context.Context, accountSid string) ApiListTranscriptionRequest {
	return ApiListTranscriptionRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListTranscriptionResponse
func (a *DefaultApiService) ListTranscriptionExecute(r ApiListTranscriptionRequest) (*ListTranscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTranscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTranscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Transcriptions.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordRequest) Category(category string) ApiListUsageRecordRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordRequest) StartDate(startDate string) ApiListUsageRecordRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordRequest) EndDate(endDate string) ApiListUsageRecordRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordRequest) PageSize(pageSize int32) ApiListUsageRecordRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordRequest) Execute() (*ListUsageRecordResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordExecute(r)
}

/*
ListUsageRecord Method for ListUsageRecord

Retrieve a list of usage-records belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordRequest
*/
func (a *DefaultApiService) ListUsageRecord(ctx context.Context, accountSid string) ApiListUsageRecordRequest {
	return ApiListUsageRecordRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordResponse
func (a *DefaultApiService) ListUsageRecordExecute(r ApiListUsageRecordRequest) (*ListUsageRecordResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordAllTimeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordAllTimeRequest) Category(category string) ApiListUsageRecordAllTimeRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordAllTimeRequest) StartDate(startDate string) ApiListUsageRecordAllTimeRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordAllTimeRequest) EndDate(endDate string) ApiListUsageRecordAllTimeRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordAllTimeRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordAllTimeRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordAllTimeRequest) PageSize(pageSize int32) ApiListUsageRecordAllTimeRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordAllTimeRequest) Execute() (*ListUsageRecordAllTimeResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordAllTimeExecute(r)
}

/*
ListUsageRecordAllTime Method for ListUsageRecordAllTime



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordAllTimeRequest
*/
func (a *DefaultApiService) ListUsageRecordAllTime(ctx context.Context, accountSid string) ApiListUsageRecordAllTimeRequest {
	return ApiListUsageRecordAllTimeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordAllTimeResponse
func (a *DefaultApiService) ListUsageRecordAllTimeExecute(r ApiListUsageRecordAllTimeRequest) (*ListUsageRecordAllTimeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordAllTimeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordAllTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordDailyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordDailyRequest) Category(category string) ApiListUsageRecordDailyRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordDailyRequest) StartDate(startDate string) ApiListUsageRecordDailyRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordDailyRequest) EndDate(endDate string) ApiListUsageRecordDailyRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordDailyRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordDailyRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordDailyRequest) PageSize(pageSize int32) ApiListUsageRecordDailyRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordDailyRequest) Execute() (*ListUsageRecordDailyResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordDailyExecute(r)
}

/*
ListUsageRecordDaily Method for ListUsageRecordDaily



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordDailyRequest
*/
func (a *DefaultApiService) ListUsageRecordDaily(ctx context.Context, accountSid string) ApiListUsageRecordDailyRequest {
	return ApiListUsageRecordDailyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordDailyResponse
func (a *DefaultApiService) ListUsageRecordDailyExecute(r ApiListUsageRecordDailyRequest) (*ListUsageRecordDailyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordDailyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordDaily")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordLastMonthRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordLastMonthRequest) Category(category string) ApiListUsageRecordLastMonthRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordLastMonthRequest) StartDate(startDate string) ApiListUsageRecordLastMonthRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordLastMonthRequest) EndDate(endDate string) ApiListUsageRecordLastMonthRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordLastMonthRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordLastMonthRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordLastMonthRequest) PageSize(pageSize int32) ApiListUsageRecordLastMonthRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordLastMonthRequest) Execute() (*ListUsageRecordLastMonthResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordLastMonthExecute(r)
}

/*
ListUsageRecordLastMonth Method for ListUsageRecordLastMonth



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordLastMonthRequest
*/
func (a *DefaultApiService) ListUsageRecordLastMonth(ctx context.Context, accountSid string) ApiListUsageRecordLastMonthRequest {
	return ApiListUsageRecordLastMonthRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordLastMonthResponse
func (a *DefaultApiService) ListUsageRecordLastMonthExecute(r ApiListUsageRecordLastMonthRequest) (*ListUsageRecordLastMonthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordLastMonthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordLastMonth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordMonthlyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordMonthlyRequest) Category(category string) ApiListUsageRecordMonthlyRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordMonthlyRequest) StartDate(startDate string) ApiListUsageRecordMonthlyRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordMonthlyRequest) EndDate(endDate string) ApiListUsageRecordMonthlyRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordMonthlyRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordMonthlyRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordMonthlyRequest) PageSize(pageSize int32) ApiListUsageRecordMonthlyRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordMonthlyRequest) Execute() (*ListUsageRecordMonthlyResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordMonthlyExecute(r)
}

/*
ListUsageRecordMonthly Method for ListUsageRecordMonthly



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordMonthlyRequest
*/
func (a *DefaultApiService) ListUsageRecordMonthly(ctx context.Context, accountSid string) ApiListUsageRecordMonthlyRequest {
	return ApiListUsageRecordMonthlyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordMonthlyResponse
func (a *DefaultApiService) ListUsageRecordMonthlyExecute(r ApiListUsageRecordMonthlyRequest) (*ListUsageRecordMonthlyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordMonthlyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordMonthly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordThisMonthRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordThisMonthRequest) Category(category string) ApiListUsageRecordThisMonthRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordThisMonthRequest) StartDate(startDate string) ApiListUsageRecordThisMonthRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordThisMonthRequest) EndDate(endDate string) ApiListUsageRecordThisMonthRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordThisMonthRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordThisMonthRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordThisMonthRequest) PageSize(pageSize int32) ApiListUsageRecordThisMonthRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordThisMonthRequest) Execute() (*ListUsageRecordThisMonthResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordThisMonthExecute(r)
}

/*
ListUsageRecordThisMonth Method for ListUsageRecordThisMonth



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordThisMonthRequest
*/
func (a *DefaultApiService) ListUsageRecordThisMonth(ctx context.Context, accountSid string) ApiListUsageRecordThisMonthRequest {
	return ApiListUsageRecordThisMonthRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordThisMonthResponse
func (a *DefaultApiService) ListUsageRecordThisMonthExecute(r ApiListUsageRecordThisMonthRequest) (*ListUsageRecordThisMonthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordThisMonthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordThisMonth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordTodayRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordTodayRequest) Category(category string) ApiListUsageRecordTodayRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordTodayRequest) StartDate(startDate string) ApiListUsageRecordTodayRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordTodayRequest) EndDate(endDate string) ApiListUsageRecordTodayRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordTodayRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordTodayRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordTodayRequest) PageSize(pageSize int32) ApiListUsageRecordTodayRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordTodayRequest) Execute() (*ListUsageRecordTodayResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordTodayExecute(r)
}

/*
ListUsageRecordToday Method for ListUsageRecordToday



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordTodayRequest
*/
func (a *DefaultApiService) ListUsageRecordToday(ctx context.Context, accountSid string) ApiListUsageRecordTodayRequest {
	return ApiListUsageRecordTodayRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordTodayResponse
func (a *DefaultApiService) ListUsageRecordTodayExecute(r ApiListUsageRecordTodayRequest) (*ListUsageRecordTodayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordTodayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordToday")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordYearlyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordYearlyRequest) Category(category string) ApiListUsageRecordYearlyRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordYearlyRequest) StartDate(startDate string) ApiListUsageRecordYearlyRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordYearlyRequest) EndDate(endDate string) ApiListUsageRecordYearlyRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordYearlyRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordYearlyRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordYearlyRequest) PageSize(pageSize int32) ApiListUsageRecordYearlyRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordYearlyRequest) Execute() (*ListUsageRecordYearlyResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordYearlyExecute(r)
}

/*
ListUsageRecordYearly Method for ListUsageRecordYearly



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordYearlyRequest
*/
func (a *DefaultApiService) ListUsageRecordYearly(ctx context.Context, accountSid string) ApiListUsageRecordYearlyRequest {
	return ApiListUsageRecordYearlyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordYearlyResponse
func (a *DefaultApiService) ListUsageRecordYearlyExecute(r ApiListUsageRecordYearlyRequest) (*ListUsageRecordYearlyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordYearlyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordYearly")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageRecordYesterdayRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	category *string
	startDate *string
	endDate *string
	includeSubaccounts *bool
	pageSize *int32
}

// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
func (r ApiListUsageRecordYesterdayRequest) Category(category string) ApiListUsageRecordYesterdayRequest {
	r.category = &category
	return r
}

// Only include usage that has occurred on or after this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;. You can also specify offsets from the current date, such as: &#x60;-30days&#x60;, which will set the start date to be 30 days before the current date.
func (r ApiListUsageRecordYesterdayRequest) StartDate(startDate string) ApiListUsageRecordYesterdayRequest {
	r.startDate = &startDate
	return r
}

// Only include usage that occurred on or before this date. Specify the date in GMT and format as &#x60;YYYY-MM-DD&#x60;.  You can also specify offsets from the current date, such as: &#x60;+30days&#x60;, which will set the end date to 30 days from the current date.
func (r ApiListUsageRecordYesterdayRequest) EndDate(endDate string) ApiListUsageRecordYesterdayRequest {
	r.endDate = &endDate
	return r
}

// Whether to include usage from the master account and all its subaccounts. Can be: &#x60;true&#x60; (the default) to include usage from the master account and all subaccounts or &#x60;false&#x60; to retrieve usage from only the specified account.
func (r ApiListUsageRecordYesterdayRequest) IncludeSubaccounts(includeSubaccounts bool) ApiListUsageRecordYesterdayRequest {
	r.includeSubaccounts = &includeSubaccounts
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageRecordYesterdayRequest) PageSize(pageSize int32) ApiListUsageRecordYesterdayRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageRecordYesterdayRequest) Execute() (*ListUsageRecordYesterdayResponse, *http.Response, error) {
	return r.ApiService.ListUsageRecordYesterdayExecute(r)
}

/*
ListUsageRecordYesterday Method for ListUsageRecordYesterday



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
 @return ApiListUsageRecordYesterdayRequest
*/
func (a *DefaultApiService) ListUsageRecordYesterday(ctx context.Context, accountSid string) ApiListUsageRecordYesterdayRequest {
	return ApiListUsageRecordYesterdayRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageRecordYesterdayResponse
func (a *DefaultApiService) ListUsageRecordYesterdayExecute(r ApiListUsageRecordYesterdayRequest) (*ListUsageRecordYesterdayResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageRecordYesterdayResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageRecordYesterday")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.category != nil {
		localVarQueryParams.Add("Category", parameterToString(*r.category, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("StartDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("EndDate", parameterToString(*r.endDate, ""))
	}
	if r.includeSubaccounts != nil {
		localVarQueryParams.Add("IncludeSubaccounts", parameterToString(*r.includeSubaccounts, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsageTriggerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	recurring *string
	triggerBy *string
	usageCategory *string
	pageSize *int32
}

// The frequency of recurring UsageTriggers to read. Can be: &#x60;daily&#x60;, &#x60;monthly&#x60;, or &#x60;yearly&#x60; to read recurring UsageTriggers. An empty value or a value of &#x60;alltime&#x60; reads non-recurring UsageTriggers.
func (r ApiListUsageTriggerRequest) Recurring(recurring string) ApiListUsageTriggerRequest {
	r.recurring = &recurring
	return r
}

// The trigger field of the UsageTriggers to read.  Can be: &#x60;count&#x60;, &#x60;usage&#x60;, or &#x60;price&#x60; as described in the [UsageRecords documentation](https://www.twilio.com/docs/usage/api/usage-record#usage-count-price).
func (r ApiListUsageTriggerRequest) TriggerBy(triggerBy string) ApiListUsageTriggerRequest {
	r.triggerBy = &triggerBy
	return r
}

// The usage category of the UsageTriggers to read. Must be a supported [usage categories](https://www.twilio.com/docs/usage/api/usage-record#usage-categories).
func (r ApiListUsageTriggerRequest) UsageCategory(usageCategory string) ApiListUsageTriggerRequest {
	r.usageCategory = &usageCategory
	return r
}

// How many resources to return in each list page. The default is 50, and the maximum is 1000.
func (r ApiListUsageTriggerRequest) PageSize(pageSize int32) ApiListUsageTriggerRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListUsageTriggerRequest) Execute() (*ListUsageTriggerResponse, *http.Response, error) {
	return r.ApiService.ListUsageTriggerExecute(r)
}

/*
ListUsageTrigger Method for ListUsageTrigger

Retrieve a list of usage-triggers belonging to the account used to make the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resources to read.
 @return ApiListUsageTriggerRequest
*/
func (a *DefaultApiService) ListUsageTrigger(ctx context.Context, accountSid string) ApiListUsageTriggerRequest {
	return ApiListUsageTriggerRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
	}
}

// Execute executes the request
//  @return ListUsageTriggerResponse
func (a *DefaultApiService) ListUsageTriggerExecute(r ApiListUsageTriggerRequest) (*ListUsageTriggerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListUsageTriggerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUsageTrigger")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	if r.recurring != nil {
		localVarQueryParams.Add("Recurring", parameterToString(*r.recurring, ""))
	}
	if r.triggerBy != nil {
		localVarQueryParams.Add("TriggerBy", parameterToString(*r.triggerBy, ""))
	}
	if r.usageCategory != nil {
		localVarQueryParams.Add("UsageCategory", parameterToString(*r.usageCategory, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("PageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	sid string
	friendlyName *string
	status *string
}

// Update the human-readable description of this Account
func (r ApiUpdateAccountRequest) FriendlyName(friendlyName string) ApiUpdateAccountRequest {
	r.friendlyName = &friendlyName
	return r
}

// Alter the status of this account: use &#x60;closed&#x60; to irreversibly close this account, &#x60;suspended&#x60; to temporarily suspend it, or &#x60;active&#x60; to reactivate it.
func (r ApiUpdateAccountRequest) Status(status string) ApiUpdateAccountRequest {
	r.status = &status
	return r
}

func (r ApiUpdateAccountRequest) Execute() (*ApiV2010Account, *http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Method for UpdateAccount

Modify the properties of a given Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sid The Account Sid that uniquely identifies the account to update
 @return ApiUpdateAccountRequest
*/
func (a *DefaultApiService) UpdateAccount(ctx context.Context, sid string) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010Account
func (a *DefaultApiService) UpdateAccountExecute(r ApiUpdateAccountRequest) (*ApiV2010Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.status != nil {
		localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	autoCorrectAddress *bool
	city *string
	customerName *string
	emergencyEnabled *bool
	friendlyName *string
	postalCode *string
	region *string
	street *string
}

// Whether we should automatically correct the address. Can be: &#x60;true&#x60; or &#x60;false&#x60; and the default is &#x60;true&#x60;. If empty or &#x60;true&#x60;, we will correct the address you provide if necessary. If &#x60;false&#x60;, we won&#39;t alter the address you provide.
func (r ApiUpdateAddressRequest) AutoCorrectAddress(autoCorrectAddress bool) ApiUpdateAddressRequest {
	r.autoCorrectAddress = &autoCorrectAddress
	return r
}

// The city of the address.
func (r ApiUpdateAddressRequest) City(city string) ApiUpdateAddressRequest {
	r.city = &city
	return r
}

// The name to associate with the address.
func (r ApiUpdateAddressRequest) CustomerName(customerName string) ApiUpdateAddressRequest {
	r.customerName = &customerName
	return r
}

// Whether to enable emergency calling on the address. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiUpdateAddressRequest) EmergencyEnabled(emergencyEnabled bool) ApiUpdateAddressRequest {
	r.emergencyEnabled = &emergencyEnabled
	return r
}

// A descriptive string that you create to describe the address. It can be up to 64 characters long.
func (r ApiUpdateAddressRequest) FriendlyName(friendlyName string) ApiUpdateAddressRequest {
	r.friendlyName = &friendlyName
	return r
}

// The postal code of the address.
func (r ApiUpdateAddressRequest) PostalCode(postalCode string) ApiUpdateAddressRequest {
	r.postalCode = &postalCode
	return r
}

// The state or region of the address.
func (r ApiUpdateAddressRequest) Region(region string) ApiUpdateAddressRequest {
	r.region = &region
	return r
}

// The number and street address of the address.
func (r ApiUpdateAddressRequest) Street(street string) ApiUpdateAddressRequest {
	r.street = &street
	return r
}

func (r ApiUpdateAddressRequest) Execute() (*ApiV2010AccountAddress, *http.Response, error) {
	return r.ApiService.UpdateAddressExecute(r)
}

/*
UpdateAddress Method for UpdateAddress



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to update.
 @param sid The Twilio-provided string that uniquely identifies the Address resource to update.
 @return ApiUpdateAddressRequest
*/
func (a *DefaultApiService) UpdateAddress(ctx context.Context, accountSid string, sid string) ApiUpdateAddressRequest {
	return ApiUpdateAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountAddress
func (a *DefaultApiService) UpdateAddressExecute(r ApiUpdateAddressRequest) (*ApiV2010AccountAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.autoCorrectAddress != nil {
		localVarFormParams.Add("AutoCorrectAddress", parameterToString(*r.autoCorrectAddress, ""))
	}
	if r.city != nil {
		localVarFormParams.Add("City", parameterToString(*r.city, ""))
	}
	if r.customerName != nil {
		localVarFormParams.Add("CustomerName", parameterToString(*r.customerName, ""))
	}
	if r.emergencyEnabled != nil {
		localVarFormParams.Add("EmergencyEnabled", parameterToString(*r.emergencyEnabled, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.postalCode != nil {
		localVarFormParams.Add("PostalCode", parameterToString(*r.postalCode, ""))
	}
	if r.region != nil {
		localVarFormParams.Add("Region", parameterToString(*r.region, ""))
	}
	if r.street != nil {
		localVarFormParams.Add("Street", parameterToString(*r.street, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	apiVersion *string
	friendlyName *string
	messageStatusCallback *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsStatusCallback *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceUrl *string
}

// The API version to use to start a new TwiML session. Can be: &#x60;2010-04-01&#x60; or &#x60;2008-08-01&#x60;. The default value is your account&#39;s default API version.
func (r ApiUpdateApplicationRequest) ApiVersion(apiVersion string) ApiUpdateApplicationRequest {
	r.apiVersion = &apiVersion
	return r
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiUpdateApplicationRequest) FriendlyName(friendlyName string) ApiUpdateApplicationRequest {
	r.friendlyName = &friendlyName
	return r
}

// The URL we should call using a POST method to send message status information to your application.
func (r ApiUpdateApplicationRequest) MessageStatusCallback(messageStatusCallback string) ApiUpdateApplicationRequest {
	r.messageStatusCallback = &messageStatusCallback
	return r
}

// The HTTP method we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateApplicationRequest) SmsFallbackMethod(smsFallbackMethod string) ApiUpdateApplicationRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while retrieving or executing the TwiML from &#x60;sms_url&#x60;.
func (r ApiUpdateApplicationRequest) SmsFallbackUrl(smsFallbackUrl string) ApiUpdateApplicationRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateApplicationRequest) SmsMethod(smsMethod string) ApiUpdateApplicationRequest {
	r.smsMethod = &smsMethod
	return r
}

// Same as message_status_callback: The URL we should call using a POST method to send status information about SMS messages sent by the application. Deprecated, included for backwards compatibility.
func (r ApiUpdateApplicationRequest) SmsStatusCallback(smsStatusCallback string) ApiUpdateApplicationRequest {
	r.smsStatusCallback = &smsStatusCallback
	return r
}

// The URL we should call when the phone number receives an incoming SMS message.
func (r ApiUpdateApplicationRequest) SmsUrl(smsUrl string) ApiUpdateApplicationRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiUpdateApplicationRequest) StatusCallback(statusCallback string) ApiUpdateApplicationRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateApplicationRequest) StatusCallbackMethod(statusCallbackMethod string) ApiUpdateApplicationRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// Whether we should look up the caller&#39;s caller-ID name from the CNAM database (additional charges apply). Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiUpdateApplicationRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiUpdateApplicationRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateApplicationRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiUpdateApplicationRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiUpdateApplicationRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiUpdateApplicationRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateApplicationRequest) VoiceMethod(voiceMethod string) ApiUpdateApplicationRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The URL we should call when the phone number assigned to this application receives a call.
func (r ApiUpdateApplicationRequest) VoiceUrl(voiceUrl string) ApiUpdateApplicationRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiUpdateApplicationRequest) Execute() (*ApiV2010AccountApplication, *http.Response, error) {
	return r.ApiService.UpdateApplicationExecute(r)
}

/*
UpdateApplication Method for UpdateApplication

Updates the application's properties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resources to update.
 @param sid The Twilio-provided string that uniquely identifies the Application resource to update.
 @return ApiUpdateApplicationRequest
*/
func (a *DefaultApiService) UpdateApplication(ctx context.Context, accountSid string, sid string) ApiUpdateApplicationRequest {
	return ApiUpdateApplicationRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountApplication
func (a *DefaultApiService) UpdateApplicationExecute(r ApiUpdateApplicationRequest) (*ApiV2010AccountApplication, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.messageStatusCallback != nil {
		localVarFormParams.Add("MessageStatusCallback", parameterToString(*r.messageStatusCallback, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsStatusCallback != nil {
		localVarFormParams.Add("SmsStatusCallback", parameterToString(*r.smsStatusCallback, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCallRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	fallbackMethod *string
	fallbackUrl *string
	method *string
	status *string
	statusCallback *string
	statusCallbackMethod *string
	timeLimit *int32
	twiml *string
	url *string
}

// The HTTP method that we should use to request the &#x60;fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiUpdateCallRequest) FallbackMethod(fallbackMethod string) ApiUpdateCallRequest {
	r.fallbackMethod = &fallbackMethod
	return r
}

// The URL that we call using the &#x60;fallback_method&#x60; if an error occurs when requesting or executing the TwiML at &#x60;url&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiUpdateCallRequest) FallbackUrl(fallbackUrl string) ApiUpdateCallRequest {
	r.fallbackUrl = &fallbackUrl
	return r
}

// The HTTP method we should use when calling the &#x60;url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiUpdateCallRequest) Method(method string) ApiUpdateCallRequest {
	r.method = &method
	return r
}

// The new status of the resource. Can be: &#x60;canceled&#x60; or &#x60;completed&#x60;. Specifying &#x60;canceled&#x60; will attempt to hang up calls that are queued or ringing; however, it will not affect calls already in progress. Specifying &#x60;completed&#x60; will attempt to hang up a call even if it&#39;s already in progress.
func (r ApiUpdateCallRequest) Status(status string) ApiUpdateCallRequest {
	r.status = &status
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application. If no &#x60;status_callback_event&#x60; is specified, we will send the &#x60;completed&#x60; status. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored. URLs must contain a valid hostname (underscores are not permitted).
func (r ApiUpdateCallRequest) StatusCallback(statusCallback string) ApiUpdateCallRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use when requesting the &#x60;status_callback&#x60; URL. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. If an &#x60;application_sid&#x60; parameter is present, this parameter is ignored.
func (r ApiUpdateCallRequest) StatusCallbackMethod(statusCallbackMethod string) ApiUpdateCallRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The maximum duration of the call in seconds. Constraints depend on account and configuration.
func (r ApiUpdateCallRequest) TimeLimit(timeLimit int32) ApiUpdateCallRequest {
	r.timeLimit = &timeLimit
	return r
}

// TwiML instructions for the call Twilio will use without fetching Twiml from url. Twiml and url parameters are mutually exclusive
func (r ApiUpdateCallRequest) Twiml(twiml string) ApiUpdateCallRequest {
	r.twiml = &twiml
	return r
}

// The absolute URL that returns the TwiML instructions for the call. We will call this URL using the &#x60;method&#x60; when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls).
func (r ApiUpdateCallRequest) Url(url string) ApiUpdateCallRequest {
	r.url = &url
	return r
}

func (r ApiUpdateCallRequest) Execute() (*ApiV2010AccountCall, *http.Response, error) {
	return r.ApiService.UpdateCallExecute(r)
}

/*
UpdateCall Method for UpdateCall

Initiates a call redirect or terminates a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to update.
 @param sid The Twilio-provided string that uniquely identifies the Call resource to update
 @return ApiUpdateCallRequest
*/
func (a *DefaultApiService) UpdateCall(ctx context.Context, accountSid string, sid string) ApiUpdateCallRequest {
	return ApiUpdateCallRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCall
func (a *DefaultApiService) UpdateCallExecute(r ApiUpdateCallRequest) (*ApiV2010AccountCall, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCall
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.fallbackMethod != nil {
		localVarFormParams.Add("FallbackMethod", parameterToString(*r.fallbackMethod, ""))
	}
	if r.fallbackUrl != nil {
		localVarFormParams.Add("FallbackUrl", parameterToString(*r.fallbackUrl, ""))
	}
	if r.method != nil {
		localVarFormParams.Add("Method", parameterToString(*r.method, ""))
	}
	if r.status != nil {
		localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.timeLimit != nil {
		localVarFormParams.Add("TimeLimit", parameterToString(*r.timeLimit, ""))
	}
	if r.twiml != nil {
		localVarFormParams.Add("Twiml", parameterToString(*r.twiml, ""))
	}
	if r.url != nil {
		localVarFormParams.Add("Url", parameterToString(*r.url, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCallFeedbackRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	issue *[]string
	qualityScore *int32
}

// One or more issues experienced during the call. The issues can be: &#x60;imperfect-audio&#x60;, &#x60;dropped-call&#x60;, &#x60;incorrect-caller-id&#x60;, &#x60;post-dial-delay&#x60;, &#x60;digits-not-captured&#x60;, &#x60;audio-latency&#x60;, &#x60;unsolicited-call&#x60;, or &#x60;one-way-audio&#x60;.
func (r ApiUpdateCallFeedbackRequest) Issue(issue []string) ApiUpdateCallFeedbackRequest {
	r.issue = &issue
	return r
}

// The call quality expressed as an integer from &#x60;1&#x60; to &#x60;5&#x60; where &#x60;1&#x60; represents very poor call quality and &#x60;5&#x60; represents a perfect call.
func (r ApiUpdateCallFeedbackRequest) QualityScore(qualityScore int32) ApiUpdateCallFeedbackRequest {
	r.qualityScore = &qualityScore
	return r
}

func (r ApiUpdateCallFeedbackRequest) Execute() (*ApiV2010AccountCallCallFeedback, *http.Response, error) {
	return r.ApiService.UpdateCallFeedbackExecute(r)
}

/*
UpdateCallFeedback Method for UpdateCallFeedback

Update a Feedback resource for a call

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param callSid The call sid that uniquely identifies the call
 @return ApiUpdateCallFeedbackRequest
*/
func (a *DefaultApiService) UpdateCallFeedback(ctx context.Context, accountSid string, callSid string) ApiUpdateCallFeedbackRequest {
	return ApiUpdateCallFeedbackRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallFeedback
func (a *DefaultApiService) UpdateCallFeedbackExecute(r ApiUpdateCallFeedbackRequest) (*ApiV2010AccountCallCallFeedback, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallFeedback
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCallFeedback")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.issue != nil {
		localVarFormParams.Add("Issue", parameterToString(*r.issue, "csv"))
	}
	if r.qualityScore != nil {
		localVarFormParams.Add("QualityScore", parameterToString(*r.qualityScore, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCallRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
	status *string
	pauseBehavior *string
}

// The new status of the recording. Can be: &#x60;stopped&#x60;, &#x60;paused&#x60;, &#x60;in-progress&#x60;.
func (r ApiUpdateCallRecordingRequest) Status(status string) ApiUpdateCallRecordingRequest {
	r.status = &status
	return r
}

// Whether to record during a pause. Can be: &#x60;skip&#x60; or &#x60;silence&#x60; and the default is &#x60;silence&#x60;. &#x60;skip&#x60; does not record during the pause period, while &#x60;silence&#x60; will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting &#x60;status&#x60; is set to &#x60;paused&#x60;.
func (r ApiUpdateCallRecordingRequest) PauseBehavior(pauseBehavior string) ApiUpdateCallRecordingRequest {
	r.pauseBehavior = &pauseBehavior
	return r
}

func (r ApiUpdateCallRecordingRequest) Execute() (*ApiV2010AccountCallCallRecording, *http.Response, error) {
	return r.ApiService.UpdateCallRecordingExecute(r)
}

/*
UpdateCallRecording Method for UpdateCallRecording

Changes the status of the recording to paused, stopped, or in-progress. Note: Pass `Twilio.CURRENT` instead of recording sid to reference current active recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resource to update.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource to update.
 @param sid The Twilio-provided string that uniquely identifies the Recording resource to update.
 @return ApiUpdateCallRecordingRequest
*/
func (a *DefaultApiService) UpdateCallRecording(ctx context.Context, accountSid string, callSid string, sid string) ApiUpdateCallRecordingRequest {
	return ApiUpdateCallRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallCallRecording
func (a *DefaultApiService) UpdateCallRecordingExecute(r ApiUpdateCallRecordingRequest) (*ApiV2010AccountCallCallRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallCallRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCallRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.pauseBehavior != nil {
		localVarFormParams.Add("PauseBehavior", parameterToString(*r.pauseBehavior, ""))
	}
	localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConferenceRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	announceMethod *string
	announceUrl *string
	status *string
}

// The HTTP method used to call &#x60;announce_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;
func (r ApiUpdateConferenceRequest) AnnounceMethod(announceMethod string) ApiUpdateConferenceRequest {
	r.announceMethod = &announceMethod
	return r
}

// The URL we should call to announce something into the conference. The URL can return an MP3, a WAV, or a TwiML document with &#x60;&lt;Play&gt;&#x60; or &#x60;&lt;Say&gt;&#x60;.
func (r ApiUpdateConferenceRequest) AnnounceUrl(announceUrl string) ApiUpdateConferenceRequest {
	r.announceUrl = &announceUrl
	return r
}

// The new status of the resource. Can be:  Can be: &#x60;init&#x60;, &#x60;in-progress&#x60;, or &#x60;completed&#x60;. Specifying &#x60;completed&#x60; will end the conference and hang up all participants
func (r ApiUpdateConferenceRequest) Status(status string) ApiUpdateConferenceRequest {
	r.status = &status
	return r
}

func (r ApiUpdateConferenceRequest) Execute() (*ApiV2010AccountConference, *http.Response, error) {
	return r.ApiService.UpdateConferenceExecute(r)
}

/*
UpdateConference Method for UpdateConference



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference resource(s) to update.
 @param sid The Twilio-provided string that uniquely identifies the Conference resource to update
 @return ApiUpdateConferenceRequest
*/
func (a *DefaultApiService) UpdateConference(ctx context.Context, accountSid string, sid string) ApiUpdateConferenceRequest {
	return ApiUpdateConferenceRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConference
func (a *DefaultApiService) UpdateConferenceExecute(r ApiUpdateConferenceRequest) (*ApiV2010AccountConference, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateConference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.announceMethod != nil {
		localVarFormParams.Add("AnnounceMethod", parameterToString(*r.announceMethod, ""))
	}
	if r.announceUrl != nil {
		localVarFormParams.Add("AnnounceUrl", parameterToString(*r.announceUrl, ""))
	}
	if r.status != nil {
		localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConferenceRecordingRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	sid string
	status *string
	pauseBehavior *string
}

// The new status of the recording. Can be: &#x60;stopped&#x60;, &#x60;paused&#x60;, &#x60;in-progress&#x60;.
func (r ApiUpdateConferenceRecordingRequest) Status(status string) ApiUpdateConferenceRecordingRequest {
	r.status = &status
	return r
}

// Whether to record during a pause. Can be: &#x60;skip&#x60; or &#x60;silence&#x60; and the default is &#x60;silence&#x60;. &#x60;skip&#x60; does not record during the pause period, while &#x60;silence&#x60; will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting &#x60;status&#x60; is set to &#x60;paused&#x60;.
func (r ApiUpdateConferenceRecordingRequest) PauseBehavior(pauseBehavior string) ApiUpdateConferenceRecordingRequest {
	r.pauseBehavior = &pauseBehavior
	return r
}

func (r ApiUpdateConferenceRecordingRequest) Execute() (*ApiV2010AccountConferenceConferenceRecording, *http.Response, error) {
	return r.ApiService.UpdateConferenceRecordingExecute(r)
}

/*
UpdateConferenceRecording Method for UpdateConferenceRecording

Changes the status of the recording to paused, stopped, or in-progress. Note: To use `Twilio.CURRENT`, pass it as recording sid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resource to update.
 @param conferenceSid The Conference SID that identifies the conference associated with the recording to update.
 @param sid The Twilio-provided string that uniquely identifies the Conference Recording resource to update. Use `Twilio.CURRENT` to reference the current active recording.
 @return ApiUpdateConferenceRecordingRequest
*/
func (a *DefaultApiService) UpdateConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string) ApiUpdateConferenceRecordingRequest {
	return ApiUpdateConferenceRecordingRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConferenceConferenceRecording
func (a *DefaultApiService) UpdateConferenceRecordingExecute(r ApiUpdateConferenceRecordingRequest) (*ApiV2010AccountConferenceConferenceRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConferenceConferenceRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateConferenceRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have less than 34 elements")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.pauseBehavior != nil {
		localVarFormParams.Add("PauseBehavior", parameterToString(*r.pauseBehavior, ""))
	}
	localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConnectAppRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	authorizeRedirectUrl *string
	companyName *string
	deauthorizeCallbackMethod *string
	deauthorizeCallbackUrl *string
	description *string
	friendlyName *string
	homepageUrl *string
	permissions *[]string
}

// The URL to redirect the user to after we authenticate the user and obtain authorization to access the Connect App.
func (r ApiUpdateConnectAppRequest) AuthorizeRedirectUrl(authorizeRedirectUrl string) ApiUpdateConnectAppRequest {
	r.authorizeRedirectUrl = &authorizeRedirectUrl
	return r
}

// The company name to set for the Connect App.
func (r ApiUpdateConnectAppRequest) CompanyName(companyName string) ApiUpdateConnectAppRequest {
	r.companyName = &companyName
	return r
}

// The HTTP method to use when calling &#x60;deauthorize_callback_url&#x60;.
func (r ApiUpdateConnectAppRequest) DeauthorizeCallbackMethod(deauthorizeCallbackMethod string) ApiUpdateConnectAppRequest {
	r.deauthorizeCallbackMethod = &deauthorizeCallbackMethod
	return r
}

// The URL to call using the &#x60;deauthorize_callback_method&#x60; to de-authorize the Connect App.
func (r ApiUpdateConnectAppRequest) DeauthorizeCallbackUrl(deauthorizeCallbackUrl string) ApiUpdateConnectAppRequest {
	r.deauthorizeCallbackUrl = &deauthorizeCallbackUrl
	return r
}

// A description of the Connect App.
func (r ApiUpdateConnectAppRequest) Description(description string) ApiUpdateConnectAppRequest {
	r.description = &description
	return r
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiUpdateConnectAppRequest) FriendlyName(friendlyName string) ApiUpdateConnectAppRequest {
	r.friendlyName = &friendlyName
	return r
}

// A public URL where users can obtain more information about this Connect App.
func (r ApiUpdateConnectAppRequest) HomepageUrl(homepageUrl string) ApiUpdateConnectAppRequest {
	r.homepageUrl = &homepageUrl
	return r
}

// A comma-separated list of the permissions you will request from the users of this ConnectApp.  Can include: &#x60;get-all&#x60; and &#x60;post-all&#x60;.
func (r ApiUpdateConnectAppRequest) Permissions(permissions []string) ApiUpdateConnectAppRequest {
	r.permissions = &permissions
	return r
}

func (r ApiUpdateConnectAppRequest) Execute() (*ApiV2010AccountConnectApp, *http.Response, error) {
	return r.ApiService.UpdateConnectAppExecute(r)
}

/*
UpdateConnectApp Method for UpdateConnectApp

Update a connect-app with the specified parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resources to update.
 @param sid The Twilio-provided string that uniquely identifies the ConnectApp resource to update.
 @return ApiUpdateConnectAppRequest
*/
func (a *DefaultApiService) UpdateConnectApp(ctx context.Context, accountSid string, sid string) ApiUpdateConnectAppRequest {
	return ApiUpdateConnectAppRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConnectApp
func (a *DefaultApiService) UpdateConnectAppExecute(r ApiUpdateConnectAppRequest) (*ApiV2010AccountConnectApp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConnectApp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateConnectApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorizeRedirectUrl != nil {
		localVarFormParams.Add("AuthorizeRedirectUrl", parameterToString(*r.authorizeRedirectUrl, ""))
	}
	if r.companyName != nil {
		localVarFormParams.Add("CompanyName", parameterToString(*r.companyName, ""))
	}
	if r.deauthorizeCallbackMethod != nil {
		localVarFormParams.Add("DeauthorizeCallbackMethod", parameterToString(*r.deauthorizeCallbackMethod, ""))
	}
	if r.deauthorizeCallbackUrl != nil {
		localVarFormParams.Add("DeauthorizeCallbackUrl", parameterToString(*r.deauthorizeCallbackUrl, ""))
	}
	if r.description != nil {
		localVarFormParams.Add("Description", parameterToString(*r.description, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.homepageUrl != nil {
		localVarFormParams.Add("HomepageUrl", parameterToString(*r.homepageUrl, ""))
	}
	if r.permissions != nil {
		localVarFormParams.Add("Permissions", parameterToString(*r.permissions, "csv"))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIncomingPhoneNumberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	accountSid2 *string
	addressSid *string
	apiVersion *string
	bundleSid *string
	emergencyAddressSid *string
	emergencyStatus *string
	friendlyName *string
	identitySid *string
	smsApplicationSid *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsUrl *string
	statusCallback *string
	statusCallbackMethod *string
	trunkSid *string
	voiceApplicationSid *string
	voiceCallerIdLookup *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceReceiveMode *string
	voiceUrl *string
}

// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to update.  For more information, see [Exchanging Numbers Between Subaccounts](https://www.twilio.com/docs/iam/api/subaccounts#exchanging-numbers).
func (r ApiUpdateIncomingPhoneNumberRequest) AccountSid2(accountSid2 string) ApiUpdateIncomingPhoneNumberRequest {
	r.accountSid2 = &accountSid2
	return r
}

// The SID of the Address resource we should associate with the phone number. Some regions require addresses to meet local regulations.
func (r ApiUpdateIncomingPhoneNumberRequest) AddressSid(addressSid string) ApiUpdateIncomingPhoneNumberRequest {
	r.addressSid = &addressSid
	return r
}

// The API version to use for incoming calls made to the phone number. The default is &#x60;2010-04-01&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) ApiVersion(apiVersion string) ApiUpdateIncomingPhoneNumberRequest {
	r.apiVersion = &apiVersion
	return r
}

// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
func (r ApiUpdateIncomingPhoneNumberRequest) BundleSid(bundleSid string) ApiUpdateIncomingPhoneNumberRequest {
	r.bundleSid = &bundleSid
	return r
}

// The SID of the emergency address configuration to use for emergency calling from this phone number.
func (r ApiUpdateIncomingPhoneNumberRequest) EmergencyAddressSid(emergencyAddressSid string) ApiUpdateIncomingPhoneNumberRequest {
	r.emergencyAddressSid = &emergencyAddressSid
	return r
}

// The parameter displays if emergency calling is enabled for this number. Active numbers may place emergency calls by dialing valid emergency numbers for the country.
func (r ApiUpdateIncomingPhoneNumberRequest) EmergencyStatus(emergencyStatus string) ApiUpdateIncomingPhoneNumberRequest {
	r.emergencyStatus = &emergencyStatus
	return r
}

// A descriptive string that you created to describe this phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
func (r ApiUpdateIncomingPhoneNumberRequest) FriendlyName(friendlyName string) ApiUpdateIncomingPhoneNumberRequest {
	r.friendlyName = &friendlyName
	return r
}

// The SID of the Identity resource that we should associate with the phone number. Some regions require an identity to meet local regulations.
func (r ApiUpdateIncomingPhoneNumberRequest) IdentitySid(identitySid string) ApiUpdateIncomingPhoneNumberRequest {
	r.identitySid = &identitySid
	return r
}

// The SID of the application that should handle SMS messages sent to the number. If an &#x60;sms_application_sid&#x60; is present, we ignore all of the &#x60;sms_*_url&#x60; urls and use those set on the application.
func (r ApiUpdateIncomingPhoneNumberRequest) SmsApplicationSid(smsApplicationSid string) ApiUpdateIncomingPhoneNumberRequest {
	r.smsApplicationSid = &smsApplicationSid
	return r
}

// The HTTP method that we should use to call &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) SmsFallbackMethod(smsFallbackMethod string) ApiUpdateIncomingPhoneNumberRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call when an error occurs while requesting or executing the TwiML defined by &#x60;sms_url&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) SmsFallbackUrl(smsFallbackUrl string) ApiUpdateIncomingPhoneNumberRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) SmsMethod(smsMethod string) ApiUpdateIncomingPhoneNumberRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call when the phone number receives an incoming SMS message.
func (r ApiUpdateIncomingPhoneNumberRequest) SmsUrl(smsUrl string) ApiUpdateIncomingPhoneNumberRequest {
	r.smsUrl = &smsUrl
	return r
}

// The URL we should call using the &#x60;status_callback_method&#x60; to send status information to your application.
func (r ApiUpdateIncomingPhoneNumberRequest) StatusCallback(statusCallback string) ApiUpdateIncomingPhoneNumberRequest {
	r.statusCallback = &statusCallback
	return r
}

// The HTTP method we should use to call &#x60;status_callback&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) StatusCallbackMethod(statusCallbackMethod string) ApiUpdateIncomingPhoneNumberRequest {
	r.statusCallbackMethod = &statusCallbackMethod
	return r
}

// The SID of the Trunk we should use to handle phone calls to the phone number. If a &#x60;trunk_sid&#x60; is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a &#x60;trunk_sid&#x60; will automatically delete your &#x60;voice_application_sid&#x60; and vice versa.
func (r ApiUpdateIncomingPhoneNumberRequest) TrunkSid(trunkSid string) ApiUpdateIncomingPhoneNumberRequest {
	r.trunkSid = &trunkSid
	return r
}

// The SID of the application we should use to handle phone calls to the phone number. If a &#x60;voice_application_sid&#x60; is present, we ignore all of the voice urls and use only those set on the application. Setting a &#x60;voice_application_sid&#x60; will automatically delete your &#x60;trunk_sid&#x60; and vice versa.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceApplicationSid(voiceApplicationSid string) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceApplicationSid = &voiceApplicationSid
	return r
}

// Whether to lookup the caller&#39;s name from the CNAM database and post it to your app. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceCallerIdLookup(voiceCallerIdLookup bool) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceCallerIdLookup = &voiceCallerIdLookup
	return r
}

// The HTTP method that we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs retrieving or executing the TwiML requested by &#x60;url&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method that we should use to call &#x60;voice_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceMethod(voiceMethod string) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The configuration parameter for the phone number to receive incoming voice calls or faxes. Can be: &#x60;fax&#x60; or &#x60;voice&#x60; and defaults to &#x60;voice&#x60;.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceReceiveMode(voiceReceiveMode string) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceReceiveMode = &voiceReceiveMode
	return r
}

// The URL that we should call to answer a call to the phone number. The &#x60;voice_url&#x60; will not be called if a &#x60;voice_application_sid&#x60; or a &#x60;trunk_sid&#x60; is set.
func (r ApiUpdateIncomingPhoneNumberRequest) VoiceUrl(voiceUrl string) ApiUpdateIncomingPhoneNumberRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiUpdateIncomingPhoneNumberRequest) Execute() (*ApiV2010AccountIncomingPhoneNumber, *http.Response, error) {
	return r.ApiService.UpdateIncomingPhoneNumberExecute(r)
}

/*
UpdateIncomingPhoneNumber Method for UpdateIncomingPhoneNumber

Update an incoming-phone-number instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to update.  For more information, see [Exchanging Numbers Between Subaccounts](https://www.twilio.com/docs/iam/api/subaccounts#exchanging-numbers).
 @param sid The Twilio-provided string that uniquely identifies the IncomingPhoneNumber resource to update.
 @return ApiUpdateIncomingPhoneNumberRequest
*/
func (a *DefaultApiService) UpdateIncomingPhoneNumber(ctx context.Context, accountSid string, sid string) ApiUpdateIncomingPhoneNumberRequest {
	return ApiUpdateIncomingPhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountIncomingPhoneNumber
func (a *DefaultApiService) UpdateIncomingPhoneNumberExecute(r ApiUpdateIncomingPhoneNumberRequest) (*ApiV2010AccountIncomingPhoneNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountIncomingPhoneNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateIncomingPhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accountSid2 != nil {
		localVarFormParams.Add("AccountSid", parameterToString(*r.accountSid2, ""))
	}
	if r.addressSid != nil {
		localVarFormParams.Add("AddressSid", parameterToString(*r.addressSid, ""))
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.bundleSid != nil {
		localVarFormParams.Add("BundleSid", parameterToString(*r.bundleSid, ""))
	}
	if r.emergencyAddressSid != nil {
		localVarFormParams.Add("EmergencyAddressSid", parameterToString(*r.emergencyAddressSid, ""))
	}
	if r.emergencyStatus != nil {
		localVarFormParams.Add("EmergencyStatus", parameterToString(*r.emergencyStatus, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.identitySid != nil {
		localVarFormParams.Add("IdentitySid", parameterToString(*r.identitySid, ""))
	}
	if r.smsApplicationSid != nil {
		localVarFormParams.Add("SmsApplicationSid", parameterToString(*r.smsApplicationSid, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	if r.statusCallback != nil {
		localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	}
	if r.statusCallbackMethod != nil {
		localVarFormParams.Add("StatusCallbackMethod", parameterToString(*r.statusCallbackMethod, ""))
	}
	if r.trunkSid != nil {
		localVarFormParams.Add("TrunkSid", parameterToString(*r.trunkSid, ""))
	}
	if r.voiceApplicationSid != nil {
		localVarFormParams.Add("VoiceApplicationSid", parameterToString(*r.voiceApplicationSid, ""))
	}
	if r.voiceCallerIdLookup != nil {
		localVarFormParams.Add("VoiceCallerIdLookup", parameterToString(*r.voiceCallerIdLookup, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceReceiveMode != nil {
		localVarFormParams.Add("VoiceReceiveMode", parameterToString(*r.voiceReceiveMode, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	friendlyName *string
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiUpdateKeyRequest) FriendlyName(friendlyName string) ApiUpdateKeyRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiUpdateKeyRequest) Execute() (*ApiV2010AccountKey, *http.Response, error) {
	return r.ApiService.UpdateKeyExecute(r)
}

/*
UpdateKey Method for UpdateKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resources to update.
 @param sid The Twilio-provided string that uniquely identifies the Key resource to update.
 @return ApiUpdateKeyRequest
*/
func (a *DefaultApiService) UpdateKey(ctx context.Context, accountSid string, sid string) ApiUpdateKeyRequest {
	return ApiUpdateKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountKey
func (a *DefaultApiService) UpdateKeyExecute(r ApiUpdateKeyRequest) (*ApiV2010AccountKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMemberRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	queueSid string
	callSid string
	url *string
	method *string
}

// The absolute URL of the Queue resource.
func (r ApiUpdateMemberRequest) Url(url string) ApiUpdateMemberRequest {
	r.url = &url
	return r
}

// How to pass the update request data. Can be &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. &#x60;POST&#x60; sends the data as encoded form data and &#x60;GET&#x60; sends the data as query parameters.
func (r ApiUpdateMemberRequest) Method(method string) ApiUpdateMemberRequest {
	r.method = &method
	return r
}

func (r ApiUpdateMemberRequest) Execute() (*ApiV2010AccountQueueMember, *http.Response, error) {
	return r.ApiService.UpdateMemberExecute(r)
}

/*
UpdateMember Method for UpdateMember

Dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Member resource(s) to update.
 @param queueSid The SID of the Queue in which to find the members to update.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource(s) to update.
 @return ApiUpdateMemberRequest
*/
func (a *DefaultApiService) UpdateMember(ctx context.Context, accountSid string, queueSid string, callSid string) ApiUpdateMemberRequest {
	return ApiUpdateMemberRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		queueSid: queueSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountQueueMember
func (a *DefaultApiService) UpdateMemberExecute(r ApiUpdateMemberRequest) (*ApiV2010AccountQueueMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountQueueMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"QueueSid"+"}", url.PathEscape(parameterToString(r.queueSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.queueSid) < 34 {
		return localVarReturnValue, nil, reportError("queueSid must have at least 34 elements")
	}
	if strlen(r.queueSid) > 34 {
		return localVarReturnValue, nil, reportError("queueSid must have less than 34 elements")
	}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.method != nil {
		localVarFormParams.Add("Method", parameterToString(*r.method, ""))
	}
	localVarFormParams.Add("Url", parameterToString(*r.url, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	body *string
	status *string
}

// The text of the message you want to send. Can be up to 1,600 characters long.
func (r ApiUpdateMessageRequest) Body(body string) ApiUpdateMessageRequest {
	r.body = &body
	return r
}

// When set as &#x60;canceled&#x60;, allows a message cancelation request if a message has not yet been sent.
func (r ApiUpdateMessageRequest) Status(status string) ApiUpdateMessageRequest {
	r.status = &status
	return r
}

func (r ApiUpdateMessageRequest) Execute() (*ApiV2010AccountMessage, *http.Response, error) {
	return r.ApiService.UpdateMessageExecute(r)
}

/*
UpdateMessage Method for UpdateMessage

To redact a message-body from a post-flight message record, post to the message instance resource with an empty body

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resources to update.
 @param sid The Twilio-provided string that uniquely identifies the Message resource to update.
 @return ApiUpdateMessageRequest
*/
func (a *DefaultApiService) UpdateMessage(ctx context.Context, accountSid string, sid string) ApiUpdateMessageRequest {
	return ApiUpdateMessageRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountMessage
func (a *DefaultApiService) UpdateMessageExecute(r ApiUpdateMessageRequest) (*ApiV2010AccountMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.body != nil {
		localVarFormParams.Add("Body", parameterToString(*r.body, ""))
	}
	if r.status != nil {
		localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOutgoingCallerIdRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	friendlyName *string
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiUpdateOutgoingCallerIdRequest) FriendlyName(friendlyName string) ApiUpdateOutgoingCallerIdRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiUpdateOutgoingCallerIdRequest) Execute() (*ApiV2010AccountOutgoingCallerId, *http.Response, error) {
	return r.ApiService.UpdateOutgoingCallerIdExecute(r)
}

/*
UpdateOutgoingCallerId Method for UpdateOutgoingCallerId

Updates the caller-id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resources to update.
 @param sid The Twilio-provided string that uniquely identifies the OutgoingCallerId resource to update.
 @return ApiUpdateOutgoingCallerIdRequest
*/
func (a *DefaultApiService) UpdateOutgoingCallerId(ctx context.Context, accountSid string, sid string) ApiUpdateOutgoingCallerIdRequest {
	return ApiUpdateOutgoingCallerIdRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountOutgoingCallerId
func (a *DefaultApiService) UpdateOutgoingCallerIdExecute(r ApiUpdateOutgoingCallerIdRequest) (*ApiV2010AccountOutgoingCallerId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountOutgoingCallerId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateOutgoingCallerId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateParticipantRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	conferenceSid string
	callSid string
	announceMethod *string
	announceUrl *string
	beepOnExit *bool
	callSidToCoach *string
	coaching *bool
	endConferenceOnExit *bool
	hold *bool
	holdMethod *string
	holdUrl *string
	muted *bool
	waitMethod *string
	waitUrl *string
}

// The HTTP method we should use to call &#x60;announce_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and defaults to &#x60;POST&#x60;.
func (r ApiUpdateParticipantRequest) AnnounceMethod(announceMethod string) ApiUpdateParticipantRequest {
	r.announceMethod = &announceMethod
	return r
}

// The URL we call using the &#x60;announce_method&#x60; for an announcement to the participant. The URL must return an MP3 file, a WAV file, or a TwiML document that contains &#x60;&lt;Play&gt;&#x60; or &#x60;&lt;Say&gt;&#x60; commands.
func (r ApiUpdateParticipantRequest) AnnounceUrl(announceUrl string) ApiUpdateParticipantRequest {
	r.announceUrl = &announceUrl
	return r
}

// Whether to play a notification beep to the conference when the participant exits. Can be: &#x60;true&#x60; or &#x60;false&#x60;.
func (r ApiUpdateParticipantRequest) BeepOnExit(beepOnExit bool) ApiUpdateParticipantRequest {
	r.beepOnExit = &beepOnExit
	return r
}

// The SID of the participant who is being &#x60;coached&#x60;. The participant being coached is the only participant who can hear the participant who is &#x60;coaching&#x60;.
func (r ApiUpdateParticipantRequest) CallSidToCoach(callSidToCoach string) ApiUpdateParticipantRequest {
	r.callSidToCoach = &callSidToCoach
	return r
}

// Whether the participant is coaching another call. Can be: &#x60;true&#x60; or &#x60;false&#x60;. If not present, defaults to &#x60;false&#x60; unless &#x60;call_sid_to_coach&#x60; is defined. If &#x60;true&#x60;, &#x60;call_sid_to_coach&#x60; must be defined.
func (r ApiUpdateParticipantRequest) Coaching(coaching bool) ApiUpdateParticipantRequest {
	r.coaching = &coaching
	return r
}

// Whether to end the conference when the participant leaves. Can be: &#x60;true&#x60; or &#x60;false&#x60; and defaults to &#x60;false&#x60;.
func (r ApiUpdateParticipantRequest) EndConferenceOnExit(endConferenceOnExit bool) ApiUpdateParticipantRequest {
	r.endConferenceOnExit = &endConferenceOnExit
	return r
}

// Whether the participant should be on hold. Can be: &#x60;true&#x60; or &#x60;false&#x60;. &#x60;true&#x60; puts the participant on hold, and &#x60;false&#x60; lets them rejoin the conference.
func (r ApiUpdateParticipantRequest) Hold(hold bool) ApiUpdateParticipantRequest {
	r.hold = &hold
	return r
}

// The HTTP method we should use to call &#x60;hold_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;GET&#x60;.
func (r ApiUpdateParticipantRequest) HoldMethod(holdMethod string) ApiUpdateParticipantRequest {
	r.holdMethod = &holdMethod
	return r
}

// The URL we call using the &#x60;hold_method&#x60; for  music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains the &#x60;&lt;Play&gt;&#x60;, &#x60;&lt;Say&gt;&#x60; or &#x60;&lt;Redirect&gt;&#x60; commands.
func (r ApiUpdateParticipantRequest) HoldUrl(holdUrl string) ApiUpdateParticipantRequest {
	r.holdUrl = &holdUrl
	return r
}

// Whether the participant should be muted. Can be &#x60;true&#x60; or &#x60;false&#x60;. &#x60;true&#x60; will mute the participant, and &#x60;false&#x60; will un-mute them. Anything value other than &#x60;true&#x60; or &#x60;false&#x60; is interpreted as &#x60;false&#x60;.
func (r ApiUpdateParticipantRequest) Muted(muted bool) ApiUpdateParticipantRequest {
	r.muted = &muted
	return r
}

// The HTTP method we should use to call &#x60;wait_url&#x60;. Can be &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;. When using a static audio file, this should be &#x60;GET&#x60; so that we can cache the file.
func (r ApiUpdateParticipantRequest) WaitMethod(waitMethod string) ApiUpdateParticipantRequest {
	r.waitMethod = &waitMethod
	return r
}

// The URL we should call using the &#x60;wait_method&#x60; for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
func (r ApiUpdateParticipantRequest) WaitUrl(waitUrl string) ApiUpdateParticipantRequest {
	r.waitUrl = &waitUrl
	return r
}

func (r ApiUpdateParticipantRequest) Execute() (*ApiV2010AccountConferenceParticipant, *http.Response, error) {
	return r.ApiService.UpdateParticipantExecute(r)
}

/*
UpdateParticipant Method for UpdateParticipant

Update the properties of the participant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to update.
 @param conferenceSid The SID of the conference with the participant to update.
 @param callSid The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to update. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
 @return ApiUpdateParticipantRequest
*/
func (a *DefaultApiService) UpdateParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string) ApiUpdateParticipantRequest {
	return ApiUpdateParticipantRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		conferenceSid: conferenceSid,
		callSid: callSid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountConferenceParticipant
func (a *DefaultApiService) UpdateParticipantExecute(r ApiUpdateParticipantRequest) (*ApiV2010AccountConferenceParticipant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountConferenceParticipant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateParticipant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ConferenceSid"+"}", url.PathEscape(parameterToString(r.conferenceSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.conferenceSid) < 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have at least 34 elements")
	}
	if strlen(r.conferenceSid) > 34 {
		return localVarReturnValue, nil, reportError("conferenceSid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.announceMethod != nil {
		localVarFormParams.Add("AnnounceMethod", parameterToString(*r.announceMethod, ""))
	}
	if r.announceUrl != nil {
		localVarFormParams.Add("AnnounceUrl", parameterToString(*r.announceUrl, ""))
	}
	if r.beepOnExit != nil {
		localVarFormParams.Add("BeepOnExit", parameterToString(*r.beepOnExit, ""))
	}
	if r.callSidToCoach != nil {
		localVarFormParams.Add("CallSidToCoach", parameterToString(*r.callSidToCoach, ""))
	}
	if r.coaching != nil {
		localVarFormParams.Add("Coaching", parameterToString(*r.coaching, ""))
	}
	if r.endConferenceOnExit != nil {
		localVarFormParams.Add("EndConferenceOnExit", parameterToString(*r.endConferenceOnExit, ""))
	}
	if r.hold != nil {
		localVarFormParams.Add("Hold", parameterToString(*r.hold, ""))
	}
	if r.holdMethod != nil {
		localVarFormParams.Add("HoldMethod", parameterToString(*r.holdMethod, ""))
	}
	if r.holdUrl != nil {
		localVarFormParams.Add("HoldUrl", parameterToString(*r.holdUrl, ""))
	}
	if r.muted != nil {
		localVarFormParams.Add("Muted", parameterToString(*r.muted, ""))
	}
	if r.waitMethod != nil {
		localVarFormParams.Add("WaitMethod", parameterToString(*r.waitMethod, ""))
	}
	if r.waitUrl != nil {
		localVarFormParams.Add("WaitUrl", parameterToString(*r.waitUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePaymentsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
	idempotencyKey *string
	statusCallback *string
	capture *string
	status *string
}

// A unique token that will be used to ensure that multiple API calls with the same information do not result in multiple transactions. This should be a unique string value per API call and can be a randomly generated.
func (r ApiUpdatePaymentsRequest) IdempotencyKey(idempotencyKey string) ApiUpdatePaymentsRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [Update](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-update) and [Complete/Cancel](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-cancelcomplete) POST requests.
func (r ApiUpdatePaymentsRequest) StatusCallback(statusCallback string) ApiUpdatePaymentsRequest {
	r.statusCallback = &statusCallback
	return r
}

// The piece of payment information that you wish the caller to enter. Must be one of &#x60;payment-card-number&#x60;, &#x60;expiration-date&#x60;, &#x60;security-code&#x60;, &#x60;postal-code&#x60;, &#x60;bank-routing-number&#x60;, or &#x60;bank-account-number&#x60;.
func (r ApiUpdatePaymentsRequest) Capture(capture string) ApiUpdatePaymentsRequest {
	r.capture = &capture
	return r
}

// Indicates whether the current payment session should be cancelled or completed. When &#x60;cancel&#x60; the payment session is cancelled. When &#x60;complete&#x60;, Twilio sends the payment information to the selected &lt;Pay&gt; connector for processing.
func (r ApiUpdatePaymentsRequest) Status(status string) ApiUpdatePaymentsRequest {
	r.status = &status
	return r
}

func (r ApiUpdatePaymentsRequest) Execute() (*ApiV2010AccountCallPayments, *http.Response, error) {
	return r.ApiService.UpdatePaymentsExecute(r)
}

/*
UpdatePayments Method for UpdatePayments

update an instance of payments with different phases of payment flows.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will update the resource.
 @param callSid The SID of the call that will update the resource. This should be the same call sid that was used to create payments resource.
 @param sid The SID of Payments session that needs to be updated.
 @return ApiUpdatePaymentsRequest
*/
func (a *DefaultApiService) UpdatePayments(ctx context.Context, accountSid string, callSid string, sid string) ApiUpdatePaymentsRequest {
	return ApiUpdatePaymentsRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallPayments
func (a *DefaultApiService) UpdatePaymentsExecute(r ApiUpdatePaymentsRequest) (*ApiV2010AccountCallPayments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallPayments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdatePayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.statusCallback == nil {
		return localVarReturnValue, nil, reportError("statusCallback is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.capture != nil {
		localVarFormParams.Add("Capture", parameterToString(*r.capture, ""))
	}
	localVarFormParams.Add("IdempotencyKey", parameterToString(*r.idempotencyKey, ""))
	if r.status != nil {
		localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	}
	localVarFormParams.Add("StatusCallback", parameterToString(*r.statusCallback, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateQueueRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	friendlyName *string
	maxSize *int32
}

// A descriptive string that you created to describe this resource. It can be up to 64 characters long.
func (r ApiUpdateQueueRequest) FriendlyName(friendlyName string) ApiUpdateQueueRequest {
	r.friendlyName = &friendlyName
	return r
}

// The maximum number of calls allowed to be in the queue. The default is 100. The maximum is 5000.
func (r ApiUpdateQueueRequest) MaxSize(maxSize int32) ApiUpdateQueueRequest {
	r.maxSize = &maxSize
	return r
}

func (r ApiUpdateQueueRequest) Execute() (*ApiV2010AccountQueue, *http.Response, error) {
	return r.ApiService.UpdateQueueExecute(r)
}

/*
UpdateQueue Method for UpdateQueue

Update the queue with the new parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resource to update.
 @param sid The Twilio-provided string that uniquely identifies the Queue resource to update
 @return ApiUpdateQueueRequest
*/
func (a *DefaultApiService) UpdateQueue(ctx context.Context, accountSid string, sid string) ApiUpdateQueueRequest {
	return ApiUpdateQueueRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountQueue
func (a *DefaultApiService) UpdateQueueExecute(r ApiUpdateQueueRequest) (*ApiV2010AccountQueue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountQueue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.maxSize != nil {
		localVarFormParams.Add("MaxSize", parameterToString(*r.maxSize, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShortCodeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	apiVersion *string
	friendlyName *string
	smsFallbackMethod *string
	smsFallbackUrl *string
	smsMethod *string
	smsUrl *string
}

// The API version to use to start a new TwiML session. Can be: &#x60;2010-04-01&#x60; or &#x60;2008-08-01&#x60;.
func (r ApiUpdateShortCodeRequest) ApiVersion(apiVersion string) ApiUpdateShortCodeRequest {
	r.apiVersion = &apiVersion
	return r
}

// A descriptive string that you created to describe this resource. It can be up to 64 characters long. By default, the &#x60;FriendlyName&#x60; is the short code.
func (r ApiUpdateShortCodeRequest) FriendlyName(friendlyName string) ApiUpdateShortCodeRequest {
	r.friendlyName = &friendlyName
	return r
}

// The HTTP method that we should use to call the &#x60;sms_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateShortCodeRequest) SmsFallbackMethod(smsFallbackMethod string) ApiUpdateShortCodeRequest {
	r.smsFallbackMethod = &smsFallbackMethod
	return r
}

// The URL that we should call if an error occurs while retrieving or executing the TwiML from &#x60;sms_url&#x60;.
func (r ApiUpdateShortCodeRequest) SmsFallbackUrl(smsFallbackUrl string) ApiUpdateShortCodeRequest {
	r.smsFallbackUrl = &smsFallbackUrl
	return r
}

// The HTTP method we should use when calling the &#x60;sms_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateShortCodeRequest) SmsMethod(smsMethod string) ApiUpdateShortCodeRequest {
	r.smsMethod = &smsMethod
	return r
}

// The URL we should call when receiving an incoming SMS message to this short code.
func (r ApiUpdateShortCodeRequest) SmsUrl(smsUrl string) ApiUpdateShortCodeRequest {
	r.smsUrl = &smsUrl
	return r
}

func (r ApiUpdateShortCodeRequest) Execute() (*ApiV2010AccountShortCode, *http.Response, error) {
	return r.ApiService.UpdateShortCodeExecute(r)
}

/*
UpdateShortCode Method for UpdateShortCode

Update a short code with the following parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ShortCode resource(s) to update.
 @param sid The Twilio-provided string that uniquely identifies the ShortCode resource to update
 @return ApiUpdateShortCodeRequest
*/
func (a *DefaultApiService) UpdateShortCode(ctx context.Context, accountSid string, sid string) ApiUpdateShortCodeRequest {
	return ApiUpdateShortCodeRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountShortCode
func (a *DefaultApiService) UpdateShortCodeExecute(r ApiUpdateShortCodeRequest) (*ApiV2010AccountShortCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountShortCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateShortCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.apiVersion != nil {
		localVarFormParams.Add("ApiVersion", parameterToString(*r.apiVersion, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.smsFallbackMethod != nil {
		localVarFormParams.Add("SmsFallbackMethod", parameterToString(*r.smsFallbackMethod, ""))
	}
	if r.smsFallbackUrl != nil {
		localVarFormParams.Add("SmsFallbackUrl", parameterToString(*r.smsFallbackUrl, ""))
	}
	if r.smsMethod != nil {
		localVarFormParams.Add("SmsMethod", parameterToString(*r.smsMethod, ""))
	}
	if r.smsUrl != nil {
		localVarFormParams.Add("SmsUrl", parameterToString(*r.smsUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSigningKeyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	friendlyName *string
}

// 
func (r ApiUpdateSigningKeyRequest) FriendlyName(friendlyName string) ApiUpdateSigningKeyRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiUpdateSigningKeyRequest) Execute() (*ApiV2010AccountSigningKey, *http.Response, error) {
	return r.ApiService.UpdateSigningKeyExecute(r)
}

/*
UpdateSigningKey Method for UpdateSigningKey



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid 
 @param sid 
 @return ApiUpdateSigningKeyRequest
*/
func (a *DefaultApiService) UpdateSigningKey(ctx context.Context, accountSid string, sid string) ApiUpdateSigningKeyRequest {
	return ApiUpdateSigningKeyRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSigningKey
func (a *DefaultApiService) UpdateSigningKeyExecute(r ApiUpdateSigningKeyRequest) (*ApiV2010AccountSigningKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSigningKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSigningKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSipCredentialRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	credentialListSid string
	sid string
	password *string
}

// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg &#x60;IWasAtSignal2018&#x60;)
func (r ApiUpdateSipCredentialRequest) Password(password string) ApiUpdateSipCredentialRequest {
	r.password = &password
	return r
}

func (r ApiUpdateSipCredentialRequest) Execute() (*ApiV2010AccountSipSipCredentialListSipCredential, *http.Response, error) {
	return r.ApiService.UpdateSipCredentialExecute(r)
}

/*
UpdateSipCredential Method for UpdateSipCredential

Update a credential resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param credentialListSid The unique id that identifies the credential list that includes this credential.
 @param sid The unique id that identifies the resource to update.
 @return ApiUpdateSipCredentialRequest
*/
func (a *DefaultApiService) UpdateSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string) ApiUpdateSipCredentialRequest {
	return ApiUpdateSipCredentialRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		credentialListSid: credentialListSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipCredentialListSipCredential
func (a *DefaultApiService) UpdateSipCredentialExecute(r ApiUpdateSipCredentialRequest) (*ApiV2010AccountSipSipCredentialListSipCredential, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipCredentialListSipCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSipCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CredentialListSid"+"}", url.PathEscape(parameterToString(r.credentialListSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.credentialListSid) < 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have at least 34 elements")
	}
	if strlen(r.credentialListSid) > 34 {
		return localVarReturnValue, nil, reportError("credentialListSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.password != nil {
		localVarFormParams.Add("Password", parameterToString(*r.password, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSipCredentialListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	friendlyName *string
}

// A human readable descriptive text for a CredentialList, up to 64 characters long.
func (r ApiUpdateSipCredentialListRequest) FriendlyName(friendlyName string) ApiUpdateSipCredentialListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiUpdateSipCredentialListRequest) Execute() (*ApiV2010AccountSipSipCredentialList, *http.Response, error) {
	return r.ApiService.UpdateSipCredentialListExecute(r)
}

/*
UpdateSipCredentialList Method for UpdateSipCredentialList

Update a Credential List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the Account that is responsible for this resource.
 @param sid The credential list Sid that uniquely identifies this resource
 @return ApiUpdateSipCredentialListRequest
*/
func (a *DefaultApiService) UpdateSipCredentialList(ctx context.Context, accountSid string, sid string) ApiUpdateSipCredentialListRequest {
	return ApiUpdateSipCredentialListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipCredentialList
func (a *DefaultApiService) UpdateSipCredentialListExecute(r ApiUpdateSipCredentialListRequest) (*ApiV2010AccountSipSipCredentialList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipCredentialList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSipCredentialList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}
	if r.friendlyName == nil {
		return localVarReturnValue, nil, reportError("friendlyName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSipDomainRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	byocTrunkSid *string
	domainName *string
	emergencyCallerSid *string
	emergencyCallingEnabled *bool
	friendlyName *string
	secure *bool
	sipRegistration *bool
	voiceFallbackMethod *string
	voiceFallbackUrl *string
	voiceMethod *string
	voiceStatusCallbackMethod *string
	voiceStatusCallbackUrl *string
	voiceUrl *string
}

// The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will be associated with.
func (r ApiUpdateSipDomainRequest) ByocTrunkSid(byocTrunkSid string) ApiUpdateSipDomainRequest {
	r.byocTrunkSid = &byocTrunkSid
	return r
}

// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and \\\&quot;-\\\&quot; and must end with &#x60;sip.twilio.com&#x60;.
func (r ApiUpdateSipDomainRequest) DomainName(domainName string) ApiUpdateSipDomainRequest {
	r.domainName = &domainName
	return r
}

// Whether an emergency caller sid is configured for the domain. If present, this phone number will be used as the callback for the emergency call.
func (r ApiUpdateSipDomainRequest) EmergencyCallerSid(emergencyCallerSid string) ApiUpdateSipDomainRequest {
	r.emergencyCallerSid = &emergencyCallerSid
	return r
}

// Whether emergency calling is enabled for the domain. If enabled, allows emergency calls on the domain from phone numbers with validated addresses.
func (r ApiUpdateSipDomainRequest) EmergencyCallingEnabled(emergencyCallingEnabled bool) ApiUpdateSipDomainRequest {
	r.emergencyCallingEnabled = &emergencyCallingEnabled
	return r
}

// A descriptive string that you created to describe the resource. It can be up to 64 characters long.
func (r ApiUpdateSipDomainRequest) FriendlyName(friendlyName string) ApiUpdateSipDomainRequest {
	r.friendlyName = &friendlyName
	return r
}

// Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and SRTP will be negotiated on all incoming calls to this sip domain.
func (r ApiUpdateSipDomainRequest) Secure(secure bool) ApiUpdateSipDomainRequest {
	r.secure = &secure
	return r
}

// Whether to allow SIP Endpoints to register with the domain to receive calls. Can be &#x60;true&#x60; or &#x60;false&#x60;. &#x60;true&#x60; allows SIP Endpoints to register with the domain to receive calls, &#x60;false&#x60; does not.
func (r ApiUpdateSipDomainRequest) SipRegistration(sipRegistration bool) ApiUpdateSipDomainRequest {
	r.sipRegistration = &sipRegistration
	return r
}

// The HTTP method we should use to call &#x60;voice_fallback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateSipDomainRequest) VoiceFallbackMethod(voiceFallbackMethod string) ApiUpdateSipDomainRequest {
	r.voiceFallbackMethod = &voiceFallbackMethod
	return r
}

// The URL that we should call when an error occurs while retrieving or executing the TwiML requested by &#x60;voice_url&#x60;.
func (r ApiUpdateSipDomainRequest) VoiceFallbackUrl(voiceFallbackUrl string) ApiUpdateSipDomainRequest {
	r.voiceFallbackUrl = &voiceFallbackUrl
	return r
}

// The HTTP method we should use to call &#x60;voice_url&#x60;
func (r ApiUpdateSipDomainRequest) VoiceMethod(voiceMethod string) ApiUpdateSipDomainRequest {
	r.voiceMethod = &voiceMethod
	return r
}

// The HTTP method we should use to call &#x60;voice_status_callback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60;.
func (r ApiUpdateSipDomainRequest) VoiceStatusCallbackMethod(voiceStatusCallbackMethod string) ApiUpdateSipDomainRequest {
	r.voiceStatusCallbackMethod = &voiceStatusCallbackMethod
	return r
}

// The URL that we should call to pass status parameters (such as call ended) to your application.
func (r ApiUpdateSipDomainRequest) VoiceStatusCallbackUrl(voiceStatusCallbackUrl string) ApiUpdateSipDomainRequest {
	r.voiceStatusCallbackUrl = &voiceStatusCallbackUrl
	return r
}

// The URL we should call when the domain receives a call.
func (r ApiUpdateSipDomainRequest) VoiceUrl(voiceUrl string) ApiUpdateSipDomainRequest {
	r.voiceUrl = &voiceUrl
	return r
}

func (r ApiUpdateSipDomainRequest) Execute() (*ApiV2010AccountSipSipDomain, *http.Response, error) {
	return r.ApiService.UpdateSipDomainExecute(r)
}

/*
UpdateSipDomain Method for UpdateSipDomain

Update the attributes of a domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resource to update.
 @param sid The Twilio-provided string that uniquely identifies the SipDomain resource to update.
 @return ApiUpdateSipDomainRequest
*/
func (a *DefaultApiService) UpdateSipDomain(ctx context.Context, accountSid string, sid string) ApiUpdateSipDomainRequest {
	return ApiUpdateSipDomainRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipDomain
func (a *DefaultApiService) UpdateSipDomainExecute(r ApiUpdateSipDomainRequest) (*ApiV2010AccountSipSipDomain, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipDomain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSipDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.byocTrunkSid != nil {
		localVarFormParams.Add("ByocTrunkSid", parameterToString(*r.byocTrunkSid, ""))
	}
	if r.domainName != nil {
		localVarFormParams.Add("DomainName", parameterToString(*r.domainName, ""))
	}
	if r.emergencyCallerSid != nil {
		localVarFormParams.Add("EmergencyCallerSid", parameterToString(*r.emergencyCallerSid, ""))
	}
	if r.emergencyCallingEnabled != nil {
		localVarFormParams.Add("EmergencyCallingEnabled", parameterToString(*r.emergencyCallingEnabled, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.secure != nil {
		localVarFormParams.Add("Secure", parameterToString(*r.secure, ""))
	}
	if r.sipRegistration != nil {
		localVarFormParams.Add("SipRegistration", parameterToString(*r.sipRegistration, ""))
	}
	if r.voiceFallbackMethod != nil {
		localVarFormParams.Add("VoiceFallbackMethod", parameterToString(*r.voiceFallbackMethod, ""))
	}
	if r.voiceFallbackUrl != nil {
		localVarFormParams.Add("VoiceFallbackUrl", parameterToString(*r.voiceFallbackUrl, ""))
	}
	if r.voiceMethod != nil {
		localVarFormParams.Add("VoiceMethod", parameterToString(*r.voiceMethod, ""))
	}
	if r.voiceStatusCallbackMethod != nil {
		localVarFormParams.Add("VoiceStatusCallbackMethod", parameterToString(*r.voiceStatusCallbackMethod, ""))
	}
	if r.voiceStatusCallbackUrl != nil {
		localVarFormParams.Add("VoiceStatusCallbackUrl", parameterToString(*r.voiceStatusCallbackUrl, ""))
	}
	if r.voiceUrl != nil {
		localVarFormParams.Add("VoiceUrl", parameterToString(*r.voiceUrl, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSipIpAccessControlListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	friendlyName *string
}

// A human readable descriptive text, up to 64 characters long.
func (r ApiUpdateSipIpAccessControlListRequest) FriendlyName(friendlyName string) ApiUpdateSipIpAccessControlListRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiUpdateSipIpAccessControlListRequest) Execute() (*ApiV2010AccountSipSipIpAccessControlList, *http.Response, error) {
	return r.ApiService.UpdateSipIpAccessControlListExecute(r)
}

/*
UpdateSipIpAccessControlList Method for UpdateSipIpAccessControlList

Rename an IpAccessControlList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param sid A 34 character string that uniquely identifies the resource to udpate.
 @return ApiUpdateSipIpAccessControlListRequest
*/
func (a *DefaultApiService) UpdateSipIpAccessControlList(ctx context.Context, accountSid string, sid string) ApiUpdateSipIpAccessControlListRequest {
	return ApiUpdateSipIpAccessControlListRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipIpAccessControlList
func (a *DefaultApiService) UpdateSipIpAccessControlListExecute(r ApiUpdateSipIpAccessControlListRequest) (*ApiV2010AccountSipSipIpAccessControlList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipIpAccessControlList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSipIpAccessControlList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}
	if r.friendlyName == nil {
		return localVarReturnValue, nil, reportError("friendlyName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSipIpAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	ipAccessControlListSid string
	sid string
	cidrPrefixLength *int32
	friendlyName *string
	ipAddress *string
}

// An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.
func (r ApiUpdateSipIpAddressRequest) CidrPrefixLength(cidrPrefixLength int32) ApiUpdateSipIpAddressRequest {
	r.cidrPrefixLength = &cidrPrefixLength
	return r
}

// A human readable descriptive text for this resource, up to 64 characters long.
func (r ApiUpdateSipIpAddressRequest) FriendlyName(friendlyName string) ApiUpdateSipIpAddressRequest {
	r.friendlyName = &friendlyName
	return r
}

// An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.
func (r ApiUpdateSipIpAddressRequest) IpAddress(ipAddress string) ApiUpdateSipIpAddressRequest {
	r.ipAddress = &ipAddress
	return r
}

func (r ApiUpdateSipIpAddressRequest) Execute() (*ApiV2010AccountSipSipIpAccessControlListSipIpAddress, *http.Response, error) {
	return r.ApiService.UpdateSipIpAddressExecute(r)
}

/*
UpdateSipIpAddress Method for UpdateSipIpAddress

Update an IpAddress resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
 @param ipAccessControlListSid The IpAccessControlList Sid that identifies the IpAddress resources to update.
 @param sid A 34 character string that identifies the IpAddress resource to update.
 @return ApiUpdateSipIpAddressRequest
*/
func (a *DefaultApiService) UpdateSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string) ApiUpdateSipIpAddressRequest {
	return ApiUpdateSipIpAddressRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		ipAccessControlListSid: ipAccessControlListSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountSipSipIpAccessControlListSipIpAddress
func (a *DefaultApiService) UpdateSipIpAddressExecute(r ApiUpdateSipIpAddressRequest) (*ApiV2010AccountSipSipIpAccessControlListSipIpAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountSipSipIpAccessControlListSipIpAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSipIpAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"IpAccessControlListSid"+"}", url.PathEscape(parameterToString(r.ipAccessControlListSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.ipAccessControlListSid) < 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have at least 34 elements")
	}
	if strlen(r.ipAccessControlListSid) > 34 {
		return localVarReturnValue, nil, reportError("ipAccessControlListSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cidrPrefixLength != nil {
		localVarFormParams.Add("CidrPrefixLength", parameterToString(*r.cidrPrefixLength, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	if r.ipAddress != nil {
		localVarFormParams.Add("IpAddress", parameterToString(*r.ipAddress, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiprecRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
	status *string
}

// The status. Must have the value &#x60;stopped&#x60;
func (r ApiUpdateSiprecRequest) Status(status string) ApiUpdateSiprecRequest {
	r.status = &status
	return r
}

func (r ApiUpdateSiprecRequest) Execute() (*ApiV2010AccountCallSiprec, *http.Response, error) {
	return r.ApiService.UpdateSiprecExecute(r)
}

/*
UpdateSiprec Method for UpdateSiprec

Stop a Siprec using either the SID of the Siprec resource or the `name` used when creating the resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created this Siprec resource.
 @param callSid The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the Siprec resource is associated with.
 @param sid The SID of the Siprec resource, or the `name` used when creating the resource
 @return ApiUpdateSiprecRequest
*/
func (a *DefaultApiService) UpdateSiprec(ctx context.Context, accountSid string, callSid string, sid string) ApiUpdateSiprecRequest {
	return ApiUpdateSiprecRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallSiprec
func (a *DefaultApiService) UpdateSiprecExecute(r ApiUpdateSiprecRequest) (*ApiV2010AccountCallSiprec, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallSiprec
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSiprec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStreamRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	callSid string
	sid string
	status *string
}

// The status. Must have the value &#x60;stopped&#x60;
func (r ApiUpdateStreamRequest) Status(status string) ApiUpdateStreamRequest {
	r.status = &status
	return r
}

func (r ApiUpdateStreamRequest) Execute() (*ApiV2010AccountCallStream, *http.Response, error) {
	return r.ApiService.UpdateStreamExecute(r)
}

/*
UpdateStream Method for UpdateStream

Stop a Stream using either the SID of the Stream resource or the `name` used when creating the resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created this Stream resource.
 @param callSid The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) the Stream resource is associated with.
 @param sid The SID of the Stream resource, or the `name` used when creating the resource
 @return ApiUpdateStreamRequest
*/
func (a *DefaultApiService) UpdateStream(ctx context.Context, accountSid string, callSid string, sid string) ApiUpdateStreamRequest {
	return ApiUpdateStreamRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		callSid: callSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountCallStream
func (a *DefaultApiService) UpdateStreamExecute(r ApiUpdateStreamRequest) (*ApiV2010AccountCallStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountCallStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"CallSid"+"}", url.PathEscape(parameterToString(r.callSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.callSid) < 34 {
		return localVarReturnValue, nil, reportError("callSid must have at least 34 elements")
	}
	if strlen(r.callSid) > 34 {
		return localVarReturnValue, nil, reportError("callSid must have less than 34 elements")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("Status", parameterToString(*r.status, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUsageTriggerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	accountSid string
	sid string
	callbackMethod *string
	callbackUrl *string
	friendlyName *string
}

// The HTTP method we should use to call &#x60;callback_url&#x60;. Can be: &#x60;GET&#x60; or &#x60;POST&#x60; and the default is &#x60;POST&#x60;.
func (r ApiUpdateUsageTriggerRequest) CallbackMethod(callbackMethod string) ApiUpdateUsageTriggerRequest {
	r.callbackMethod = &callbackMethod
	return r
}

// The URL we should call using &#x60;callback_method&#x60; when the trigger fires.
func (r ApiUpdateUsageTriggerRequest) CallbackUrl(callbackUrl string) ApiUpdateUsageTriggerRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
func (r ApiUpdateUsageTriggerRequest) FriendlyName(friendlyName string) ApiUpdateUsageTriggerRequest {
	r.friendlyName = &friendlyName
	return r
}

func (r ApiUpdateUsageTriggerRequest) Execute() (*ApiV2010AccountUsageUsageTrigger, *http.Response, error) {
	return r.ApiService.UpdateUsageTriggerExecute(r)
}

/*
UpdateUsageTrigger Method for UpdateUsageTrigger

Update an instance of a usage trigger

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountSid The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resources to update.
 @param sid The Twilio-provided string that uniquely identifies the UsageTrigger resource to update.
 @return ApiUpdateUsageTriggerRequest
*/
func (a *DefaultApiService) UpdateUsageTrigger(ctx context.Context, accountSid string, sid string) ApiUpdateUsageTriggerRequest {
	return ApiUpdateUsageTriggerRequest{
		ApiService: a,
		ctx: ctx,
		accountSid: accountSid,
		sid: sid,
	}
}

// Execute executes the request
//  @return ApiV2010AccountUsageUsageTrigger
func (a *DefaultApiService) UpdateUsageTriggerExecute(r ApiUpdateUsageTriggerRequest) (*ApiV2010AccountUsageUsageTrigger, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV2010AccountUsageUsageTrigger
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateUsageTrigger")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountSid"+"}", url.PathEscape(parameterToString(r.accountSid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"Sid"+"}", url.PathEscape(parameterToString(r.sid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.accountSid) < 34 {
		return localVarReturnValue, nil, reportError("accountSid must have at least 34 elements")
	}
	if strlen(r.accountSid) > 34 {
		return localVarReturnValue, nil, reportError("accountSid must have less than 34 elements")
	}
	if strlen(r.sid) < 34 {
		return localVarReturnValue, nil, reportError("sid must have at least 34 elements")
	}
	if strlen(r.sid) > 34 {
		return localVarReturnValue, nil, reportError("sid must have less than 34 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.callbackMethod != nil {
		localVarFormParams.Add("CallbackMethod", parameterToString(*r.callbackMethod, ""))
	}
	if r.callbackUrl != nil {
		localVarFormParams.Add("CallbackUrl", parameterToString(*r.callbackUrl, ""))
	}
	if r.friendlyName != nil {
		localVarFormParams.Add("FriendlyName", parameterToString(*r.friendlyName, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
